(window["webpackJsonp"] = window["webpackJsonp"] || []).push([
    ["chunk-vendors"], {
        "00ee": function(t, e, n) {
            var r = n("b622"),
                i = r("toStringTag"),
                o = {};
            o[i] = "z", t.exports = "[object z]" === String(o)
        },
        "0366": function(t, e, n) {
            var r = n("1c0b");
            t.exports = function(t, e, n) {
                if (r(t), void 0 === e) return t;
                switch (n) {
                    case 0:
                        return function() {
                            return t.call(e)
                        };
                    case 1:
                        return function(n) {
                            return t.call(e, n)
                        };
                    case 2:
                        return function(n, r) {
                            return t.call(e, n, r)
                        };
                    case 3:
                        return function(n, r, i) {
                            return t.call(e, n, r, i)
                        }
                }
                return function() {
                    return t.apply(e, arguments)
                }
            }
        },
        "0538": function(t, e, n) {
            "use strict";
            var r = n("1c0b"),
                i = n("861d"),
                o = [].slice,
                a = {},
                s = function(t, e, n) {
                    if (!(e in a)) {
                        for (var r = [], i = 0; i < e; i++) r[i] = "a[" + i + "]";
                        a[e] = Function("C,a", "return new C(" + r.join(",") + ")")
                    }
                    return a[e](t, n)
                };
            t.exports = Function.bind || function(t) {
                var e = r(this),
                    n = o.call(arguments, 1),
                    a = function() {
                        var r = n.concat(o.call(arguments));
                        return this instanceof a ? s(e, r.length, r) : e.apply(t, r)
                    };
                return i(e.prototype) && (a.prototype = e.prototype), a
            }
        },
        "057f": function(t, e, n) {
            var r = n("fc6a"),
                i = n("241c").f,
                o = {}.toString,
                a = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
                s = function(t) {
                    try {
                        return i(t)
                    } catch (e) {
                        return a.slice()
                    }
                };
            t.exports.f = function(t) {
                return a && "[object Window]" == o.call(t) ? s(t) : i(r(t))
            }
        },
        "06c5": function(t, e, n) {
            "use strict";
            n.d(e, "a", (function() {
                return i
            }));
            n("a630"), n("fb6a"), n("b0c0"), n("d3b7"), n("25f0"), n("3ca3");
            var r = n("6b75");

            function i(t, e) {
                if (t) {
                    if ("string" === typeof t) return Object(r["a"])(t, e);
                    var n = Object.prototype.toString.call(t).slice(8, -1);
                    return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Object(r["a"])(t, e) : void 0
                }
            }
        },
        "06cf": function(t, e, n) {
            var r = n("83ab"),
                i = n("d1e7"),
                o = n("5c6c"),
                a = n("fc6a"),
                s = n("c04e"),
                c = n("5135"),
                l = n("0cfb"),
                u = Object.getOwnPropertyDescriptor;
            e.f = r ? u : function(t, e) {
                if (t = a(t), e = s(e, !0), l) try {
                    return u(t, e)
                } catch (n) {}
                if (c(t, e)) return o(!i.f.call(t, e), t[e])
            }
        },
        "0b25": function(t, e, n) {
            var r = n("a691"),
                i = n("50c4");
            t.exports = function(t) {
                if (void 0 === t) return 0;
                var e = r(t),
                    n = i(e);
                if (e !== n) throw RangeError("Wrong length or index");
                return n
            }
        },
        "0cfb": function(t, e, n) {
            var r = n("83ab"),
                i = n("d039"),
                o = n("cc12");
            t.exports = !r && !i((function() {
                return 7 != Object.defineProperty(o("div"), "a", {
                    get: function() {
                        return 7
                    }
                }).a
            }))
        },
        1148: function(t, e, n) {
            "use strict";
            var r = n("a691"),
                i = n("1d80");
            t.exports = "".repeat || function(t) {
                var e = String(i(this)),
                    n = "",
                    o = r(t);
                if (o < 0 || o == 1 / 0) throw RangeError("Wrong number of repetitions");
                for (; o > 0;
                    (o >>>= 1) && (e += e)) 1 & o && (n += e);
                return n
            }
        },
        1276: function(t, e, n) {
            "use strict";
            var r = n("d784"),
                i = n("44e7"),
                o = n("825a"),
                a = n("1d80"),
                s = n("4840"),
                c = n("8aa5"),
                l = n("50c4"),
                u = n("14c3"),
                h = n("9263"),
                d = n("d039"),
                p = [].push,
                f = Math.min,
                m = 4294967295,
                g = !d((function() {
                    return !RegExp(m, "y")
                }));
            r("split", 2, (function(t, e, n) {
                var r;
                return r = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(t, n) {
                    var r = String(a(this)),
                        o = void 0 === n ? m : n >>> 0;
                    if (0 === o) return [];
                    if (void 0 === t) return [r];
                    if (!i(t)) return e.call(r, t, o);
                    var s, c, l, u = [],
                        d = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""),
                        f = 0,
                        g = new RegExp(t.source, d + "g");
                    while (s = h.call(g, r)) {
                        if (c = g.lastIndex, c > f && (u.push(r.slice(f, s.index)), s.length > 1 && s.index < r.length && p.apply(u, s.slice(1)), l = s[0].length, f = c, u.length >= o)) break;
                        g.lastIndex === s.index && g.lastIndex++
                    }
                    return f === r.length ? !l && g.test("") || u.push("") : u.push(r.slice(f)), u.length > o ? u.slice(0, o) : u
                } : "0".split(void 0, 0).length ? function(t, n) {
                    return void 0 === t && 0 === n ? [] : e.call(this, t, n)
                } : e, [function(e, n) {
                    var i = a(this),
                        o = void 0 == e ? void 0 : e[t];
                    return void 0 !== o ? o.call(e, i, n) : r.call(String(i), e, n)
                }, function(t, i) {
                    var a = n(r, t, this, i, r !== e);
                    if (a.done) return a.value;
                    var h = o(t),
                        d = String(this),
                        p = s(h, RegExp),
                        v = h.unicode,
                        y = (h.ignoreCase ? "i" : "") + (h.multiline ? "m" : "") + (h.unicode ? "u" : "") + (g ? "y" : "g"),
                        _ = new p(g ? h : "^(?:" + h.source + ")", y),
                        b = void 0 === i ? m : i >>> 0;
                    if (0 === b) return [];
                    if (0 === d.length) return null === u(_, d) ? [d] : [];
                    var x = 0,
                        w = 0,
                        M = [];
                    while (w < d.length) {
                        _.lastIndex = g ? w : 0;
                        var T, S = u(_, g ? d : d.slice(w));
                        if (null === S || (T = f(l(_.lastIndex + (g ? 0 : w)), d.length)) === x) w = c(d, w, v);
                        else {
                            if (M.push(d.slice(x, w)), M.length === b) return M;
                            for (var E = 1; E <= S.length - 1; E++)
                                if (M.push(S[E]), M.length === b) return M;
                            w = x = T
                        }
                    }
                    return M.push(d.slice(x)), M
                }]
            }), !g)
        },
        "145e": function(t, e, n) {
            "use strict";
            var r = n("7b0b"),
                i = n("23cb"),
                o = n("50c4"),
                a = Math.min;
            t.exports = [].copyWithin || function(t, e) {
                var n = r(this),
                    s = o(n.length),
                    c = i(t, s),
                    l = i(e, s),
                    u = arguments.length > 2 ? arguments[2] : void 0,
                    h = a((void 0 === u ? s : i(u, s)) - l, s - c),
                    d = 1;
                l < c && c < l + h && (d = -1, l += h - 1, c += h - 1);
                while (h-- > 0) l in n ? n[c] = n[l] : delete n[c], c += d, l += d;
                return n
            }
        },
        "14c3": function(t, e, n) {
            var r = n("c6b6"),
                i = n("9263");
            t.exports = function(t, e) {
                var n = t.exec;
                if ("function" === typeof n) {
                    var o = n.call(t, e);
                    if ("object" !== typeof o) throw TypeError("RegExp exec method returned something other than an Object or null");
                    return o
                }
                if ("RegExp" !== r(t)) throw TypeError("RegExp#exec called on incompatible receiver");
                return i.call(t, e)
            }
        },
        "159b": function(t, e, n) {
            var r = n("da84"),
                i = n("fdbc"),
                o = n("17c2"),
                a = n("9112");
            for (var s in i) {
                var c = r[s],
                    l = c && c.prototype;
                if (l && l.forEach !== o) try {
                    a(l, "forEach", o)
                } catch (u) {
                    l.forEach = o
                }
            }
        },
        "170b": function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("50c4"),
                o = n("23cb"),
                a = n("4840"),
                s = r.aTypedArray,
                c = r.exportTypedArrayMethod;
            c("subarray", (function(t, e) {
                var n = s(this),
                    r = n.length,
                    c = o(t, r);
                return new(a(n, n.constructor))(n.buffer, n.byteOffset + c * n.BYTES_PER_ELEMENT, i((void 0 === e ? r : o(e, r)) - c))
            }))
        },
        "17c2": function(t, e, n) {
            "use strict";
            var r = n("b727").forEach,
                i = n("a640"),
                o = n("ae40"),
                a = i("forEach"),
                s = o("forEach");
            t.exports = a && s ? [].forEach : function(t) {
                return r(this, t, arguments.length > 1 ? arguments[1] : void 0)
            }
        },
        "182d": function(t, e, n) {
            var r = n("f8cd");
            t.exports = function(t, e) {
                var n = r(t);
                if (n % e) throw RangeError("Wrong offset");
                return n
            }
        },
        "19aa": function(t, e) {
            t.exports = function(t, e, n) {
                if (!(t instanceof e)) throw TypeError("Incorrect " + (n ? n + " " : "") + "invocation");
                return t
            }
        },
        "1b53": function(t, e, n) {
            "use strict";
            n.d(e, "a", (function() {
                return i
            }));
            var r = n("5a89");

            function i() {
                this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
            }
            Object.assign(i.prototype, {
                setSize: function() {},
                render: function() {
                    console.error("THREE.Pass: .render() must be implemented in derived pass.")
                }
            }), i.FullScreenQuad = function() {
                var t = new r["gb"](-1, 1, 1, -1, 0, 1),
                    e = new r["jb"](2, 2),
                    n = function(t) {
                        this._mesh = new r["T"](e, t)
                    };
                return Object.defineProperty(n.prototype, "material", {
                    get: function() {
                        return this._mesh.material
                    },
                    set: function(t) {
                        this._mesh.material = t
                    }
                }), Object.assign(n.prototype, {
                    dispose: function() {
                        this._mesh.geometry.dispose()
                    },
                    render: function(e) {
                        e.render(this._mesh, t)
                    }
                }), n
            }()
        },
        "1be4": function(t, e, n) {
            var r = n("d066");
            t.exports = r("document", "documentElement")
        },
        "1c0b": function(t, e) {
            t.exports = function(t) {
                if ("function" != typeof t) throw TypeError(String(t) + " is not a function");
                return t
            }
        },
        "1c7e": function(t, e, n) {
            var r = n("b622"),
                i = r("iterator"),
                o = !1;
            try {
                var a = 0,
                    s = {
                        next: function() {
                            return {
                                done: !!a++
                            }
                        },
                        return: function() {
                            o = !0
                        }
                    };
                s[i] = function() {
                    return this
                }, Array.from(s, (function() {
                    throw 2
                }))
            } catch (c) {}
            t.exports = function(t, e) {
                if (!e && !o) return !1;
                var n = !1;
                try {
                    var r = {};
                    r[i] = function() {
                        return {
                            next: function() {
                                return {
                                    done: n = !0
                                }
                            }
                        }
                    }, t(r)
                } catch (c) {}
                return n
            }
        },
        "1cdc": function(t, e, n) {
            var r = n("342f");
            t.exports = /(iphone|ipod|ipad).*applewebkit/i.test(r)
        },
        "1d80": function(t, e) {
            t.exports = function(t) {
                if (void 0 == t) throw TypeError("Can't call method on " + t);
                return t
            }
        },
        "1dde": function(t, e, n) {
            var r = n("d039"),
                i = n("b622"),
                o = n("2d00"),
                a = i("species");
            t.exports = function(t) {
                return o >= 51 || !r((function() {
                    var e = [],
                        n = e.constructor = {};
                    return n[a] = function() {
                        return {
                            foo: 1
                        }
                    }, 1 !== e[t](Boolean).foo
                }))
            }
        },
        "1e5c": function(t, e, n) {
            (function(n) {
                var r, i;
                /*!
                 *  howler.js v2.2.0
                 *  howlerjs.com
                 *
                 *  (c) 2013-2020, James Simpson of GoldFire Studios
                 *  goldfirestudios.com
                 *
                 *  MIT License
                 */
                (function() {
                    "use strict";
                    var o = function() {
                        this.init()
                    };
                    o.prototype = {
                        init: function() {
                            var t = this || a;
                            return t._counter = 1e3, t._html5AudioPool = [], t.html5PoolSize = 10, t._codecs = {}, t._howls = [], t._muted = !1, t._volume = 1, t._canPlayEvent = "canplaythrough", t._navigator = "undefined" !== typeof window && window.navigator ? window.navigator : null, t.masterGain = null, t.noAudio = !1, t.usingWebAudio = !0, t.autoSuspend = !0, t.ctx = null, t.autoUnlock = !0, t._setup(), t
                        },
                        volume: function(t) {
                            var e = this || a;
                            if (t = parseFloat(t), e.ctx || f(), "undefined" !== typeof t && t >= 0 && t <= 1) {
                                if (e._volume = t, e._muted) return e;
                                e.usingWebAudio && e.masterGain.gain.setValueAtTime(t, a.ctx.currentTime);
                                for (var n = 0; n < e._howls.length; n++)
                                    if (!e._howls[n]._webAudio)
                                        for (var r = e._howls[n]._getSoundIds(), i = 0; i < r.length; i++) {
                                            var o = e._howls[n]._soundById(r[i]);
                                            o && o._node && (o._node.volume = o._volume * t)
                                        }
                                return e
                            }
                            return e._volume
                        },
                        mute: function(t) {
                            var e = this || a;
                            e.ctx || f(), e._muted = t, e.usingWebAudio && e.masterGain.gain.setValueAtTime(t ? 0 : e._volume, a.ctx.currentTime);
                            for (var n = 0; n < e._howls.length; n++)
                                if (!e._howls[n]._webAudio)
                                    for (var r = e._howls[n]._getSoundIds(), i = 0; i < r.length; i++) {
                                        var o = e._howls[n]._soundById(r[i]);
                                        o && o._node && (o._node.muted = !!t || o._muted)
                                    }
                            return e
                        },
                        stop: function() {
                            for (var t = this || a, e = 0; e < t._howls.length; e++) t._howls[e].stop();
                            return t
                        },
                        unload: function() {
                            for (var t = this || a, e = t._howls.length - 1; e >= 0; e--) t._howls[e].unload();
                            return t.usingWebAudio && t.ctx && "undefined" !== typeof t.ctx.close && (t.ctx.close(), t.ctx = null, f()), t
                        },
                        codecs: function(t) {
                            return (this || a)._codecs[t.replace(/^x-/, "")]
                        },
                        _setup: function() {
                            var t = this || a;
                            if (t.state = t.ctx && t.ctx.state || "suspended", t._autoSuspend(), !t.usingWebAudio)
                                if ("undefined" !== typeof Audio) try {
                                    var e = new Audio;
                                    "undefined" === typeof e.oncanplaythrough && (t._canPlayEvent = "canplay")
                                } catch (n) {
                                    t.noAudio = !0
                                } else t.noAudio = !0;
                            try {
                                e = new Audio;
                                e.muted && (t.noAudio = !0)
                            } catch (n) {}
                            return t.noAudio || t._setupCodecs(), t
                        },
                        _setupCodecs: function() {
                            var t = this || a,
                                e = null;
                            try {
                                e = "undefined" !== typeof Audio ? new Audio : null
                            } catch (o) {
                                return t
                            }
                            if (!e || "function" !== typeof e.canPlayType) return t;
                            var n = e.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                                r = t._navigator && t._navigator.userAgent.match(/OPR\/([0-6].)/g),
                                i = r && parseInt(r[0].split("/")[1], 10) < 33;
                            return t._codecs = {
                                mp3: !(i || !n && !e.canPlayType("audio/mp3;").replace(/^no$/, "")),
                                mpeg: !!n,
                                opus: !!e.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                                ogg: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                                oga: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                                wav: !!e.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
                                aac: !!e.canPlayType("audio/aac;").replace(/^no$/, ""),
                                caf: !!e.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                                m4a: !!(e.canPlayType("audio/x-m4a;") || e.canPlayType("audio/m4a;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
                                m4b: !!(e.canPlayType("audio/x-m4b;") || e.canPlayType("audio/m4b;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
                                mp4: !!(e.canPlayType("audio/x-mp4;") || e.canPlayType("audio/mp4;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
                                weba: !!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
                                webm: !!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
                                dolby: !!e.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                                flac: !!(e.canPlayType("audio/x-flac;") || e.canPlayType("audio/flac;")).replace(/^no$/, "")
                            }, t
                        },
                        _unlockAudio: function() {
                            var t = this || a;
                            if (!t._audioUnlocked && t.ctx) {
                                t._audioUnlocked = !1, t.autoUnlock = !1, t._mobileUnloaded || 44100 === t.ctx.sampleRate || (t._mobileUnloaded = !0, t.unload()), t._scratchBuffer = t.ctx.createBuffer(1, 1, 22050);
                                var e = function(n) {
                                    while (t._html5AudioPool.length < t.html5PoolSize) try {
                                        var r = new Audio;
                                        r._unlocked = !0, t._releaseHtml5Audio(r)
                                    } catch (n) {
                                        t.noAudio = !0;
                                        break
                                    }
                                    for (var i = 0; i < t._howls.length; i++)
                                        if (!t._howls[i]._webAudio)
                                            for (var o = t._howls[i]._getSoundIds(), a = 0; a < o.length; a++) {
                                                var s = t._howls[i]._soundById(o[a]);
                                                s && s._node && !s._node._unlocked && (s._node._unlocked = !0, s._node.load())
                                            }
                                    t._autoResume();
                                    var c = t.ctx.createBufferSource();
                                    c.buffer = t._scratchBuffer, c.connect(t.ctx.destination), "undefined" === typeof c.start ? c.noteOn(0) : c.start(0), "function" === typeof t.ctx.resume && t.ctx.resume(), c.onended = function() {
                                        c.disconnect(0), t._audioUnlocked = !0, document.removeEventListener("touchstart", e, !0), document.removeEventListener("touchend", e, !0), document.removeEventListener("click", e, !0);
                                        for (var n = 0; n < t._howls.length; n++) t._howls[n]._emit("unlock")
                                    }
                                };
                                return document.addEventListener("touchstart", e, !0), document.addEventListener("touchend", e, !0), document.addEventListener("click", e, !0), t
                            }
                        },
                        _obtainHtml5Audio: function() {
                            var t = this || a;
                            if (t._html5AudioPool.length) return t._html5AudioPool.pop();
                            var e = (new Audio).play();
                            return e && "undefined" !== typeof Promise && (e instanceof Promise || "function" === typeof e.then) && e.catch((function() {
                                console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")
                            })), new Audio
                        },
                        _releaseHtml5Audio: function(t) {
                            var e = this || a;
                            return t._unlocked && e._html5AudioPool.push(t), e
                        },
                        _autoSuspend: function() {
                            var t = this;
                            if (t.autoSuspend && t.ctx && "undefined" !== typeof t.ctx.suspend && a.usingWebAudio) {
                                for (var e = 0; e < t._howls.length; e++)
                                    if (t._howls[e]._webAudio)
                                        for (var n = 0; n < t._howls[e]._sounds.length; n++)
                                            if (!t._howls[e]._sounds[n]._paused) return t;
                                return t._suspendTimer && clearTimeout(t._suspendTimer), t._suspendTimer = setTimeout((function() {
                                    if (t.autoSuspend) {
                                        t._suspendTimer = null, t.state = "suspending";
                                        var e = function() {
                                            t.state = "suspended", t._resumeAfterSuspend && (delete t._resumeAfterSuspend, t._autoResume())
                                        };
                                        t.ctx.suspend().then(e, e)
                                    }
                                }), 3e4), t
                            }
                        },
                        _autoResume: function() {
                            var t = this;
                            if (t.ctx && "undefined" !== typeof t.ctx.resume && a.usingWebAudio) return "running" === t.state && "interrupted" !== t.ctx.state && t._suspendTimer ? (clearTimeout(t._suspendTimer), t._suspendTimer = null) : "suspended" === t.state || "running" === t.state && "interrupted" === t.ctx.state ? (t.ctx.resume().then((function() {
                                t.state = "running";
                                for (var e = 0; e < t._howls.length; e++) t._howls[e]._emit("resume")
                            })), t._suspendTimer && (clearTimeout(t._suspendTimer), t._suspendTimer = null)) : "suspending" === t.state && (t._resumeAfterSuspend = !0), t
                        }
                    };
                    var a = new o,
                        s = function(t) {
                            var e = this;
                            t.src && 0 !== t.src.length ? e.init(t) : console.error("An array of source files must be passed with any new Howl.")
                        };
                    s.prototype = {
                        init: function(t) {
                            var e = this;
                            return a.ctx || f(), e._autoplay = t.autoplay || !1, e._format = "string" !== typeof t.format ? t.format : [t.format], e._html5 = t.html5 || !1, e._muted = t.mute || !1, e._loop = t.loop || !1, e._pool = t.pool || 5, e._preload = "boolean" !== typeof t.preload && "metadata" !== t.preload || t.preload, e._rate = t.rate || 1, e._sprite = t.sprite || {}, e._src = "string" !== typeof t.src ? t.src : [t.src], e._volume = void 0 !== t.volume ? t.volume : 1, e._xhr = {
                                method: t.xhr && t.xhr.method ? t.xhr.method : "GET",
                                headers: t.xhr && t.xhr.headers ? t.xhr.headers : null,
                                withCredentials: !(!t.xhr || !t.xhr.withCredentials) && t.xhr.withCredentials
                            }, e._duration = 0, e._state = "unloaded", e._sounds = [], e._endTimers = {}, e._queue = [], e._playLock = !1, e._onend = t.onend ? [{
                                fn: t.onend
                            }] : [], e._onfade = t.onfade ? [{
                                fn: t.onfade
                            }] : [], e._onload = t.onload ? [{
                                fn: t.onload
                            }] : [], e._onloaderror = t.onloaderror ? [{
                                fn: t.onloaderror
                            }] : [], e._onplayerror = t.onplayerror ? [{
                                fn: t.onplayerror
                            }] : [], e._onpause = t.onpause ? [{
                                fn: t.onpause
                            }] : [], e._onplay = t.onplay ? [{
                                fn: t.onplay
                            }] : [], e._onstop = t.onstop ? [{
                                fn: t.onstop
                            }] : [], e._onmute = t.onmute ? [{
                                fn: t.onmute
                            }] : [], e._onvolume = t.onvolume ? [{
                                fn: t.onvolume
                            }] : [], e._onrate = t.onrate ? [{
                                fn: t.onrate
                            }] : [], e._onseek = t.onseek ? [{
                                fn: t.onseek
                            }] : [], e._onunlock = t.onunlock ? [{
                                fn: t.onunlock
                            }] : [], e._onresume = [], e._webAudio = a.usingWebAudio && !e._html5, "undefined" !== typeof a.ctx && a.ctx && a.autoUnlock && a._unlockAudio(), a._howls.push(e), e._autoplay && e._queue.push({
                                event: "play",
                                action: function() {
                                    e.play()
                                }
                            }), e._preload && "none" !== e._preload && e.load(), e
                        },
                        load: function() {
                            var t = this,
                                e = null;
                            if (a.noAudio) t._emit("loaderror", null, "No audio support.");
                            else {
                                "string" === typeof t._src && (t._src = [t._src]);
                                for (var n = 0; n < t._src.length; n++) {
                                    var r, i;
                                    if (t._format && t._format[n]) r = t._format[n];
                                    else {
                                        if (i = t._src[n], "string" !== typeof i) {
                                            t._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                                            continue
                                        }
                                        r = /^data:audio\/([^;,]+);/i.exec(i), r || (r = /\.([^.]+)$/.exec(i.split("?", 1)[0])), r && (r = r[1].toLowerCase())
                                    }
                                    if (r || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), r && a.codecs(r)) {
                                        e = t._src[n];
                                        break
                                    }
                                }
                                if (e) return t._src = e, t._state = "loading", "https:" === window.location.protocol && "http:" === e.slice(0, 5) && (t._html5 = !0, t._webAudio = !1), new c(t), t._webAudio && u(t), t;
                                t._emit("loaderror", null, "No codec support for selected audio sources.")
                            }
                        },
                        play: function(t, e) {
                            var n = this,
                                r = null;
                            if ("number" === typeof t) r = t, t = null;
                            else {
                                if ("string" === typeof t && "loaded" === n._state && !n._sprite[t]) return null;
                                if ("undefined" === typeof t && (t = "__default", !n._playLock)) {
                                    for (var i = 0, o = 0; o < n._sounds.length; o++) n._sounds[o]._paused && !n._sounds[o]._ended && (i++, r = n._sounds[o]._id);
                                    1 === i ? t = null : r = null
                                }
                            }
                            var s = r ? n._soundById(r) : n._inactiveSound();
                            if (!s) return null;
                            if (r && !t && (t = s._sprite || "__default"), "loaded" !== n._state) {
                                s._sprite = t, s._ended = !1;
                                var c = s._id;
                                return n._queue.push({
                                    event: "play",
                                    action: function() {
                                        n.play(c)
                                    }
                                }), c
                            }
                            if (r && !s._paused) return e || n._loadQueue("play"), s._id;
                            n._webAudio && a._autoResume();
                            var l = Math.max(0, s._seek > 0 ? s._seek : n._sprite[t][0] / 1e3),
                                u = Math.max(0, (n._sprite[t][0] + n._sprite[t][1]) / 1e3 - l),
                                h = 1e3 * u / Math.abs(s._rate),
                                d = n._sprite[t][0] / 1e3,
                                p = (n._sprite[t][0] + n._sprite[t][1]) / 1e3;
                            s._sprite = t, s._ended = !1;
                            var f = function() {
                                s._paused = !1, s._seek = l, s._start = d, s._stop = p, s._loop = !(!s._loop && !n._sprite[t][2])
                            };
                            if (!(l >= p)) {
                                var m = s._node;
                                if (n._webAudio) {
                                    var g = function() {
                                        n._playLock = !1, f(), n._refreshBuffer(s);
                                        var t = s._muted || n._muted ? 0 : s._volume;
                                        m.gain.setValueAtTime(t, a.ctx.currentTime), s._playStart = a.ctx.currentTime, "undefined" === typeof m.bufferSource.start ? s._loop ? m.bufferSource.noteGrainOn(0, l, 86400) : m.bufferSource.noteGrainOn(0, l, u) : s._loop ? m.bufferSource.start(0, l, 86400) : m.bufferSource.start(0, l, u), h !== 1 / 0 && (n._endTimers[s._id] = setTimeout(n._ended.bind(n, s), h)), e || setTimeout((function() {
                                            n._emit("play", s._id), n._loadQueue()
                                        }), 0)
                                    };
                                    "running" === a.state && "interrupted" !== a.ctx.state ? g() : (n._playLock = !0, n.once("resume", g), n._clearTimer(s._id))
                                } else {
                                    var v = function() {
                                        m.currentTime = l, m.muted = s._muted || n._muted || a._muted || m.muted, m.volume = s._volume * a.volume(), m.playbackRate = s._rate;
                                        try {
                                            var r = m.play();
                                            if (r && "undefined" !== typeof Promise && (r instanceof Promise || "function" === typeof r.then) ? (n._playLock = !0, f(), r.then((function() {
                                                    n._playLock = !1, m._unlocked = !0, e || (n._emit("play", s._id), n._loadQueue())
                                                })).catch((function() {
                                                    n._playLock = !1, n._emit("playerror", s._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), s._ended = !0, s._paused = !0
                                                }))) : e || (n._playLock = !1, f(), n._emit("play", s._id), n._loadQueue()), m.playbackRate = s._rate, m.paused) return void n._emit("playerror", s._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                            "__default" !== t || s._loop ? n._endTimers[s._id] = setTimeout(n._ended.bind(n, s), h) : (n._endTimers[s._id] = function() {
                                                n._ended(s), m.removeEventListener("ended", n._endTimers[s._id], !1)
                                            }, m.addEventListener("ended", n._endTimers[s._id], !1))
                                        } catch (i) {
                                            n._emit("playerror", s._id, i)
                                        }
                                    };
                                    "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === m.src && (m.src = n._src, m.load());
                                    var y = window && window.ejecta || !m.readyState && a._navigator.isCocoonJS;
                                    if (m.readyState >= 3 || y) v();
                                    else {
                                        n._playLock = !0;
                                        var _ = function() {
                                            v(), m.removeEventListener(a._canPlayEvent, _, !1)
                                        };
                                        m.addEventListener(a._canPlayEvent, _, !1), n._clearTimer(s._id)
                                    }
                                }
                                return s._id
                            }
                            n._ended(s)
                        },
                        pause: function(t) {
                            var e = this;
                            if ("loaded" !== e._state || e._playLock) return e._queue.push({
                                event: "pause",
                                action: function() {
                                    e.pause(t)
                                }
                            }), e;
                            for (var n = e._getSoundIds(t), r = 0; r < n.length; r++) {
                                e._clearTimer(n[r]);
                                var i = e._soundById(n[r]);
                                if (i && !i._paused && (i._seek = e.seek(n[r]), i._rateSeek = 0, i._paused = !0, e._stopFade(n[r]), i._node))
                                    if (e._webAudio) {
                                        if (!i._node.bufferSource) continue;
                                        "undefined" === typeof i._node.bufferSource.stop ? i._node.bufferSource.noteOff(0) : i._node.bufferSource.stop(0), e._cleanBuffer(i._node)
                                    } else isNaN(i._node.duration) && i._node.duration !== 1 / 0 || i._node.pause();
                                arguments[1] || e._emit("pause", i ? i._id : null)
                            }
                            return e
                        },
                        stop: function(t, e) {
                            var n = this;
                            if ("loaded" !== n._state || n._playLock) return n._queue.push({
                                event: "stop",
                                action: function() {
                                    n.stop(t)
                                }
                            }), n;
                            for (var r = n._getSoundIds(t), i = 0; i < r.length; i++) {
                                n._clearTimer(r[i]);
                                var o = n._soundById(r[i]);
                                o && (o._seek = o._start || 0, o._rateSeek = 0, o._paused = !0, o._ended = !0, n._stopFade(r[i]), o._node && (n._webAudio ? o._node.bufferSource && ("undefined" === typeof o._node.bufferSource.stop ? o._node.bufferSource.noteOff(0) : o._node.bufferSource.stop(0), n._cleanBuffer(o._node)) : isNaN(o._node.duration) && o._node.duration !== 1 / 0 || (o._node.currentTime = o._start || 0, o._node.pause(), o._node.duration === 1 / 0 && n._clearSound(o._node))), e || n._emit("stop", o._id))
                            }
                            return n
                        },
                        mute: function(t, e) {
                            var n = this;
                            if ("loaded" !== n._state || n._playLock) return n._queue.push({
                                event: "mute",
                                action: function() {
                                    n.mute(t, e)
                                }
                            }), n;
                            if ("undefined" === typeof e) {
                                if ("boolean" !== typeof t) return n._muted;
                                n._muted = t
                            }
                            for (var r = n._getSoundIds(e), i = 0; i < r.length; i++) {
                                var o = n._soundById(r[i]);
                                o && (o._muted = t, o._interval && n._stopFade(o._id), n._webAudio && o._node ? o._node.gain.setValueAtTime(t ? 0 : o._volume, a.ctx.currentTime) : o._node && (o._node.muted = !!a._muted || t), n._emit("mute", o._id))
                            }
                            return n
                        },
                        volume: function() {
                            var t, e, n, r = this,
                                i = arguments;
                            if (0 === i.length) return r._volume;
                            if (1 === i.length || 2 === i.length && "undefined" === typeof i[1]) {
                                var o = r._getSoundIds(),
                                    s = o.indexOf(i[0]);
                                s >= 0 ? e = parseInt(i[0], 10) : t = parseFloat(i[0])
                            } else i.length >= 2 && (t = parseFloat(i[0]), e = parseInt(i[1], 10));
                            if (!("undefined" !== typeof t && t >= 0 && t <= 1)) return n = e ? r._soundById(e) : r._sounds[0], n ? n._volume : 0;
                            if ("loaded" !== r._state || r._playLock) return r._queue.push({
                                event: "volume",
                                action: function() {
                                    r.volume.apply(r, i)
                                }
                            }), r;
                            "undefined" === typeof e && (r._volume = t), e = r._getSoundIds(e);
                            for (var c = 0; c < e.length; c++) n = r._soundById(e[c]), n && (n._volume = t, i[2] || r._stopFade(e[c]), r._webAudio && n._node && !n._muted ? n._node.gain.setValueAtTime(t, a.ctx.currentTime) : n._node && !n._muted && (n._node.volume = t * a.volume()), r._emit("volume", n._id));
                            return r
                        },
                        fade: function(t, e, n, r) {
                            var i = this;
                            if ("loaded" !== i._state || i._playLock) return i._queue.push({
                                event: "fade",
                                action: function() {
                                    i.fade(t, e, n, r)
                                }
                            }), i;
                            t = Math.min(Math.max(0, parseFloat(t)), 1), e = Math.min(Math.max(0, parseFloat(e)), 1), n = parseFloat(n), i.volume(t, r);
                            for (var o = i._getSoundIds(r), s = 0; s < o.length; s++) {
                                var c = i._soundById(o[s]);
                                if (c) {
                                    if (r || i._stopFade(o[s]), i._webAudio && !c._muted) {
                                        var l = a.ctx.currentTime,
                                            u = l + n / 1e3;
                                        c._volume = t, c._node.gain.setValueAtTime(t, l), c._node.gain.linearRampToValueAtTime(e, u)
                                    }
                                    i._startFadeInterval(c, t, e, n, o[s], "undefined" === typeof r)
                                }
                            }
                            return i
                        },
                        _startFadeInterval: function(t, e, n, r, i, o) {
                            var a = this,
                                s = e,
                                c = n - e,
                                l = Math.abs(c / .01),
                                u = Math.max(4, l > 0 ? r / l : r),
                                h = Date.now();
                            t._fadeTo = n, t._interval = setInterval((function() {
                                var i = (Date.now() - h) / r;
                                h = Date.now(), s += c * i, s = c < 0 ? Math.max(n, s) : Math.min(n, s), s = Math.round(100 * s) / 100, a._webAudio ? t._volume = s : a.volume(s, t._id, !0), o && (a._volume = s), (n < e && s <= n || n > e && s >= n) && (clearInterval(t._interval), t._interval = null, t._fadeTo = null, a.volume(n, t._id), a._emit("fade", t._id))
                            }), u)
                        },
                        _stopFade: function(t) {
                            var e = this,
                                n = e._soundById(t);
                            return n && n._interval && (e._webAudio && n._node.gain.cancelScheduledValues(a.ctx.currentTime), clearInterval(n._interval), n._interval = null, e.volume(n._fadeTo, t), n._fadeTo = null, e._emit("fade", t)), e
                        },
                        loop: function() {
                            var t, e, n, r = this,
                                i = arguments;
                            if (0 === i.length) return r._loop;
                            if (1 === i.length) {
                                if ("boolean" !== typeof i[0]) return n = r._soundById(parseInt(i[0], 10)), !!n && n._loop;
                                t = i[0], r._loop = t
                            } else 2 === i.length && (t = i[0], e = parseInt(i[1], 10));
                            for (var o = r._getSoundIds(e), a = 0; a < o.length; a++) n = r._soundById(o[a]), n && (n._loop = t, r._webAudio && n._node && n._node.bufferSource && (n._node.bufferSource.loop = t, t && (n._node.bufferSource.loopStart = n._start || 0, n._node.bufferSource.loopEnd = n._stop)));
                            return r
                        },
                        rate: function() {
                            var t, e, n, r = this,
                                i = arguments;
                            if (0 === i.length) e = r._sounds[0]._id;
                            else if (1 === i.length) {
                                var o = r._getSoundIds(),
                                    s = o.indexOf(i[0]);
                                s >= 0 ? e = parseInt(i[0], 10) : t = parseFloat(i[0])
                            } else 2 === i.length && (t = parseFloat(i[0]), e = parseInt(i[1], 10));
                            if ("number" !== typeof t) return n = r._soundById(e), n ? n._rate : r._rate;
                            if ("loaded" !== r._state || r._playLock) return r._queue.push({
                                event: "rate",
                                action: function() {
                                    r.rate.apply(r, i)
                                }
                            }), r;
                            "undefined" === typeof e && (r._rate = t), e = r._getSoundIds(e);
                            for (var c = 0; c < e.length; c++)
                                if (n = r._soundById(e[c]), n) {
                                    r.playing(e[c]) && (n._rateSeek = r.seek(e[c]), n._playStart = r._webAudio ? a.ctx.currentTime : n._playStart), n._rate = t, r._webAudio && n._node && n._node.bufferSource ? n._node.bufferSource.playbackRate.setValueAtTime(t, a.ctx.currentTime) : n._node && (n._node.playbackRate = t);
                                    var l = r.seek(e[c]),
                                        u = (r._sprite[n._sprite][0] + r._sprite[n._sprite][1]) / 1e3 - l,
                                        h = 1e3 * u / Math.abs(n._rate);
                                    !r._endTimers[e[c]] && n._paused || (r._clearTimer(e[c]), r._endTimers[e[c]] = setTimeout(r._ended.bind(r, n), h)), r._emit("rate", n._id)
                                }
                            return r
                        },
                        seek: function() {
                            var t, e, n = this,
                                r = arguments;
                            if (0 === r.length) e = n._sounds[0]._id;
                            else if (1 === r.length) {
                                var i = n._getSoundIds(),
                                    o = i.indexOf(r[0]);
                                o >= 0 ? e = parseInt(r[0], 10) : n._sounds.length && (e = n._sounds[0]._id, t = parseFloat(r[0]))
                            } else 2 === r.length && (t = parseFloat(r[0]), e = parseInt(r[1], 10));
                            if ("undefined" === typeof e) return n;
                            if ("loaded" !== n._state || n._playLock) return n._queue.push({
                                event: "seek",
                                action: function() {
                                    n.seek.apply(n, r)
                                }
                            }), n;
                            var s = n._soundById(e);
                            if (s) {
                                if (!("number" === typeof t && t >= 0)) {
                                    if (n._webAudio) {
                                        var c = n.playing(e) ? a.ctx.currentTime - s._playStart : 0,
                                            l = s._rateSeek ? s._rateSeek - s._seek : 0;
                                        return s._seek + (l + c * Math.abs(s._rate))
                                    }
                                    return s._node.currentTime
                                }
                                var u = n.playing(e);
                                u && n.pause(e, !0), s._seek = t, s._ended = !1, n._clearTimer(e), n._webAudio || !s._node || isNaN(s._node.duration) || (s._node.currentTime = t);
                                var h = function() {
                                    n._emit("seek", e), u && n.play(e, !0)
                                };
                                if (u && !n._webAudio) {
                                    var d = function() {
                                        n._playLock ? setTimeout(d, 0) : h()
                                    };
                                    setTimeout(d, 0)
                                } else h()
                            }
                            return n
                        },
                        playing: function(t) {
                            var e = this;
                            if ("number" === typeof t) {
                                var n = e._soundById(t);
                                return !!n && !n._paused
                            }
                            for (var r = 0; r < e._sounds.length; r++)
                                if (!e._sounds[r]._paused) return !0;
                            return !1
                        },
                        duration: function(t) {
                            var e = this,
                                n = e._duration,
                                r = e._soundById(t);
                            return r && (n = e._sprite[r._sprite][1] / 1e3), n
                        },
                        state: function() {
                            return this._state
                        },
                        unload: function() {
                            for (var t = this, e = t._sounds, n = 0; n < e.length; n++) e[n]._paused || t.stop(e[n]._id), t._webAudio || (t._clearSound(e[n]._node), e[n]._node.removeEventListener("error", e[n]._errorFn, !1), e[n]._node.removeEventListener(a._canPlayEvent, e[n]._loadFn, !1), a._releaseHtml5Audio(e[n]._node)), delete e[n]._node, t._clearTimer(e[n]._id);
                            var r = a._howls.indexOf(t);
                            r >= 0 && a._howls.splice(r, 1);
                            var i = !0;
                            for (n = 0; n < a._howls.length; n++)
                                if (a._howls[n]._src === t._src || t._src.indexOf(a._howls[n]._src) >= 0) {
                                    i = !1;
                                    break
                                }
                            return l && i && delete l[t._src], a.noAudio = !1, t._state = "unloaded", t._sounds = [], t = null, null
                        },
                        on: function(t, e, n, r) {
                            var i = this,
                                o = i["_on" + t];
                            return "function" === typeof e && o.push(r ? {
                                id: n,
                                fn: e,
                                once: r
                            } : {
                                id: n,
                                fn: e
                            }), i
                        },
                        off: function(t, e, n) {
                            var r = this,
                                i = r["_on" + t],
                                o = 0;
                            if ("number" === typeof e && (n = e, e = null), e || n)
                                for (o = 0; o < i.length; o++) {
                                    var a = n === i[o].id;
                                    if (e === i[o].fn && a || !e && a) {
                                        i.splice(o, 1);
                                        break
                                    }
                                } else if (t) r["_on" + t] = [];
                                else {
                                    var s = Object.keys(r);
                                    for (o = 0; o < s.length; o++) 0 === s[o].indexOf("_on") && Array.isArray(r[s[o]]) && (r[s[o]] = [])
                                }
                            return r
                        },
                        once: function(t, e, n) {
                            var r = this;
                            return r.on(t, e, n, 1), r
                        },
                        _emit: function(t, e, n) {
                            for (var r = this, i = r["_on" + t], o = i.length - 1; o >= 0; o--) i[o].id && i[o].id !== e && "load" !== t || (setTimeout(function(t) {
                                t.call(this, e, n)
                            }.bind(r, i[o].fn), 0), i[o].once && r.off(t, i[o].fn, i[o].id));
                            return r._loadQueue(t), r
                        },
                        _loadQueue: function(t) {
                            var e = this;
                            if (e._queue.length > 0) {
                                var n = e._queue[0];
                                n.event === t && (e._queue.shift(), e._loadQueue()), t || n.action()
                            }
                            return e
                        },
                        _ended: function(t) {
                            var e = this,
                                n = t._sprite;
                            if (!e._webAudio && t._node && !t._node.paused && !t._node.ended && t._node.currentTime < t._stop) return setTimeout(e._ended.bind(e, t), 100), e;
                            var r = !(!t._loop && !e._sprite[n][2]);
                            if (e._emit("end", t._id), !e._webAudio && r && e.stop(t._id, !0).play(t._id), e._webAudio && r) {
                                e._emit("play", t._id), t._seek = t._start || 0, t._rateSeek = 0, t._playStart = a.ctx.currentTime;
                                var i = 1e3 * (t._stop - t._start) / Math.abs(t._rate);
                                e._endTimers[t._id] = setTimeout(e._ended.bind(e, t), i)
                            }
                            return e._webAudio && !r && (t._paused = !0, t._ended = !0, t._seek = t._start || 0, t._rateSeek = 0, e._clearTimer(t._id), e._cleanBuffer(t._node), a._autoSuspend()), e._webAudio || r || e.stop(t._id, !0), e
                        },
                        _clearTimer: function(t) {
                            var e = this;
                            if (e._endTimers[t]) {
                                if ("function" !== typeof e._endTimers[t]) clearTimeout(e._endTimers[t]);
                                else {
                                    var n = e._soundById(t);
                                    n && n._node && n._node.removeEventListener("ended", e._endTimers[t], !1)
                                }
                                delete e._endTimers[t]
                            }
                            return e
                        },
                        _soundById: function(t) {
                            for (var e = this, n = 0; n < e._sounds.length; n++)
                                if (t === e._sounds[n]._id) return e._sounds[n];
                            return null
                        },
                        _inactiveSound: function() {
                            var t = this;
                            t._drain();
                            for (var e = 0; e < t._sounds.length; e++)
                                if (t._sounds[e]._ended) return t._sounds[e].reset();
                            return new c(t)
                        },
                        _drain: function() {
                            var t = this,
                                e = t._pool,
                                n = 0,
                                r = 0;
                            if (!(t._sounds.length < e)) {
                                for (r = 0; r < t._sounds.length; r++) t._sounds[r]._ended && n++;
                                for (r = t._sounds.length - 1; r >= 0; r--) {
                                    if (n <= e) return;
                                    t._sounds[r]._ended && (t._webAudio && t._sounds[r]._node && t._sounds[r]._node.disconnect(0), t._sounds.splice(r, 1), n--)
                                }
                            }
                        },
                        _getSoundIds: function(t) {
                            var e = this;
                            if ("undefined" === typeof t) {
                                for (var n = [], r = 0; r < e._sounds.length; r++) n.push(e._sounds[r]._id);
                                return n
                            }
                            return [t]
                        },
                        _refreshBuffer: function(t) {
                            var e = this;
                            return t._node.bufferSource = a.ctx.createBufferSource(), t._node.bufferSource.buffer = l[e._src], t._panner ? t._node.bufferSource.connect(t._panner) : t._node.bufferSource.connect(t._node), t._node.bufferSource.loop = t._loop, t._loop && (t._node.bufferSource.loopStart = t._start || 0, t._node.bufferSource.loopEnd = t._stop || 0), t._node.bufferSource.playbackRate.setValueAtTime(t._rate, a.ctx.currentTime), e
                        },
                        _cleanBuffer: function(t) {
                            var e = this,
                                n = a._navigator && a._navigator.vendor.indexOf("Apple") >= 0;
                            if (a._scratchBuffer && t.bufferSource && (t.bufferSource.onended = null, t.bufferSource.disconnect(0), n)) try {
                                t.bufferSource.buffer = a._scratchBuffer
                            } catch (r) {}
                            return t.bufferSource = null, e
                        },
                        _clearSound: function(t) {
                            var e = /MSIE |Trident\//.test(a._navigator && a._navigator.userAgent);
                            e || (t.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
                        }
                    };
                    var c = function(t) {
                        this._parent = t, this.init()
                    };
                    c.prototype = {
                        init: function() {
                            var t = this,
                                e = t._parent;
                            return t._muted = e._muted, t._loop = e._loop, t._volume = e._volume, t._rate = e._rate, t._seek = 0, t._paused = !0, t._ended = !0, t._sprite = "__default", t._id = ++a._counter, e._sounds.push(t), t.create(), t
                        },
                        create: function() {
                            var t = this,
                                e = t._parent,
                                n = a._muted || t._muted || t._parent._muted ? 0 : t._volume;
                            return e._webAudio ? (t._node = "undefined" === typeof a.ctx.createGain ? a.ctx.createGainNode() : a.ctx.createGain(), t._node.gain.setValueAtTime(n, a.ctx.currentTime), t._node.paused = !0, t._node.connect(a.masterGain)) : a.noAudio || (t._node = a._obtainHtml5Audio(), t._errorFn = t._errorListener.bind(t), t._node.addEventListener("error", t._errorFn, !1), t._loadFn = t._loadListener.bind(t), t._node.addEventListener(a._canPlayEvent, t._loadFn, !1), t._node.src = e._src, t._node.preload = !0 === e._preload ? "auto" : e._preload, t._node.volume = n * a.volume(), t._node.load()), t
                        },
                        reset: function() {
                            var t = this,
                                e = t._parent;
                            return t._muted = e._muted, t._loop = e._loop, t._volume = e._volume, t._rate = e._rate, t._seek = 0, t._rateSeek = 0, t._paused = !0, t._ended = !0, t._sprite = "__default", t._id = ++a._counter, t
                        },
                        _errorListener: function() {
                            var t = this;
                            t._parent._emit("loaderror", t._id, t._node.error ? t._node.error.code : 0), t._node.removeEventListener("error", t._errorFn, !1)
                        },
                        _loadListener: function() {
                            var t = this,
                                e = t._parent;
                            e._duration = Math.ceil(10 * t._node.duration) / 10, 0 === Object.keys(e._sprite).length && (e._sprite = {
                                __default: [0, 1e3 * e._duration]
                            }), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue()), t._node.removeEventListener(a._canPlayEvent, t._loadFn, !1)
                        }
                    };
                    var l = {},
                        u = function(t) {
                            var e = t._src;
                            if (l[e]) return t._duration = l[e].duration, void p(t);
                            if (/^data:[^;]+;base64,/.test(e)) {
                                for (var n = atob(e.split(",")[1]), r = new Uint8Array(n.length), i = 0; i < n.length; ++i) r[i] = n.charCodeAt(i);
                                d(r.buffer, t)
                            } else {
                                var o = new XMLHttpRequest;
                                o.open(t._xhr.method, e, !0), o.withCredentials = t._xhr.withCredentials, o.responseType = "arraybuffer", t._xhr.headers && Object.keys(t._xhr.headers).forEach((function(e) {
                                    o.setRequestHeader(e, t._xhr.headers[e])
                                })), o.onload = function() {
                                    var e = (o.status + "")[0];
                                    "0" === e || "2" === e || "3" === e ? d(o.response, t) : t._emit("loaderror", null, "Failed loading audio file with status: " + o.status + ".")
                                }, o.onerror = function() {
                                    t._webAudio && (t._html5 = !0, t._webAudio = !1, t._sounds = [], delete l[e], t.load())
                                }, h(o)
                            }
                        },
                        h = function(t) {
                            try {
                                t.send()
                            } catch (e) {
                                t.onerror()
                            }
                        },
                        d = function(t, e) {
                            var n = function() {
                                    e._emit("loaderror", null, "Decoding audio data failed.")
                                },
                                r = function(t) {
                                    t && e._sounds.length > 0 ? (l[e._src] = t, p(e, t)) : n()
                                };
                            "undefined" !== typeof Promise && 1 === a.ctx.decodeAudioData.length ? a.ctx.decodeAudioData(t).then(r).catch(n) : a.ctx.decodeAudioData(t, r, n)
                        },
                        p = function(t, e) {
                            e && !t._duration && (t._duration = e.duration), 0 === Object.keys(t._sprite).length && (t._sprite = {
                                __default: [0, 1e3 * t._duration]
                            }), "loaded" !== t._state && (t._state = "loaded", t._emit("load"), t._loadQueue())
                        },
                        f = function() {
                            if (a.usingWebAudio) {
                                try {
                                    "undefined" !== typeof AudioContext ? a.ctx = new AudioContext : "undefined" !== typeof webkitAudioContext ? a.ctx = new webkitAudioContext : a.usingWebAudio = !1
                                } catch (i) {
                                    a.usingWebAudio = !1
                                }
                                a.ctx || (a.usingWebAudio = !1);
                                var t = /iP(hone|od|ad)/.test(a._navigator && a._navigator.platform),
                                    e = a._navigator && a._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                                    n = e ? parseInt(e[1], 10) : null;
                                if (t && n && n < 9) {
                                    var r = /safari/.test(a._navigator && a._navigator.userAgent.toLowerCase());
                                    a._navigator && !r && (a.usingWebAudio = !1)
                                }
                                a.usingWebAudio && (a.masterGain = "undefined" === typeof a.ctx.createGain ? a.ctx.createGainNode() : a.ctx.createGain(), a.masterGain.gain.setValueAtTime(a._muted ? 0 : a._volume, a.ctx.currentTime), a.masterGain.connect(a.ctx.destination)), a._setup()
                            }
                        };
                    r = [], i = function() {
                        return {
                            Howler: a,
                            Howl: s
                        }
                    }.apply(e, r), void 0 === i || (t.exports = i), e.Howler = a, e.Howl = s, "undefined" !== typeof n ? (n.HowlerGlobal = o, n.Howler = a, n.Howl = s, n.Sound = c) : "undefined" !== typeof window && (window.HowlerGlobal = o, window.Howler = a, window.Howl = s, window.Sound = c)
                })(),
                /*!
                 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
                 *  
                 *  howler.js v2.2.0
                 *  howlerjs.com
                 *
                 *  (c) 2013-2020, James Simpson of GoldFire Studios
                 *  goldfirestudios.com
                 *
                 *  MIT License
                 */
                function() {
                    "use strict";
                    HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(t) {
                        var e = this;
                        if (!e.ctx || !e.ctx.listener) return e;
                        for (var n = e._howls.length - 1; n >= 0; n--) e._howls[n].stereo(t);
                        return e
                    }, HowlerGlobal.prototype.pos = function(t, e, n) {
                        var r = this;
                        return r.ctx && r.ctx.listener ? (e = "number" !== typeof e ? r._pos[1] : e, n = "number" !== typeof n ? r._pos[2] : n, "number" !== typeof t ? r._pos : (r._pos = [t, e, n], "undefined" !== typeof r.ctx.listener.positionX ? (r.ctx.listener.positionX.setTargetAtTime(r._pos[0], Howler.ctx.currentTime, .1), r.ctx.listener.positionY.setTargetAtTime(r._pos[1], Howler.ctx.currentTime, .1), r.ctx.listener.positionZ.setTargetAtTime(r._pos[2], Howler.ctx.currentTime, .1)) : r.ctx.listener.setPosition(r._pos[0], r._pos[1], r._pos[2]), r)) : r
                    }, HowlerGlobal.prototype.orientation = function(t, e, n, r, i, o) {
                        var a = this;
                        if (!a.ctx || !a.ctx.listener) return a;
                        var s = a._orientation;
                        return e = "number" !== typeof e ? s[1] : e, n = "number" !== typeof n ? s[2] : n, r = "number" !== typeof r ? s[3] : r, i = "number" !== typeof i ? s[4] : i, o = "number" !== typeof o ? s[5] : o, "number" !== typeof t ? s : (a._orientation = [t, e, n, r, i, o], "undefined" !== typeof a.ctx.listener.forwardX ? (a.ctx.listener.forwardX.setTargetAtTime(t, Howler.ctx.currentTime, .1), a.ctx.listener.forwardY.setTargetAtTime(e, Howler.ctx.currentTime, .1), a.ctx.listener.forwardZ.setTargetAtTime(n, Howler.ctx.currentTime, .1), a.ctx.listener.upX.setTargetAtTime(r, Howler.ctx.currentTime, .1), a.ctx.listener.upY.setTargetAtTime(i, Howler.ctx.currentTime, .1), a.ctx.listener.upZ.setTargetAtTime(o, Howler.ctx.currentTime, .1)) : a.ctx.listener.setOrientation(t, e, n, r, i, o), a)
                    }, Howl.prototype.init = function(t) {
                        return function(e) {
                            var n = this;
                            return n._orientation = e.orientation || [1, 0, 0], n._stereo = e.stereo || null, n._pos = e.pos || null, n._pannerAttr = {
                                coneInnerAngle: "undefined" !== typeof e.coneInnerAngle ? e.coneInnerAngle : 360,
                                coneOuterAngle: "undefined" !== typeof e.coneOuterAngle ? e.coneOuterAngle : 360,
                                coneOuterGain: "undefined" !== typeof e.coneOuterGain ? e.coneOuterGain : 0,
                                distanceModel: "undefined" !== typeof e.distanceModel ? e.distanceModel : "inverse",
                                maxDistance: "undefined" !== typeof e.maxDistance ? e.maxDistance : 1e4,
                                panningModel: "undefined" !== typeof e.panningModel ? e.panningModel : "HRTF",
                                refDistance: "undefined" !== typeof e.refDistance ? e.refDistance : 1,
                                rolloffFactor: "undefined" !== typeof e.rolloffFactor ? e.rolloffFactor : 1
                            }, n._onstereo = e.onstereo ? [{
                                fn: e.onstereo
                            }] : [], n._onpos = e.onpos ? [{
                                fn: e.onpos
                            }] : [], n._onorientation = e.onorientation ? [{
                                fn: e.onorientation
                            }] : [], t.call(this, e)
                        }
                    }(Howl.prototype.init), Howl.prototype.stereo = function(e, n) {
                        var r = this;
                        if (!r._webAudio) return r;
                        if ("loaded" !== r._state) return r._queue.push({
                            event: "stereo",
                            action: function() {
                                r.stereo(e, n)
                            }
                        }), r;
                        var i = "undefined" === typeof Howler.ctx.createStereoPanner ? "spatial" : "stereo";
                        if ("undefined" === typeof n) {
                            if ("number" !== typeof e) return r._stereo;
                            r._stereo = e, r._pos = [e, 0, 0]
                        }
                        for (var o = r._getSoundIds(n), a = 0; a < o.length; a++) {
                            var s = r._soundById(o[a]);
                            if (s) {
                                if ("number" !== typeof e) return s._stereo;
                                s._stereo = e, s._pos = [e, 0, 0], s._node && (s._pannerAttr.panningModel = "equalpower", s._panner && s._panner.pan || t(s, i), "spatial" === i ? "undefined" !== typeof s._panner.positionX ? (s._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), s._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), s._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : s._panner.setPosition(e, 0, 0) : s._panner.pan.setValueAtTime(e, Howler.ctx.currentTime)), r._emit("stereo", s._id)
                            }
                        }
                        return r
                    }, Howl.prototype.pos = function(e, n, r, i) {
                        var o = this;
                        if (!o._webAudio) return o;
                        if ("loaded" !== o._state) return o._queue.push({
                            event: "pos",
                            action: function() {
                                o.pos(e, n, r, i)
                            }
                        }), o;
                        if (n = "number" !== typeof n ? 0 : n, r = "number" !== typeof r ? -.5 : r, "undefined" === typeof i) {
                            if ("number" !== typeof e) return o._pos;
                            o._pos = [e, n, r]
                        }
                        for (var a = o._getSoundIds(i), s = 0; s < a.length; s++) {
                            var c = o._soundById(a[s]);
                            if (c) {
                                if ("number" !== typeof e) return c._pos;
                                c._pos = [e, n, r], c._node && (c._panner && !c._panner.pan || t(c, "spatial"), "undefined" !== typeof c._panner.positionX ? (c._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), c._panner.positionY.setValueAtTime(n, Howler.ctx.currentTime), c._panner.positionZ.setValueAtTime(r, Howler.ctx.currentTime)) : c._panner.setPosition(e, n, r)), o._emit("pos", c._id)
                            }
                        }
                        return o
                    }, Howl.prototype.orientation = function(e, n, r, i) {
                        var o = this;
                        if (!o._webAudio) return o;
                        if ("loaded" !== o._state) return o._queue.push({
                            event: "orientation",
                            action: function() {
                                o.orientation(e, n, r, i)
                            }
                        }), o;
                        if (n = "number" !== typeof n ? o._orientation[1] : n, r = "number" !== typeof r ? o._orientation[2] : r, "undefined" === typeof i) {
                            if ("number" !== typeof e) return o._orientation;
                            o._orientation = [e, n, r]
                        }
                        for (var a = o._getSoundIds(i), s = 0; s < a.length; s++) {
                            var c = o._soundById(a[s]);
                            if (c) {
                                if ("number" !== typeof e) return c._orientation;
                                c._orientation = [e, n, r], c._node && (c._panner || (c._pos || (c._pos = o._pos || [0, 0, -.5]), t(c, "spatial")), "undefined" !== typeof c._panner.orientationX ? (c._panner.orientationX.setValueAtTime(e, Howler.ctx.currentTime), c._panner.orientationY.setValueAtTime(n, Howler.ctx.currentTime), c._panner.orientationZ.setValueAtTime(r, Howler.ctx.currentTime)) : c._panner.setOrientation(e, n, r)), o._emit("orientation", c._id)
                            }
                        }
                        return o
                    }, Howl.prototype.pannerAttr = function() {
                        var e, n, r, i = this,
                            o = arguments;
                        if (!i._webAudio) return i;
                        if (0 === o.length) return i._pannerAttr;
                        if (1 === o.length) {
                            if ("object" !== typeof o[0]) return r = i._soundById(parseInt(o[0], 10)), r ? r._pannerAttr : i._pannerAttr;
                            e = o[0], "undefined" === typeof n && (e.pannerAttr || (e.pannerAttr = {
                                coneInnerAngle: e.coneInnerAngle,
                                coneOuterAngle: e.coneOuterAngle,
                                coneOuterGain: e.coneOuterGain,
                                distanceModel: e.distanceModel,
                                maxDistance: e.maxDistance,
                                refDistance: e.refDistance,
                                rolloffFactor: e.rolloffFactor,
                                panningModel: e.panningModel
                            }), i._pannerAttr = {
                                coneInnerAngle: "undefined" !== typeof e.pannerAttr.coneInnerAngle ? e.pannerAttr.coneInnerAngle : i._coneInnerAngle,
                                coneOuterAngle: "undefined" !== typeof e.pannerAttr.coneOuterAngle ? e.pannerAttr.coneOuterAngle : i._coneOuterAngle,
                                coneOuterGain: "undefined" !== typeof e.pannerAttr.coneOuterGain ? e.pannerAttr.coneOuterGain : i._coneOuterGain,
                                distanceModel: "undefined" !== typeof e.pannerAttr.distanceModel ? e.pannerAttr.distanceModel : i._distanceModel,
                                maxDistance: "undefined" !== typeof e.pannerAttr.maxDistance ? e.pannerAttr.maxDistance : i._maxDistance,
                                refDistance: "undefined" !== typeof e.pannerAttr.refDistance ? e.pannerAttr.refDistance : i._refDistance,
                                rolloffFactor: "undefined" !== typeof e.pannerAttr.rolloffFactor ? e.pannerAttr.rolloffFactor : i._rolloffFactor,
                                panningModel: "undefined" !== typeof e.pannerAttr.panningModel ? e.pannerAttr.panningModel : i._panningModel
                            })
                        } else 2 === o.length && (e = o[0], n = parseInt(o[1], 10));
                        for (var a = i._getSoundIds(n), s = 0; s < a.length; s++)
                            if (r = i._soundById(a[s]), r) {
                                var c = r._pannerAttr;
                                c = {
                                    coneInnerAngle: "undefined" !== typeof e.coneInnerAngle ? e.coneInnerAngle : c.coneInnerAngle,
                                    coneOuterAngle: "undefined" !== typeof e.coneOuterAngle ? e.coneOuterAngle : c.coneOuterAngle,
                                    coneOuterGain: "undefined" !== typeof e.coneOuterGain ? e.coneOuterGain : c.coneOuterGain,
                                    distanceModel: "undefined" !== typeof e.distanceModel ? e.distanceModel : c.distanceModel,
                                    maxDistance: "undefined" !== typeof e.maxDistance ? e.maxDistance : c.maxDistance,
                                    refDistance: "undefined" !== typeof e.refDistance ? e.refDistance : c.refDistance,
                                    rolloffFactor: "undefined" !== typeof e.rolloffFactor ? e.rolloffFactor : c.rolloffFactor,
                                    panningModel: "undefined" !== typeof e.panningModel ? e.panningModel : c.panningModel
                                };
                                var l = r._panner;
                                l ? (l.coneInnerAngle = c.coneInnerAngle, l.coneOuterAngle = c.coneOuterAngle, l.coneOuterGain = c.coneOuterGain, l.distanceModel = c.distanceModel, l.maxDistance = c.maxDistance, l.refDistance = c.refDistance, l.rolloffFactor = c.rolloffFactor, l.panningModel = c.panningModel) : (r._pos || (r._pos = i._pos || [0, 0, -.5]), t(r, "spatial"))
                            }
                        return i
                    }, Sound.prototype.init = function(t) {
                        return function() {
                            var e = this,
                                n = e._parent;
                            e._orientation = n._orientation, e._stereo = n._stereo, e._pos = n._pos, e._pannerAttr = n._pannerAttr, t.call(this), e._stereo ? n.stereo(e._stereo) : e._pos && n.pos(e._pos[0], e._pos[1], e._pos[2], e._id)
                        }
                    }(Sound.prototype.init), Sound.prototype.reset = function(t) {
                        return function() {
                            var e = this,
                                n = e._parent;
                            return e._orientation = n._orientation, e._stereo = n._stereo, e._pos = n._pos, e._pannerAttr = n._pannerAttr, e._stereo ? n.stereo(e._stereo) : e._pos ? n.pos(e._pos[0], e._pos[1], e._pos[2], e._id) : e._panner && (e._panner.disconnect(0), e._panner = void 0, n._refreshBuffer(e)), t.call(this)
                        }
                    }(Sound.prototype.reset);
                    var t = function(t, e) {
                        e = e || "spatial", "spatial" === e ? (t._panner = Howler.ctx.createPanner(), t._panner.coneInnerAngle = t._pannerAttr.coneInnerAngle, t._panner.coneOuterAngle = t._pannerAttr.coneOuterAngle, t._panner.coneOuterGain = t._pannerAttr.coneOuterGain, t._panner.distanceModel = t._pannerAttr.distanceModel, t._panner.maxDistance = t._pannerAttr.maxDistance, t._panner.refDistance = t._pannerAttr.refDistance, t._panner.rolloffFactor = t._pannerAttr.rolloffFactor, t._panner.panningModel = t._pannerAttr.panningModel, "undefined" !== typeof t._panner.positionX ? (t._panner.positionX.setValueAtTime(t._pos[0], Howler.ctx.currentTime), t._panner.positionY.setValueAtTime(t._pos[1], Howler.ctx.currentTime), t._panner.positionZ.setValueAtTime(t._pos[2], Howler.ctx.currentTime)) : t._panner.setPosition(t._pos[0], t._pos[1], t._pos[2]), "undefined" !== typeof t._panner.orientationX ? (t._panner.orientationX.setValueAtTime(t._orientation[0], Howler.ctx.currentTime), t._panner.orientationY.setValueAtTime(t._orientation[1], Howler.ctx.currentTime), t._panner.orientationZ.setValueAtTime(t._orientation[2], Howler.ctx.currentTime)) : t._panner.setOrientation(t._orientation[0], t._orientation[1], t._orientation[2])) : (t._panner = Howler.ctx.createStereoPanner(), t._panner.pan.setValueAtTime(t._stereo, Howler.ctx.currentTime)), t._panner.connect(t._node), t._paused || t._parent.pause(t._id, !0).play(t._id, !0)
                    }
                }()
            }).call(this, n("c8ba"))
        },
        "219c": function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = r.aTypedArray,
                o = r.exportTypedArrayMethod,
                a = [].sort;
            o("sort", (function(t) {
                return a.call(i(this), t)
            }))
        },
        2266: function(t, e, n) {
            var r = n("825a"),
                i = n("e95a"),
                o = n("50c4"),
                a = n("0366"),
                s = n("35a1"),
                c = n("9bdd"),
                l = function(t, e) {
                    this.stopped = t, this.result = e
                },
                u = t.exports = function(t, e, n, u, h) {
                    var d, p, f, m, g, v, y, _ = a(e, n, u ? 2 : 1);
                    if (h) d = t;
                    else {
                        if (p = s(t), "function" != typeof p) throw TypeError("Target is not iterable");
                        if (i(p)) {
                            for (f = 0, m = o(t.length); m > f; f++)
                                if (g = u ? _(r(y = t[f])[0], y[1]) : _(t[f]), g && g instanceof l) return g;
                            return new l(!1)
                        }
                        d = p.call(t)
                    }
                    v = d.next;
                    while (!(y = v.call(d)).done)
                        if (g = c(d, _, y.value, u), "object" == typeof g && g && g instanceof l) return g;
                    return new l(!1)
                };
            u.stop = function(t) {
                return new l(!0, t)
            }
        },
        "23cb": function(t, e, n) {
            var r = n("a691"),
                i = Math.max,
                o = Math.min;
            t.exports = function(t, e) {
                var n = r(t);
                return n < 0 ? i(n + e, 0) : o(n, e)
            }
        },
        "23e7": function(t, e, n) {
            var r = n("da84"),
                i = n("06cf").f,
                o = n("9112"),
                a = n("6eeb"),
                s = n("ce4e"),
                c = n("e893"),
                l = n("94ca");
            t.exports = function(t, e) {
                var n, u, h, d, p, f, m = t.target,
                    g = t.global,
                    v = t.stat;
                if (u = g ? r : v ? r[m] || s(m, {}) : (r[m] || {}).prototype, u)
                    for (h in e) {
                        if (p = e[h], t.noTargetGet ? (f = i(u, h), d = f && f.value) : d = u[h], n = l(g ? h : m + (v ? "." : "#") + h, t.forced), !n && void 0 !== d) {
                            if (typeof p === typeof d) continue;
                            c(p, d)
                        }(t.sham || d && d.sham) && o(p, "sham", !0), a(u, h, p, t)
                    }
            }
        },
        "241c": function(t, e, n) {
            var r = n("ca84"),
                i = n("7839"),
                o = i.concat("length", "prototype");
            e.f = Object.getOwnPropertyNames || function(t) {
                return r(t, o)
            }
        },
        2532: function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("5a34"),
                o = n("1d80"),
                a = n("ab13");
            r({
                target: "String",
                proto: !0,
                forced: !a("includes")
            }, {
                includes: function(t) {
                    return !!~String(o(this)).indexOf(i(t), arguments.length > 1 ? arguments[1] : void 0)
                }
            })
        },
        "257e": function(t, e, n) {
            "use strict";

            function r(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }
            n.d(e, "a", (function() {
                return r
            }))
        },
        "25a1": function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("d58f").right,
                o = r.aTypedArray,
                a = r.exportTypedArrayMethod;
            a("reduceRight", (function(t) {
                return i(o(this), t, arguments.length, arguments.length > 1 ? arguments[1] : void 0)
            }))
        },
        "25f0": function(t, e, n) {
            "use strict";
            var r = n("6eeb"),
                i = n("825a"),
                o = n("d039"),
                a = n("ad6d"),
                s = "toString",
                c = RegExp.prototype,
                l = c[s],
                u = o((function() {
                    return "/a/b" != l.call({
                        source: "a",
                        flags: "b"
                    })
                })),
                h = l.name != s;
            (u || h) && r(RegExp.prototype, s, (function() {
                var t = i(this),
                    e = String(t.source),
                    n = t.flags,
                    r = String(void 0 === n && t instanceof RegExp && !("flags" in c) ? a.call(t) : n);
                return "/" + e + "/" + r
            }), {
                unsafe: !0
            })
        },
        2626: function(t, e, n) {
            "use strict";
            var r = n("d066"),
                i = n("9bf2"),
                o = n("b622"),
                a = n("83ab"),
                s = o("species");
            t.exports = function(t) {
                var e = r(t),
                    n = i.f;
                a && e && !e[s] && n(e, s, {
                    configurable: !0,
                    get: function() {
                        return this
                    }
                })
            }
        },
        "262e": function(t, e, n) {
            "use strict";

            function r(t, e) {
                return r = Object.setPrototypeOf || function(t, e) {
                    return t.__proto__ = e, t
                }, r(t, e)
            }

            function i(t, e) {
                if ("function" !== typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && r(t, e)
            }
            n.d(e, "a", (function() {
                return i
            }))
        },
        2877: function(t, e, n) {
            "use strict";

            function r(t, e, n, r, i, o, a, s) {
                var c, l = "function" === typeof t ? t.options : t;
                if (e && (l.render = e, l.staticRenderFns = n, l._compiled = !0), r && (l.functional = !0), o && (l._scopeId = "data-v-" + o), a ? (c = function(t) {
                        t = t || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext, t || "undefined" === typeof __VUE_SSR_CONTEXT__ || (t = __VUE_SSR_CONTEXT__), i && i.call(this, t), t && t._registeredComponents && t._registeredComponents.add(a)
                    }, l._ssrRegister = c) : i && (c = s ? function() {
                        i.call(this, (l.functional ? this.parent : this).$root.$options.shadowRoot)
                    } : i), c)
                    if (l.functional) {
                        l._injectStyles = c;
                        var u = l.render;
                        l.render = function(t, e) {
                            return c.call(e), u(t, e)
                        }
                    } else {
                        var h = l.beforeCreate;
                        l.beforeCreate = h ? [].concat(h, c) : [c]
                    }
                return {
                    exports: t,
                    options: l
                }
            }
            n.d(e, "a", (function() {
                return r
            }))
        },
        2909: function(t, e, n) {
            "use strict";
            n.d(e, "a", (function() {
                return c
            }));
            var r = n("6b75");

            function i(t) {
                if (Array.isArray(t)) return Object(r["a"])(t)
            }
            n("a4d3"), n("e01a"), n("d28b"), n("a630"), n("d3b7"), n("3ca3"), n("ddb0");

            function o(t) {
                if ("undefined" !== typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }
            var a = n("06c5");

            function s() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }

            function c(t) {
                return i(t) || o(t) || Object(a["a"])(t) || s()
            }
        },
        2954: function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("4840"),
                o = n("d039"),
                a = r.aTypedArray,
                s = r.aTypedArrayConstructor,
                c = r.exportTypedArrayMethod,
                l = [].slice,
                u = o((function() {
                    new Int8Array(1).slice()
                }));
            c("slice", (function(t, e) {
                var n = l.call(a(this), t, e),
                    r = i(this, this.constructor),
                    o = 0,
                    c = n.length,
                    u = new(s(r))(c);
                while (c > o) u[o] = n[o++];
                return u
            }), u)
        },
        "2b0e": function(t, e, n) {
            "use strict";
            (function(t) {
                /*!
                 * Vue.js v2.6.11
                 * (c) 2014-2019 Evan You
                 * Released under the MIT License.
                 */
                var n = Object.freeze({});

                function r(t) {
                    return void 0 === t || null === t
                }

                function i(t) {
                    return void 0 !== t && null !== t
                }

                function o(t) {
                    return !0 === t
                }

                function a(t) {
                    return !1 === t
                }

                function s(t) {
                    return "string" === typeof t || "number" === typeof t || "symbol" === typeof t || "boolean" === typeof t
                }

                function c(t) {
                    return null !== t && "object" === typeof t
                }
                var l = Object.prototype.toString;

                function u(t) {
                    return "[object Object]" === l.call(t)
                }

                function h(t) {
                    return "[object RegExp]" === l.call(t)
                }

                function d(t) {
                    var e = parseFloat(String(t));
                    return e >= 0 && Math.floor(e) === e && isFinite(t)
                }

                function p(t) {
                    return i(t) && "function" === typeof t.then && "function" === typeof t.catch
                }

                function f(t) {
                    return null == t ? "" : Array.isArray(t) || u(t) && t.toString === l ? JSON.stringify(t, null, 2) : String(t)
                }

                function m(t) {
                    var e = parseFloat(t);
                    return isNaN(e) ? t : e
                }

                function g(t, e) {
                    for (var n = Object.create(null), r = t.split(","), i = 0; i < r.length; i++) n[r[i]] = !0;
                    return e ? function(t) {
                        return n[t.toLowerCase()]
                    } : function(t) {
                        return n[t]
                    }
                }
                g("slot,component", !0);
                var v = g("key,ref,slot,slot-scope,is");

                function y(t, e) {
                    if (t.length) {
                        var n = t.indexOf(e);
                        if (n > -1) return t.splice(n, 1)
                    }
                }
                var _ = Object.prototype.hasOwnProperty;

                function b(t, e) {
                    return _.call(t, e)
                }

                function x(t) {
                    var e = Object.create(null);
                    return function(n) {
                        var r = e[n];
                        return r || (e[n] = t(n))
                    }
                }
                var w = /-(\w)/g,
                    M = x((function(t) {
                        return t.replace(w, (function(t, e) {
                            return e ? e.toUpperCase() : ""
                        }))
                    })),
                    T = x((function(t) {
                        return t.charAt(0).toUpperCase() + t.slice(1)
                    })),
                    S = /\B([A-Z])/g,
                    E = x((function(t) {
                        return t.replace(S, "-$1").toLowerCase()
                    }));

                function A(t, e) {
                    function n(n) {
                        var r = arguments.length;
                        return r ? r > 1 ? t.apply(e, arguments) : t.call(e, n) : t.call(e)
                    }
                    return n._length = t.length, n
                }

                function L(t, e) {
                    return t.bind(e)
                }
                var R = Function.prototype.bind ? L : A;

                function C(t, e) {
                    e = e || 0;
                    var n = t.length - e,
                        r = new Array(n);
                    while (n--) r[n] = t[n + e];
                    return r
                }

                function O(t, e) {
                    for (var n in e) t[n] = e[n];
                    return t
                }

                function P(t) {
                    for (var e = {}, n = 0; n < t.length; n++) t[n] && O(e, t[n]);
                    return e
                }

                function I(t, e, n) {}
                var N = function(t, e, n) {
                        return !1
                    },
                    D = function(t) {
                        return t
                    };

                function k(t, e) {
                    if (t === e) return !0;
                    var n = c(t),
                        r = c(e);
                    if (!n || !r) return !n && !r && String(t) === String(e);
                    try {
                        var i = Array.isArray(t),
                            o = Array.isArray(e);
                        if (i && o) return t.length === e.length && t.every((function(t, n) {
                            return k(t, e[n])
                        }));
                        if (t instanceof Date && e instanceof Date) return t.getTime() === e.getTime();
                        if (i || o) return !1;
                        var a = Object.keys(t),
                            s = Object.keys(e);
                        return a.length === s.length && a.every((function(n) {
                            return k(t[n], e[n])
                        }))
                    } catch (l) {
                        return !1
                    }
                }

                function F(t, e) {
                    for (var n = 0; n < t.length; n++)
                        if (k(t[n], e)) return n;
                    return -1
                }

                function B(t) {
                    var e = !1;
                    return function() {
                        e || (e = !0, t.apply(this, arguments))
                    }
                }
                var U = "data-server-rendered",
                    H = ["component", "directive", "filter"],
                    z = ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeDestroy", "destroyed", "activated", "deactivated", "errorCaptured", "serverPrefetch"],
                    j = {
                        optionMergeStrategies: Object.create(null),
                        silent: !1,
                        productionTip: !1,
                        devtools: !1,
                        performance: !1,
                        errorHandler: null,
                        warnHandler: null,
                        ignoredElements: [],
                        keyCodes: Object.create(null),
                        isReservedTag: N,
                        isReservedAttr: N,
                        isUnknownElement: N,
                        getTagNamespace: I,
                        parsePlatformTagName: D,
                        mustUseProp: N,
                        async: !0,
                        _lifecycleHooks: z
                    },
                    G = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

                function V(t) {
                    var e = (t + "").charCodeAt(0);
                    return 36 === e || 95 === e
                }

                function W(t, e, n, r) {
                    Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !!r,
                        writable: !0,
                        configurable: !0
                    })
                }
                var X = new RegExp("[^" + G.source + ".$_\\d]");

                function q(t) {
                    if (!X.test(t)) {
                        var e = t.split(".");
                        return function(t) {
                            for (var n = 0; n < e.length; n++) {
                                if (!t) return;
                                t = t[e[n]]
                            }
                            return t
                        }
                    }
                }
                var Y, $ = "__proto__" in {},
                    Z = "undefined" !== typeof window,
                    J = "undefined" !== typeof WXEnvironment && !!WXEnvironment.platform,
                    K = J && WXEnvironment.platform.toLowerCase(),
                    Q = Z && window.navigator.userAgent.toLowerCase(),
                    tt = Q && /msie|trident/.test(Q),
                    et = Q && Q.indexOf("msie 9.0") > 0,
                    nt = Q && Q.indexOf("edge/") > 0,
                    rt = (Q && Q.indexOf("android"), Q && /iphone|ipad|ipod|ios/.test(Q) || "ios" === K),
                    it = (Q && /chrome\/\d+/.test(Q), Q && /phantomjs/.test(Q), Q && Q.match(/firefox\/(\d+)/)),
                    ot = {}.watch,
                    at = !1;
                if (Z) try {
                    var st = {};
                    Object.defineProperty(st, "passive", {
                        get: function() {
                            at = !0
                        }
                    }), window.addEventListener("test-passive", null, st)
                } catch (Ma) {}
                var ct = function() {
                        return void 0 === Y && (Y = !Z && !J && "undefined" !== typeof t && (t["process"] && "server" === t["process"].env.VUE_ENV)), Y
                    },
                    lt = Z && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

                function ut(t) {
                    return "function" === typeof t && /native code/.test(t.toString())
                }
                var ht, dt = "undefined" !== typeof Symbol && ut(Symbol) && "undefined" !== typeof Reflect && ut(Reflect.ownKeys);
                ht = "undefined" !== typeof Set && ut(Set) ? Set : function() {
                    function t() {
                        this.set = Object.create(null)
                    }
                    return t.prototype.has = function(t) {
                        return !0 === this.set[t]
                    }, t.prototype.add = function(t) {
                        this.set[t] = !0
                    }, t.prototype.clear = function() {
                        this.set = Object.create(null)
                    }, t
                }();
                var pt = I,
                    ft = 0,
                    mt = function() {
                        this.id = ft++, this.subs = []
                    };
                mt.prototype.addSub = function(t) {
                    this.subs.push(t)
                }, mt.prototype.removeSub = function(t) {
                    y(this.subs, t)
                }, mt.prototype.depend = function() {
                    mt.target && mt.target.addDep(this)
                }, mt.prototype.notify = function() {
                    var t = this.subs.slice();
                    for (var e = 0, n = t.length; e < n; e++) t[e].update()
                }, mt.target = null;
                var gt = [];

                function vt(t) {
                    gt.push(t), mt.target = t
                }

                function yt() {
                    gt.pop(), mt.target = gt[gt.length - 1]
                }
                var _t = function(t, e, n, r, i, o, a, s) {
                        this.tag = t, this.data = e, this.children = n, this.text = r, this.elm = i, this.ns = void 0, this.context = o, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = e && e.key, this.componentOptions = a, this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, this.asyncFactory = s, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1
                    },
                    bt = {
                        child: {
                            configurable: !0
                        }
                    };
                bt.child.get = function() {
                    return this.componentInstance
                }, Object.defineProperties(_t.prototype, bt);
                var xt = function(t) {
                    void 0 === t && (t = "");
                    var e = new _t;
                    return e.text = t, e.isComment = !0, e
                };

                function wt(t) {
                    return new _t(void 0, void 0, void 0, String(t))
                }

                function Mt(t) {
                    var e = new _t(t.tag, t.data, t.children && t.children.slice(), t.text, t.elm, t.context, t.componentOptions, t.asyncFactory);
                    return e.ns = t.ns, e.isStatic = t.isStatic, e.key = t.key, e.isComment = t.isComment, e.fnContext = t.fnContext, e.fnOptions = t.fnOptions, e.fnScopeId = t.fnScopeId, e.asyncMeta = t.asyncMeta, e.isCloned = !0, e
                }
                var Tt = Array.prototype,
                    St = Object.create(Tt),
                    Et = ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"];
                Et.forEach((function(t) {
                    var e = Tt[t];
                    W(St, t, (function() {
                        var n = [],
                            r = arguments.length;
                        while (r--) n[r] = arguments[r];
                        var i, o = e.apply(this, n),
                            a = this.__ob__;
                        switch (t) {
                            case "push":
                            case "unshift":
                                i = n;
                                break;
                            case "splice":
                                i = n.slice(2);
                                break
                        }
                        return i && a.observeArray(i), a.dep.notify(), o
                    }))
                }));
                var At = Object.getOwnPropertyNames(St),
                    Lt = !0;

                function Rt(t) {
                    Lt = t
                }
                var Ct = function(t) {
                    this.value = t, this.dep = new mt, this.vmCount = 0, W(t, "__ob__", this), Array.isArray(t) ? ($ ? Ot(t, St) : Pt(t, St, At), this.observeArray(t)) : this.walk(t)
                };

                function Ot(t, e) {
                    t.__proto__ = e
                }

                function Pt(t, e, n) {
                    for (var r = 0, i = n.length; r < i; r++) {
                        var o = n[r];
                        W(t, o, e[o])
                    }
                }

                function It(t, e) {
                    var n;
                    if (c(t) && !(t instanceof _t)) return b(t, "__ob__") && t.__ob__ instanceof Ct ? n = t.__ob__ : Lt && !ct() && (Array.isArray(t) || u(t)) && Object.isExtensible(t) && !t._isVue && (n = new Ct(t)), e && n && n.vmCount++, n
                }

                function Nt(t, e, n, r, i) {
                    var o = new mt,
                        a = Object.getOwnPropertyDescriptor(t, e);
                    if (!a || !1 !== a.configurable) {
                        var s = a && a.get,
                            c = a && a.set;
                        s && !c || 2 !== arguments.length || (n = t[e]);
                        var l = !i && It(n);
                        Object.defineProperty(t, e, {
                            enumerable: !0,
                            configurable: !0,
                            get: function() {
                                var e = s ? s.call(t) : n;
                                return mt.target && (o.depend(), l && (l.dep.depend(), Array.isArray(e) && Ft(e))), e
                            },
                            set: function(e) {
                                var r = s ? s.call(t) : n;
                                e === r || e !== e && r !== r || s && !c || (c ? c.call(t, e) : n = e, l = !i && It(e), o.notify())
                            }
                        })
                    }
                }

                function Dt(t, e, n) {
                    if (Array.isArray(t) && d(e)) return t.length = Math.max(t.length, e), t.splice(e, 1, n), n;
                    if (e in t && !(e in Object.prototype)) return t[e] = n, n;
                    var r = t.__ob__;
                    return t._isVue || r && r.vmCount ? n : r ? (Nt(r.value, e, n), r.dep.notify(), n) : (t[e] = n, n)
                }

                function kt(t, e) {
                    if (Array.isArray(t) && d(e)) t.splice(e, 1);
                    else {
                        var n = t.__ob__;
                        t._isVue || n && n.vmCount || b(t, e) && (delete t[e], n && n.dep.notify())
                    }
                }

                function Ft(t) {
                    for (var e = void 0, n = 0, r = t.length; n < r; n++) e = t[n], e && e.__ob__ && e.__ob__.dep.depend(), Array.isArray(e) && Ft(e)
                }
                Ct.prototype.walk = function(t) {
                    for (var e = Object.keys(t), n = 0; n < e.length; n++) Nt(t, e[n])
                }, Ct.prototype.observeArray = function(t) {
                    for (var e = 0, n = t.length; e < n; e++) It(t[e])
                };
                var Bt = j.optionMergeStrategies;

                function Ut(t, e) {
                    if (!e) return t;
                    for (var n, r, i, o = dt ? Reflect.ownKeys(e) : Object.keys(e), a = 0; a < o.length; a++) n = o[a], "__ob__" !== n && (r = t[n], i = e[n], b(t, n) ? r !== i && u(r) && u(i) && Ut(r, i) : Dt(t, n, i));
                    return t
                }

                function Ht(t, e, n) {
                    return n ? function() {
                        var r = "function" === typeof e ? e.call(n, n) : e,
                            i = "function" === typeof t ? t.call(n, n) : t;
                        return r ? Ut(r, i) : i
                    } : e ? t ? function() {
                        return Ut("function" === typeof e ? e.call(this, this) : e, "function" === typeof t ? t.call(this, this) : t)
                    } : e : t
                }

                function zt(t, e) {
                    var n = e ? t ? t.concat(e) : Array.isArray(e) ? e : [e] : t;
                    return n ? jt(n) : n
                }

                function jt(t) {
                    for (var e = [], n = 0; n < t.length; n++) - 1 === e.indexOf(t[n]) && e.push(t[n]);
                    return e
                }

                function Gt(t, e, n, r) {
                    var i = Object.create(t || null);
                    return e ? O(i, e) : i
                }
                Bt.data = function(t, e, n) {
                    return n ? Ht(t, e, n) : e && "function" !== typeof e ? t : Ht(t, e)
                }, z.forEach((function(t) {
                    Bt[t] = zt
                })), H.forEach((function(t) {
                    Bt[t + "s"] = Gt
                })), Bt.watch = function(t, e, n, r) {
                    if (t === ot && (t = void 0), e === ot && (e = void 0), !e) return Object.create(t || null);
                    if (!t) return e;
                    var i = {};
                    for (var o in O(i, t), e) {
                        var a = i[o],
                            s = e[o];
                        a && !Array.isArray(a) && (a = [a]), i[o] = a ? a.concat(s) : Array.isArray(s) ? s : [s]
                    }
                    return i
                }, Bt.props = Bt.methods = Bt.inject = Bt.computed = function(t, e, n, r) {
                    if (!t) return e;
                    var i = Object.create(null);
                    return O(i, t), e && O(i, e), i
                }, Bt.provide = Ht;
                var Vt = function(t, e) {
                    return void 0 === e ? t : e
                };

                function Wt(t, e) {
                    var n = t.props;
                    if (n) {
                        var r, i, o, a = {};
                        if (Array.isArray(n)) {
                            r = n.length;
                            while (r--) i = n[r], "string" === typeof i && (o = M(i), a[o] = {
                                type: null
                            })
                        } else if (u(n))
                            for (var s in n) i = n[s], o = M(s), a[o] = u(i) ? i : {
                                type: i
                            };
                        else 0;
                        t.props = a
                    }
                }

                function Xt(t, e) {
                    var n = t.inject;
                    if (n) {
                        var r = t.inject = {};
                        if (Array.isArray(n))
                            for (var i = 0; i < n.length; i++) r[n[i]] = {
                                from: n[i]
                            };
                        else if (u(n))
                            for (var o in n) {
                                var a = n[o];
                                r[o] = u(a) ? O({
                                    from: o
                                }, a) : {
                                    from: a
                                }
                            } else 0
                    }
                }

                function qt(t) {
                    var e = t.directives;
                    if (e)
                        for (var n in e) {
                            var r = e[n];
                            "function" === typeof r && (e[n] = {
                                bind: r,
                                update: r
                            })
                        }
                }

                function Yt(t, e, n) {
                    if ("function" === typeof e && (e = e.options), Wt(e, n), Xt(e, n), qt(e), !e._base && (e.extends && (t = Yt(t, e.extends, n)), e.mixins))
                        for (var r = 0, i = e.mixins.length; r < i; r++) t = Yt(t, e.mixins[r], n);
                    var o, a = {};
                    for (o in t) s(o);
                    for (o in e) b(t, o) || s(o);

                    function s(r) {
                        var i = Bt[r] || Vt;
                        a[r] = i(t[r], e[r], n, r)
                    }
                    return a
                }

                function $t(t, e, n, r) {
                    if ("string" === typeof n) {
                        var i = t[e];
                        if (b(i, n)) return i[n];
                        var o = M(n);
                        if (b(i, o)) return i[o];
                        var a = T(o);
                        if (b(i, a)) return i[a];
                        var s = i[n] || i[o] || i[a];
                        return s
                    }
                }

                function Zt(t, e, n, r) {
                    var i = e[t],
                        o = !b(n, t),
                        a = n[t],
                        s = te(Boolean, i.type);
                    if (s > -1)
                        if (o && !b(i, "default")) a = !1;
                        else if ("" === a || a === E(t)) {
                        var c = te(String, i.type);
                        (c < 0 || s < c) && (a = !0)
                    }
                    if (void 0 === a) {
                        a = Jt(r, i, t);
                        var l = Lt;
                        Rt(!0), It(a), Rt(l)
                    }
                    return a
                }

                function Jt(t, e, n) {
                    if (b(e, "default")) {
                        var r = e.default;
                        return t && t.$options.propsData && void 0 === t.$options.propsData[n] && void 0 !== t._props[n] ? t._props[n] : "function" === typeof r && "Function" !== Kt(e.type) ? r.call(t) : r
                    }
                }

                function Kt(t) {
                    var e = t && t.toString().match(/^\s*function (\w+)/);
                    return e ? e[1] : ""
                }

                function Qt(t, e) {
                    return Kt(t) === Kt(e)
                }

                function te(t, e) {
                    if (!Array.isArray(e)) return Qt(e, t) ? 0 : -1;
                    for (var n = 0, r = e.length; n < r; n++)
                        if (Qt(e[n], t)) return n;
                    return -1
                }

                function ee(t, e, n) {
                    vt();
                    try {
                        if (e) {
                            var r = e;
                            while (r = r.$parent) {
                                var i = r.$options.errorCaptured;
                                if (i)
                                    for (var o = 0; o < i.length; o++) try {
                                        var a = !1 === i[o].call(r, t, e, n);
                                        if (a) return
                                    } catch (Ma) {
                                        re(Ma, r, "errorCaptured hook")
                                    }
                            }
                        }
                        re(t, e, n)
                    } finally {
                        yt()
                    }
                }

                function ne(t, e, n, r, i) {
                    var o;
                    try {
                        o = n ? t.apply(e, n) : t.call(e), o && !o._isVue && p(o) && !o._handled && (o.catch((function(t) {
                            return ee(t, r, i + " (Promise/async)")
                        })), o._handled = !0)
                    } catch (Ma) {
                        ee(Ma, r, i)
                    }
                    return o
                }

                function re(t, e, n) {
                    if (j.errorHandler) try {
                        return j.errorHandler.call(null, t, e, n)
                    } catch (Ma) {
                        Ma !== t && ie(Ma, null, "config.errorHandler")
                    }
                    ie(t, e, n)
                }

                function ie(t, e, n) {
                    if (!Z && !J || "undefined" === typeof console) throw t;
                    console.error(t)
                }
                var oe, ae = !1,
                    se = [],
                    ce = !1;

                function le() {
                    ce = !1;
                    var t = se.slice(0);
                    se.length = 0;
                    for (var e = 0; e < t.length; e++) t[e]()
                }
                if ("undefined" !== typeof Promise && ut(Promise)) {
                    var ue = Promise.resolve();
                    oe = function() {
                        ue.then(le), rt && setTimeout(I)
                    }, ae = !0
                } else if (tt || "undefined" === typeof MutationObserver || !ut(MutationObserver) && "[object MutationObserverConstructor]" !== MutationObserver.toString()) oe = "undefined" !== typeof setImmediate && ut(setImmediate) ? function() {
                    setImmediate(le)
                } : function() {
                    setTimeout(le, 0)
                };
                else {
                    var he = 1,
                        de = new MutationObserver(le),
                        pe = document.createTextNode(String(he));
                    de.observe(pe, {
                        characterData: !0
                    }), oe = function() {
                        he = (he + 1) % 2, pe.data = String(he)
                    }, ae = !0
                }

                function fe(t, e) {
                    var n;
                    if (se.push((function() {
                            if (t) try {
                                t.call(e)
                            } catch (Ma) {
                                ee(Ma, e, "nextTick")
                            } else n && n(e)
                        })), ce || (ce = !0, oe()), !t && "undefined" !== typeof Promise) return new Promise((function(t) {
                        n = t
                    }))
                }
                var me = new ht;

                function ge(t) {
                    ve(t, me), me.clear()
                }

                function ve(t, e) {
                    var n, r, i = Array.isArray(t);
                    if (!(!i && !c(t) || Object.isFrozen(t) || t instanceof _t)) {
                        if (t.__ob__) {
                            var o = t.__ob__.dep.id;
                            if (e.has(o)) return;
                            e.add(o)
                        }
                        if (i) {
                            n = t.length;
                            while (n--) ve(t[n], e)
                        } else {
                            r = Object.keys(t), n = r.length;
                            while (n--) ve(t[r[n]], e)
                        }
                    }
                }
                var ye = x((function(t) {
                    var e = "&" === t.charAt(0);
                    t = e ? t.slice(1) : t;
                    var n = "~" === t.charAt(0);
                    t = n ? t.slice(1) : t;
                    var r = "!" === t.charAt(0);
                    return t = r ? t.slice(1) : t, {
                        name: t,
                        once: n,
                        capture: r,
                        passive: e
                    }
                }));

                function _e(t, e) {
                    function n() {
                        var t = arguments,
                            r = n.fns;
                        if (!Array.isArray(r)) return ne(r, null, arguments, e, "v-on handler");
                        for (var i = r.slice(), o = 0; o < i.length; o++) ne(i[o], null, t, e, "v-on handler")
                    }
                    return n.fns = t, n
                }

                function be(t, e, n, i, a, s) {
                    var c, l, u, h;
                    for (c in t) l = t[c], u = e[c], h = ye(c), r(l) || (r(u) ? (r(l.fns) && (l = t[c] = _e(l, s)), o(h.once) && (l = t[c] = a(h.name, l, h.capture)), n(h.name, l, h.capture, h.passive, h.params)) : l !== u && (u.fns = l, t[c] = u));
                    for (c in e) r(t[c]) && (h = ye(c), i(h.name, e[c], h.capture))
                }

                function xe(t, e, n) {
                    var a;
                    t instanceof _t && (t = t.data.hook || (t.data.hook = {}));
                    var s = t[e];

                    function c() {
                        n.apply(this, arguments), y(a.fns, c)
                    }
                    r(s) ? a = _e([c]) : i(s.fns) && o(s.merged) ? (a = s, a.fns.push(c)) : a = _e([s, c]), a.merged = !0, t[e] = a
                }

                function we(t, e, n) {
                    var o = e.options.props;
                    if (!r(o)) {
                        var a = {},
                            s = t.attrs,
                            c = t.props;
                        if (i(s) || i(c))
                            for (var l in o) {
                                var u = E(l);
                                Me(a, c, l, u, !0) || Me(a, s, l, u, !1)
                            }
                        return a
                    }
                }

                function Me(t, e, n, r, o) {
                    if (i(e)) {
                        if (b(e, n)) return t[n] = e[n], o || delete e[n], !0;
                        if (b(e, r)) return t[n] = e[r], o || delete e[r], !0
                    }
                    return !1
                }

                function Te(t) {
                    for (var e = 0; e < t.length; e++)
                        if (Array.isArray(t[e])) return Array.prototype.concat.apply([], t);
                    return t
                }

                function Se(t) {
                    return s(t) ? [wt(t)] : Array.isArray(t) ? Ae(t) : void 0
                }

                function Ee(t) {
                    return i(t) && i(t.text) && a(t.isComment)
                }

                function Ae(t, e) {
                    var n, a, c, l, u = [];
                    for (n = 0; n < t.length; n++) a = t[n], r(a) || "boolean" === typeof a || (c = u.length - 1, l = u[c], Array.isArray(a) ? a.length > 0 && (a = Ae(a, (e || "") + "_" + n), Ee(a[0]) && Ee(l) && (u[c] = wt(l.text + a[0].text), a.shift()), u.push.apply(u, a)) : s(a) ? Ee(l) ? u[c] = wt(l.text + a) : "" !== a && u.push(wt(a)) : Ee(a) && Ee(l) ? u[c] = wt(l.text + a.text) : (o(t._isVList) && i(a.tag) && r(a.key) && i(e) && (a.key = "__vlist" + e + "_" + n + "__"), u.push(a)));
                    return u
                }

                function Le(t) {
                    var e = t.$options.provide;
                    e && (t._provided = "function" === typeof e ? e.call(t) : e)
                }

                function Re(t) {
                    var e = Ce(t.$options.inject, t);
                    e && (Rt(!1), Object.keys(e).forEach((function(n) {
                        Nt(t, n, e[n])
                    })), Rt(!0))
                }

                function Ce(t, e) {
                    if (t) {
                        for (var n = Object.create(null), r = dt ? Reflect.ownKeys(t) : Object.keys(t), i = 0; i < r.length; i++) {
                            var o = r[i];
                            if ("__ob__" !== o) {
                                var a = t[o].from,
                                    s = e;
                                while (s) {
                                    if (s._provided && b(s._provided, a)) {
                                        n[o] = s._provided[a];
                                        break
                                    }
                                    s = s.$parent
                                }
                                if (!s)
                                    if ("default" in t[o]) {
                                        var c = t[o].default;
                                        n[o] = "function" === typeof c ? c.call(e) : c
                                    } else 0
                            }
                        }
                        return n
                    }
                }

                function Oe(t, e) {
                    if (!t || !t.length) return {};
                    for (var n = {}, r = 0, i = t.length; r < i; r++) {
                        var o = t[r],
                            a = o.data;
                        if (a && a.attrs && a.attrs.slot && delete a.attrs.slot, o.context !== e && o.fnContext !== e || !a || null == a.slot)(n.default || (n.default = [])).push(o);
                        else {
                            var s = a.slot,
                                c = n[s] || (n[s] = []);
                            "template" === o.tag ? c.push.apply(c, o.children || []) : c.push(o)
                        }
                    }
                    for (var l in n) n[l].every(Pe) && delete n[l];
                    return n
                }

                function Pe(t) {
                    return t.isComment && !t.asyncFactory || " " === t.text
                }

                function Ie(t, e, r) {
                    var i, o = Object.keys(e).length > 0,
                        a = t ? !!t.$stable : !o,
                        s = t && t.$key;
                    if (t) {
                        if (t._normalized) return t._normalized;
                        if (a && r && r !== n && s === r.$key && !o && !r.$hasNormal) return r;
                        for (var c in i = {}, t) t[c] && "$" !== c[0] && (i[c] = Ne(e, c, t[c]))
                    } else i = {};
                    for (var l in e) l in i || (i[l] = De(e, l));
                    return t && Object.isExtensible(t) && (t._normalized = i), W(i, "$stable", a), W(i, "$key", s), W(i, "$hasNormal", o), i
                }

                function Ne(t, e, n) {
                    var r = function() {
                        var t = arguments.length ? n.apply(null, arguments) : n({});
                        return t = t && "object" === typeof t && !Array.isArray(t) ? [t] : Se(t), t && (0 === t.length || 1 === t.length && t[0].isComment) ? void 0 : t
                    };
                    return n.proxy && Object.defineProperty(t, e, {
                        get: r,
                        enumerable: !0,
                        configurable: !0
                    }), r
                }

                function De(t, e) {
                    return function() {
                        return t[e]
                    }
                }

                function ke(t, e) {
                    var n, r, o, a, s;
                    if (Array.isArray(t) || "string" === typeof t)
                        for (n = new Array(t.length), r = 0, o = t.length; r < o; r++) n[r] = e(t[r], r);
                    else if ("number" === typeof t)
                        for (n = new Array(t), r = 0; r < t; r++) n[r] = e(r + 1, r);
                    else if (c(t))
                        if (dt && t[Symbol.iterator]) {
                            n = [];
                            var l = t[Symbol.iterator](),
                                u = l.next();
                            while (!u.done) n.push(e(u.value, n.length)), u = l.next()
                        } else
                            for (a = Object.keys(t), n = new Array(a.length), r = 0, o = a.length; r < o; r++) s = a[r], n[r] = e(t[s], s, r);
                    return i(n) || (n = []), n._isVList = !0, n
                }

                function Fe(t, e, n, r) {
                    var i, o = this.$scopedSlots[t];
                    o ? (n = n || {}, r && (n = O(O({}, r), n)), i = o(n) || e) : i = this.$slots[t] || e;
                    var a = n && n.slot;
                    return a ? this.$createElement("template", {
                        slot: a
                    }, i) : i
                }

                function Be(t) {
                    return $t(this.$options, "filters", t, !0) || D
                }

                function Ue(t, e) {
                    return Array.isArray(t) ? -1 === t.indexOf(e) : t !== e
                }

                function He(t, e, n, r, i) {
                    var o = j.keyCodes[e] || n;
                    return i && r && !j.keyCodes[e] ? Ue(i, r) : o ? Ue(o, t) : r ? E(r) !== e : void 0
                }

                function ze(t, e, n, r, i) {
                    if (n)
                        if (c(n)) {
                            var o;
                            Array.isArray(n) && (n = P(n));
                            var a = function(a) {
                                if ("class" === a || "style" === a || v(a)) o = t;
                                else {
                                    var s = t.attrs && t.attrs.type;
                                    o = r || j.mustUseProp(e, s, a) ? t.domProps || (t.domProps = {}) : t.attrs || (t.attrs = {})
                                }
                                var c = M(a),
                                    l = E(a);
                                if (!(c in o) && !(l in o) && (o[a] = n[a], i)) {
                                    var u = t.on || (t.on = {});
                                    u["update:" + a] = function(t) {
                                        n[a] = t
                                    }
                                }
                            };
                            for (var s in n) a(s)
                        } else;
                    return t
                }

                function je(t, e) {
                    var n = this._staticTrees || (this._staticTrees = []),
                        r = n[t];
                    return r && !e || (r = n[t] = this.$options.staticRenderFns[t].call(this._renderProxy, null, this), Ve(r, "__static__" + t, !1)), r
                }

                function Ge(t, e, n) {
                    return Ve(t, "__once__" + e + (n ? "_" + n : ""), !0), t
                }

                function Ve(t, e, n) {
                    if (Array.isArray(t))
                        for (var r = 0; r < t.length; r++) t[r] && "string" !== typeof t[r] && We(t[r], e + "_" + r, n);
                    else We(t, e, n)
                }

                function We(t, e, n) {
                    t.isStatic = !0, t.key = e, t.isOnce = n
                }

                function Xe(t, e) {
                    if (e)
                        if (u(e)) {
                            var n = t.on = t.on ? O({}, t.on) : {};
                            for (var r in e) {
                                var i = n[r],
                                    o = e[r];
                                n[r] = i ? [].concat(i, o) : o
                            }
                        } else;
                    return t
                }

                function qe(t, e, n, r) {
                    e = e || {
                        $stable: !n
                    };
                    for (var i = 0; i < t.length; i++) {
                        var o = t[i];
                        Array.isArray(o) ? qe(o, e, n) : o && (o.proxy && (o.fn.proxy = !0), e[o.key] = o.fn)
                    }
                    return r && (e.$key = r), e
                }

                function Ye(t, e) {
                    for (var n = 0; n < e.length; n += 2) {
                        var r = e[n];
                        "string" === typeof r && r && (t[e[n]] = e[n + 1])
                    }
                    return t
                }

                function $e(t, e) {
                    return "string" === typeof t ? e + t : t
                }

                function Ze(t) {
                    t._o = Ge, t._n = m, t._s = f, t._l = ke, t._t = Fe, t._q = k, t._i = F, t._m = je, t._f = Be, t._k = He, t._b = ze, t._v = wt, t._e = xt, t._u = qe, t._g = Xe, t._d = Ye, t._p = $e
                }

                function Je(t, e, r, i, a) {
                    var s, c = this,
                        l = a.options;
                    b(i, "_uid") ? (s = Object.create(i), s._original = i) : (s = i, i = i._original);
                    var u = o(l._compiled),
                        h = !u;
                    this.data = t, this.props = e, this.children = r, this.parent = i, this.listeners = t.on || n, this.injections = Ce(l.inject, i), this.slots = function() {
                        return c.$slots || Ie(t.scopedSlots, c.$slots = Oe(r, i)), c.$slots
                    }, Object.defineProperty(this, "scopedSlots", {
                        enumerable: !0,
                        get: function() {
                            return Ie(t.scopedSlots, this.slots())
                        }
                    }), u && (this.$options = l, this.$slots = this.slots(), this.$scopedSlots = Ie(t.scopedSlots, this.$slots)), l._scopeId ? this._c = function(t, e, n, r) {
                        var o = hn(s, t, e, n, r, h);
                        return o && !Array.isArray(o) && (o.fnScopeId = l._scopeId, o.fnContext = i), o
                    } : this._c = function(t, e, n, r) {
                        return hn(s, t, e, n, r, h)
                    }
                }

                function Ke(t, e, r, o, a) {
                    var s = t.options,
                        c = {},
                        l = s.props;
                    if (i(l))
                        for (var u in l) c[u] = Zt(u, l, e || n);
                    else i(r.attrs) && tn(c, r.attrs), i(r.props) && tn(c, r.props);
                    var h = new Je(r, c, a, o, t),
                        d = s.render.call(null, h._c, h);
                    if (d instanceof _t) return Qe(d, r, h.parent, s, h);
                    if (Array.isArray(d)) {
                        for (var p = Se(d) || [], f = new Array(p.length), m = 0; m < p.length; m++) f[m] = Qe(p[m], r, h.parent, s, h);
                        return f
                    }
                }

                function Qe(t, e, n, r, i) {
                    var o = Mt(t);
                    return o.fnContext = n, o.fnOptions = r, e.slot && ((o.data || (o.data = {})).slot = e.slot), o
                }

                function tn(t, e) {
                    for (var n in e) t[M(n)] = e[n]
                }
                Ze(Je.prototype);
                var en = {
                        init: function(t, e) {
                            if (t.componentInstance && !t.componentInstance._isDestroyed && t.data.keepAlive) {
                                var n = t;
                                en.prepatch(n, n)
                            } else {
                                var r = t.componentInstance = on(t, Cn);
                                r.$mount(e ? t.elm : void 0, e)
                            }
                        },
                        prepatch: function(t, e) {
                            var n = e.componentOptions,
                                r = e.componentInstance = t.componentInstance;
                            Dn(r, n.propsData, n.listeners, e, n.children)
                        },
                        insert: function(t) {
                            var e = t.context,
                                n = t.componentInstance;
                            n._isMounted || (n._isMounted = !0, Un(n, "mounted")), t.data.keepAlive && (e._isMounted ? Kn(n) : Fn(n, !0))
                        },
                        destroy: function(t) {
                            var e = t.componentInstance;
                            e._isDestroyed || (t.data.keepAlive ? Bn(e, !0) : e.$destroy())
                        }
                    },
                    nn = Object.keys(en);

                function rn(t, e, n, a, s) {
                    if (!r(t)) {
                        var l = n.$options._base;
                        if (c(t) && (t = l.extend(t)), "function" === typeof t) {
                            var u;
                            if (r(t.cid) && (u = t, t = xn(u, l), void 0 === t)) return bn(u, e, n, a, s);
                            e = e || {}, xr(t), i(e.model) && cn(t.options, e);
                            var h = we(e, t, s);
                            if (o(t.options.functional)) return Ke(t, h, e, n, a);
                            var d = e.on;
                            if (e.on = e.nativeOn, o(t.options.abstract)) {
                                var p = e.slot;
                                e = {}, p && (e.slot = p)
                            }
                            an(e);
                            var f = t.options.name || s,
                                m = new _t("vue-component-" + t.cid + (f ? "-" + f : ""), e, void 0, void 0, void 0, n, {
                                    Ctor: t,
                                    propsData: h,
                                    listeners: d,
                                    tag: s,
                                    children: a
                                }, u);
                            return m
                        }
                    }
                }

                function on(t, e) {
                    var n = {
                            _isComponent: !0,
                            _parentVnode: t,
                            parent: e
                        },
                        r = t.data.inlineTemplate;
                    return i(r) && (n.render = r.render, n.staticRenderFns = r.staticRenderFns), new t.componentOptions.Ctor(n)
                }

                function an(t) {
                    for (var e = t.hook || (t.hook = {}), n = 0; n < nn.length; n++) {
                        var r = nn[n],
                            i = e[r],
                            o = en[r];
                        i === o || i && i._merged || (e[r] = i ? sn(o, i) : o)
                    }
                }

                function sn(t, e) {
                    var n = function(n, r) {
                        t(n, r), e(n, r)
                    };
                    return n._merged = !0, n
                }

                function cn(t, e) {
                    var n = t.model && t.model.prop || "value",
                        r = t.model && t.model.event || "input";
                    (e.attrs || (e.attrs = {}))[n] = e.model.value;
                    var o = e.on || (e.on = {}),
                        a = o[r],
                        s = e.model.callback;
                    i(a) ? (Array.isArray(a) ? -1 === a.indexOf(s) : a !== s) && (o[r] = [s].concat(a)) : o[r] = s
                }
                var ln = 1,
                    un = 2;

                function hn(t, e, n, r, i, a) {
                    return (Array.isArray(n) || s(n)) && (i = r, r = n, n = void 0), o(a) && (i = un), dn(t, e, n, r, i)
                }

                function dn(t, e, n, r, o) {
                    if (i(n) && i(n.__ob__)) return xt();
                    if (i(n) && i(n.is) && (e = n.is), !e) return xt();
                    var a, s, c;
                    (Array.isArray(r) && "function" === typeof r[0] && (n = n || {}, n.scopedSlots = {
                        default: r[0]
                    }, r.length = 0), o === un ? r = Se(r) : o === ln && (r = Te(r)), "string" === typeof e) ? (s = t.$vnode && t.$vnode.ns || j.getTagNamespace(e), a = j.isReservedTag(e) ? new _t(j.parsePlatformTagName(e), n, r, void 0, void 0, t) : n && n.pre || !i(c = $t(t.$options, "components", e)) ? new _t(e, n, r, void 0, void 0, t) : rn(c, n, t, r, e)) : a = rn(e, n, t, r);
                    return Array.isArray(a) ? a : i(a) ? (i(s) && pn(a, s), i(n) && fn(n), a) : xt()
                }

                function pn(t, e, n) {
                    if (t.ns = e, "foreignObject" === t.tag && (e = void 0, n = !0), i(t.children))
                        for (var a = 0, s = t.children.length; a < s; a++) {
                            var c = t.children[a];
                            i(c.tag) && (r(c.ns) || o(n) && "svg" !== c.tag) && pn(c, e, n)
                        }
                }

                function fn(t) {
                    c(t.style) && ge(t.style), c(t.class) && ge(t.class)
                }

                function mn(t) {
                    t._vnode = null, t._staticTrees = null;
                    var e = t.$options,
                        r = t.$vnode = e._parentVnode,
                        i = r && r.context;
                    t.$slots = Oe(e._renderChildren, i), t.$scopedSlots = n, t._c = function(e, n, r, i) {
                        return hn(t, e, n, r, i, !1)
                    }, t.$createElement = function(e, n, r, i) {
                        return hn(t, e, n, r, i, !0)
                    };
                    var o = r && r.data;
                    Nt(t, "$attrs", o && o.attrs || n, null, !0), Nt(t, "$listeners", e._parentListeners || n, null, !0)
                }
                var gn, vn = null;

                function yn(t) {
                    Ze(t.prototype), t.prototype.$nextTick = function(t) {
                        return fe(t, this)
                    }, t.prototype._render = function() {
                        var t, e = this,
                            n = e.$options,
                            r = n.render,
                            i = n._parentVnode;
                        i && (e.$scopedSlots = Ie(i.data.scopedSlots, e.$slots, e.$scopedSlots)), e.$vnode = i;
                        try {
                            vn = e, t = r.call(e._renderProxy, e.$createElement)
                        } catch (Ma) {
                            ee(Ma, e, "render"), t = e._vnode
                        } finally {
                            vn = null
                        }
                        return Array.isArray(t) && 1 === t.length && (t = t[0]), t instanceof _t || (t = xt()), t.parent = i, t
                    }
                }

                function _n(t, e) {
                    return (t.__esModule || dt && "Module" === t[Symbol.toStringTag]) && (t = t.default), c(t) ? e.extend(t) : t
                }

                function bn(t, e, n, r, i) {
                    var o = xt();
                    return o.asyncFactory = t, o.asyncMeta = {
                        data: e,
                        context: n,
                        children: r,
                        tag: i
                    }, o
                }

                function xn(t, e) {
                    if (o(t.error) && i(t.errorComp)) return t.errorComp;
                    if (i(t.resolved)) return t.resolved;
                    var n = vn;
                    if (n && i(t.owners) && -1 === t.owners.indexOf(n) && t.owners.push(n), o(t.loading) && i(t.loadingComp)) return t.loadingComp;
                    if (n && !i(t.owners)) {
                        var a = t.owners = [n],
                            s = !0,
                            l = null,
                            u = null;
                        n.$on("hook:destroyed", (function() {
                            return y(a, n)
                        }));
                        var h = function(t) {
                                for (var e = 0, n = a.length; e < n; e++) a[e].$forceUpdate();
                                t && (a.length = 0, null !== l && (clearTimeout(l), l = null), null !== u && (clearTimeout(u), u = null))
                            },
                            d = B((function(n) {
                                t.resolved = _n(n, e), s ? a.length = 0 : h(!0)
                            })),
                            f = B((function(e) {
                                i(t.errorComp) && (t.error = !0, h(!0))
                            })),
                            m = t(d, f);
                        return c(m) && (p(m) ? r(t.resolved) && m.then(d, f) : p(m.component) && (m.component.then(d, f), i(m.error) && (t.errorComp = _n(m.error, e)), i(m.loading) && (t.loadingComp = _n(m.loading, e), 0 === m.delay ? t.loading = !0 : l = setTimeout((function() {
                            l = null, r(t.resolved) && r(t.error) && (t.loading = !0, h(!1))
                        }), m.delay || 200)), i(m.timeout) && (u = setTimeout((function() {
                            u = null, r(t.resolved) && f(null)
                        }), m.timeout)))), s = !1, t.loading ? t.loadingComp : t.resolved
                    }
                }

                function wn(t) {
                    return t.isComment && t.asyncFactory
                }

                function Mn(t) {
                    if (Array.isArray(t))
                        for (var e = 0; e < t.length; e++) {
                            var n = t[e];
                            if (i(n) && (i(n.componentOptions) || wn(n))) return n
                        }
                }

                function Tn(t) {
                    t._events = Object.create(null), t._hasHookEvent = !1;
                    var e = t.$options._parentListeners;
                    e && Ln(t, e)
                }

                function Sn(t, e) {
                    gn.$on(t, e)
                }

                function En(t, e) {
                    gn.$off(t, e)
                }

                function An(t, e) {
                    var n = gn;
                    return function r() {
                        var i = e.apply(null, arguments);
                        null !== i && n.$off(t, r)
                    }
                }

                function Ln(t, e, n) {
                    gn = t, be(e, n || {}, Sn, En, An, t), gn = void 0
                }

                function Rn(t) {
                    var e = /^hook:/;
                    t.prototype.$on = function(t, n) {
                        var r = this;
                        if (Array.isArray(t))
                            for (var i = 0, o = t.length; i < o; i++) r.$on(t[i], n);
                        else(r._events[t] || (r._events[t] = [])).push(n), e.test(t) && (r._hasHookEvent = !0);
                        return r
                    }, t.prototype.$once = function(t, e) {
                        var n = this;

                        function r() {
                            n.$off(t, r), e.apply(n, arguments)
                        }
                        return r.fn = e, n.$on(t, r), n
                    }, t.prototype.$off = function(t, e) {
                        var n = this;
                        if (!arguments.length) return n._events = Object.create(null), n;
                        if (Array.isArray(t)) {
                            for (var r = 0, i = t.length; r < i; r++) n.$off(t[r], e);
                            return n
                        }
                        var o, a = n._events[t];
                        if (!a) return n;
                        if (!e) return n._events[t] = null, n;
                        var s = a.length;
                        while (s--)
                            if (o = a[s], o === e || o.fn === e) {
                                a.splice(s, 1);
                                break
                            }
                        return n
                    }, t.prototype.$emit = function(t) {
                        var e = this,
                            n = e._events[t];
                        if (n) {
                            n = n.length > 1 ? C(n) : n;
                            for (var r = C(arguments, 1), i = 'event handler for "' + t + '"', o = 0, a = n.length; o < a; o++) ne(n[o], e, r, e, i)
                        }
                        return e
                    }
                }
                var Cn = null;

                function On(t) {
                    var e = Cn;
                    return Cn = t,
                        function() {
                            Cn = e
                        }
                }

                function Pn(t) {
                    var e = t.$options,
                        n = e.parent;
                    if (n && !e.abstract) {
                        while (n.$options.abstract && n.$parent) n = n.$parent;
                        n.$children.push(t)
                    }
                    t.$parent = n, t.$root = n ? n.$root : t, t.$children = [], t.$refs = {}, t._watcher = null, t._inactive = null, t._directInactive = !1, t._isMounted = !1, t._isDestroyed = !1, t._isBeingDestroyed = !1
                }

                function In(t) {
                    t.prototype._update = function(t, e) {
                        var n = this,
                            r = n.$el,
                            i = n._vnode,
                            o = On(n);
                        n._vnode = t, n.$el = i ? n.__patch__(i, t) : n.__patch__(n.$el, t, e, !1), o(), r && (r.__vue__ = null), n.$el && (n.$el.__vue__ = n), n.$vnode && n.$parent && n.$vnode === n.$parent._vnode && (n.$parent.$el = n.$el)
                    }, t.prototype.$forceUpdate = function() {
                        var t = this;
                        t._watcher && t._watcher.update()
                    }, t.prototype.$destroy = function() {
                        var t = this;
                        if (!t._isBeingDestroyed) {
                            Un(t, "beforeDestroy"), t._isBeingDestroyed = !0;
                            var e = t.$parent;
                            !e || e._isBeingDestroyed || t.$options.abstract || y(e.$children, t), t._watcher && t._watcher.teardown();
                            var n = t._watchers.length;
                            while (n--) t._watchers[n].teardown();
                            t._data.__ob__ && t._data.__ob__.vmCount--, t._isDestroyed = !0, t.__patch__(t._vnode, null), Un(t, "destroyed"), t.$off(), t.$el && (t.$el.__vue__ = null), t.$vnode && (t.$vnode.parent = null)
                        }
                    }
                }

                function Nn(t, e, n) {
                    var r;
                    return t.$el = e, t.$options.render || (t.$options.render = xt), Un(t, "beforeMount"), r = function() {
                        t._update(t._render(), n)
                    }, new nr(t, r, I, {
                        before: function() {
                            t._isMounted && !t._isDestroyed && Un(t, "beforeUpdate")
                        }
                    }, !0), n = !1, null == t.$vnode && (t._isMounted = !0, Un(t, "mounted")), t
                }

                function Dn(t, e, r, i, o) {
                    var a = i.data.scopedSlots,
                        s = t.$scopedSlots,
                        c = !!(a && !a.$stable || s !== n && !s.$stable || a && t.$scopedSlots.$key !== a.$key),
                        l = !!(o || t.$options._renderChildren || c);
                    if (t.$options._parentVnode = i, t.$vnode = i, t._vnode && (t._vnode.parent = i), t.$options._renderChildren = o, t.$attrs = i.data.attrs || n, t.$listeners = r || n, e && t.$options.props) {
                        Rt(!1);
                        for (var u = t._props, h = t.$options._propKeys || [], d = 0; d < h.length; d++) {
                            var p = h[d],
                                f = t.$options.props;
                            u[p] = Zt(p, f, e, t)
                        }
                        Rt(!0), t.$options.propsData = e
                    }
                    r = r || n;
                    var m = t.$options._parentListeners;
                    t.$options._parentListeners = r, Ln(t, r, m), l && (t.$slots = Oe(o, i.context), t.$forceUpdate())
                }

                function kn(t) {
                    while (t && (t = t.$parent))
                        if (t._inactive) return !0;
                    return !1
                }

                function Fn(t, e) {
                    if (e) {
                        if (t._directInactive = !1, kn(t)) return
                    } else if (t._directInactive) return;
                    if (t._inactive || null === t._inactive) {
                        t._inactive = !1;
                        for (var n = 0; n < t.$children.length; n++) Fn(t.$children[n]);
                        Un(t, "activated")
                    }
                }

                function Bn(t, e) {
                    if ((!e || (t._directInactive = !0, !kn(t))) && !t._inactive) {
                        t._inactive = !0;
                        for (var n = 0; n < t.$children.length; n++) Bn(t.$children[n]);
                        Un(t, "deactivated")
                    }
                }

                function Un(t, e) {
                    vt();
                    var n = t.$options[e],
                        r = e + " hook";
                    if (n)
                        for (var i = 0, o = n.length; i < o; i++) ne(n[i], t, null, t, r);
                    t._hasHookEvent && t.$emit("hook:" + e), yt()
                }
                var Hn = [],
                    zn = [],
                    jn = {},
                    Gn = !1,
                    Vn = !1,
                    Wn = 0;

                function Xn() {
                    Wn = Hn.length = zn.length = 0, jn = {}, Gn = Vn = !1
                }
                var qn = 0,
                    Yn = Date.now;
                if (Z && !tt) {
                    var $n = window.performance;
                    $n && "function" === typeof $n.now && Yn() > document.createEvent("Event").timeStamp && (Yn = function() {
                        return $n.now()
                    })
                }

                function Zn() {
                    var t, e;
                    for (qn = Yn(), Vn = !0, Hn.sort((function(t, e) {
                            return t.id - e.id
                        })), Wn = 0; Wn < Hn.length; Wn++) t = Hn[Wn], t.before && t.before(), e = t.id, jn[e] = null, t.run();
                    var n = zn.slice(),
                        r = Hn.slice();
                    Xn(), Qn(n), Jn(r), lt && j.devtools && lt.emit("flush")
                }

                function Jn(t) {
                    var e = t.length;
                    while (e--) {
                        var n = t[e],
                            r = n.vm;
                        r._watcher === n && r._isMounted && !r._isDestroyed && Un(r, "updated")
                    }
                }

                function Kn(t) {
                    t._inactive = !1, zn.push(t)
                }

                function Qn(t) {
                    for (var e = 0; e < t.length; e++) t[e]._inactive = !0, Fn(t[e], !0)
                }

                function tr(t) {
                    var e = t.id;
                    if (null == jn[e]) {
                        if (jn[e] = !0, Vn) {
                            var n = Hn.length - 1;
                            while (n > Wn && Hn[n].id > t.id) n--;
                            Hn.splice(n + 1, 0, t)
                        } else Hn.push(t);
                        Gn || (Gn = !0, fe(Zn))
                    }
                }
                var er = 0,
                    nr = function(t, e, n, r, i) {
                        this.vm = t, i && (t._watcher = this), t._watchers.push(this), r ? (this.deep = !!r.deep, this.user = !!r.user, this.lazy = !!r.lazy, this.sync = !!r.sync, this.before = r.before) : this.deep = this.user = this.lazy = this.sync = !1, this.cb = n, this.id = ++er, this.active = !0, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new ht, this.newDepIds = new ht, this.expression = "", "function" === typeof e ? this.getter = e : (this.getter = q(e), this.getter || (this.getter = I)), this.value = this.lazy ? void 0 : this.get()
                    };
                nr.prototype.get = function() {
                    var t;
                    vt(this);
                    var e = this.vm;
                    try {
                        t = this.getter.call(e, e)
                    } catch (Ma) {
                        if (!this.user) throw Ma;
                        ee(Ma, e, 'getter for watcher "' + this.expression + '"')
                    } finally {
                        this.deep && ge(t), yt(), this.cleanupDeps()
                    }
                    return t
                }, nr.prototype.addDep = function(t) {
                    var e = t.id;
                    this.newDepIds.has(e) || (this.newDepIds.add(e), this.newDeps.push(t), this.depIds.has(e) || t.addSub(this))
                }, nr.prototype.cleanupDeps = function() {
                    var t = this.deps.length;
                    while (t--) {
                        var e = this.deps[t];
                        this.newDepIds.has(e.id) || e.removeSub(this)
                    }
                    var n = this.depIds;
                    this.depIds = this.newDepIds, this.newDepIds = n, this.newDepIds.clear(), n = this.deps, this.deps = this.newDeps, this.newDeps = n, this.newDeps.length = 0
                }, nr.prototype.update = function() {
                    this.lazy ? this.dirty = !0 : this.sync ? this.run() : tr(this)
                }, nr.prototype.run = function() {
                    if (this.active) {
                        var t = this.get();
                        if (t !== this.value || c(t) || this.deep) {
                            var e = this.value;
                            if (this.value = t, this.user) try {
                                this.cb.call(this.vm, t, e)
                            } catch (Ma) {
                                ee(Ma, this.vm, 'callback for watcher "' + this.expression + '"')
                            } else this.cb.call(this.vm, t, e)
                        }
                    }
                }, nr.prototype.evaluate = function() {
                    this.value = this.get(), this.dirty = !1
                }, nr.prototype.depend = function() {
                    var t = this.deps.length;
                    while (t--) this.deps[t].depend()
                }, nr.prototype.teardown = function() {
                    if (this.active) {
                        this.vm._isBeingDestroyed || y(this.vm._watchers, this);
                        var t = this.deps.length;
                        while (t--) this.deps[t].removeSub(this);
                        this.active = !1
                    }
                };
                var rr = {
                    enumerable: !0,
                    configurable: !0,
                    get: I,
                    set: I
                };

                function ir(t, e, n) {
                    rr.get = function() {
                        return this[e][n]
                    }, rr.set = function(t) {
                        this[e][n] = t
                    }, Object.defineProperty(t, n, rr)
                }

                function or(t) {
                    t._watchers = [];
                    var e = t.$options;
                    e.props && ar(t, e.props), e.methods && fr(t, e.methods), e.data ? sr(t) : It(t._data = {}, !0), e.computed && ur(t, e.computed), e.watch && e.watch !== ot && mr(t, e.watch)
                }

                function ar(t, e) {
                    var n = t.$options.propsData || {},
                        r = t._props = {},
                        i = t.$options._propKeys = [],
                        o = !t.$parent;
                    o || Rt(!1);
                    var a = function(o) {
                        i.push(o);
                        var a = Zt(o, e, n, t);
                        Nt(r, o, a), o in t || ir(t, "_props", o)
                    };
                    for (var s in e) a(s);
                    Rt(!0)
                }

                function sr(t) {
                    var e = t.$options.data;
                    e = t._data = "function" === typeof e ? cr(e, t) : e || {}, u(e) || (e = {});
                    var n = Object.keys(e),
                        r = t.$options.props,
                        i = (t.$options.methods, n.length);
                    while (i--) {
                        var o = n[i];
                        0, r && b(r, o) || V(o) || ir(t, "_data", o)
                    }
                    It(e, !0)
                }

                function cr(t, e) {
                    vt();
                    try {
                        return t.call(e, e)
                    } catch (Ma) {
                        return ee(Ma, e, "data()"), {}
                    } finally {
                        yt()
                    }
                }
                var lr = {
                    lazy: !0
                };

                function ur(t, e) {
                    var n = t._computedWatchers = Object.create(null),
                        r = ct();
                    for (var i in e) {
                        var o = e[i],
                            a = "function" === typeof o ? o : o.get;
                        0, r || (n[i] = new nr(t, a || I, I, lr)), i in t || hr(t, i, o)
                    }
                }

                function hr(t, e, n) {
                    var r = !ct();
                    "function" === typeof n ? (rr.get = r ? dr(e) : pr(n), rr.set = I) : (rr.get = n.get ? r && !1 !== n.cache ? dr(e) : pr(n.get) : I, rr.set = n.set || I), Object.defineProperty(t, e, rr)
                }

                function dr(t) {
                    return function() {
                        var e = this._computedWatchers && this._computedWatchers[t];
                        if (e) return e.dirty && e.evaluate(), mt.target && e.depend(), e.value
                    }
                }

                function pr(t) {
                    return function() {
                        return t.call(this, this)
                    }
                }

                function fr(t, e) {
                    t.$options.props;
                    for (var n in e) t[n] = "function" !== typeof e[n] ? I : R(e[n], t)
                }

                function mr(t, e) {
                    for (var n in e) {
                        var r = e[n];
                        if (Array.isArray(r))
                            for (var i = 0; i < r.length; i++) gr(t, n, r[i]);
                        else gr(t, n, r)
                    }
                }

                function gr(t, e, n, r) {
                    return u(n) && (r = n, n = n.handler), "string" === typeof n && (n = t[n]), t.$watch(e, n, r)
                }

                function vr(t) {
                    var e = {
                            get: function() {
                                return this._data
                            }
                        },
                        n = {
                            get: function() {
                                return this._props
                            }
                        };
                    Object.defineProperty(t.prototype, "$data", e), Object.defineProperty(t.prototype, "$props", n), t.prototype.$set = Dt, t.prototype.$delete = kt, t.prototype.$watch = function(t, e, n) {
                        var r = this;
                        if (u(e)) return gr(r, t, e, n);
                        n = n || {}, n.user = !0;
                        var i = new nr(r, t, e, n);
                        if (n.immediate) try {
                            e.call(r, i.value)
                        } catch (o) {
                            ee(o, r, 'callback for immediate watcher "' + i.expression + '"')
                        }
                        return function() {
                            i.teardown()
                        }
                    }
                }
                var yr = 0;

                function _r(t) {
                    t.prototype._init = function(t) {
                        var e = this;
                        e._uid = yr++, e._isVue = !0, t && t._isComponent ? br(e, t) : e.$options = Yt(xr(e.constructor), t || {}, e), e._renderProxy = e, e._self = e, Pn(e), Tn(e), mn(e), Un(e, "beforeCreate"), Re(e), or(e), Le(e), Un(e, "created"), e.$options.el && e.$mount(e.$options.el)
                    }
                }

                function br(t, e) {
                    var n = t.$options = Object.create(t.constructor.options),
                        r = e._parentVnode;
                    n.parent = e.parent, n._parentVnode = r;
                    var i = r.componentOptions;
                    n.propsData = i.propsData, n._parentListeners = i.listeners, n._renderChildren = i.children, n._componentTag = i.tag, e.render && (n.render = e.render, n.staticRenderFns = e.staticRenderFns)
                }

                function xr(t) {
                    var e = t.options;
                    if (t.super) {
                        var n = xr(t.super),
                            r = t.superOptions;
                        if (n !== r) {
                            t.superOptions = n;
                            var i = wr(t);
                            i && O(t.extendOptions, i), e = t.options = Yt(n, t.extendOptions), e.name && (e.components[e.name] = t)
                        }
                    }
                    return e
                }

                function wr(t) {
                    var e, n = t.options,
                        r = t.sealedOptions;
                    for (var i in n) n[i] !== r[i] && (e || (e = {}), e[i] = n[i]);
                    return e
                }

                function Mr(t) {
                    this._init(t)
                }

                function Tr(t) {
                    t.use = function(t) {
                        var e = this._installedPlugins || (this._installedPlugins = []);
                        if (e.indexOf(t) > -1) return this;
                        var n = C(arguments, 1);
                        return n.unshift(this), "function" === typeof t.install ? t.install.apply(t, n) : "function" === typeof t && t.apply(null, n), e.push(t), this
                    }
                }

                function Sr(t) {
                    t.mixin = function(t) {
                        return this.options = Yt(this.options, t), this
                    }
                }

                function Er(t) {
                    t.cid = 0;
                    var e = 1;
                    t.extend = function(t) {
                        t = t || {};
                        var n = this,
                            r = n.cid,
                            i = t._Ctor || (t._Ctor = {});
                        if (i[r]) return i[r];
                        var o = t.name || n.options.name;
                        var a = function(t) {
                            this._init(t)
                        };
                        return a.prototype = Object.create(n.prototype), a.prototype.constructor = a, a.cid = e++, a.options = Yt(n.options, t), a["super"] = n, a.options.props && Ar(a), a.options.computed && Lr(a), a.extend = n.extend, a.mixin = n.mixin, a.use = n.use, H.forEach((function(t) {
                            a[t] = n[t]
                        })), o && (a.options.components[o] = a), a.superOptions = n.options, a.extendOptions = t, a.sealedOptions = O({}, a.options), i[r] = a, a
                    }
                }

                function Ar(t) {
                    var e = t.options.props;
                    for (var n in e) ir(t.prototype, "_props", n)
                }

                function Lr(t) {
                    var e = t.options.computed;
                    for (var n in e) hr(t.prototype, n, e[n])
                }

                function Rr(t) {
                    H.forEach((function(e) {
                        t[e] = function(t, n) {
                            return n ? ("component" === e && u(n) && (n.name = n.name || t, n = this.options._base.extend(n)), "directive" === e && "function" === typeof n && (n = {
                                bind: n,
                                update: n
                            }), this.options[e + "s"][t] = n, n) : this.options[e + "s"][t]
                        }
                    }))
                }

                function Cr(t) {
                    return t && (t.Ctor.options.name || t.tag)
                }

                function Or(t, e) {
                    return Array.isArray(t) ? t.indexOf(e) > -1 : "string" === typeof t ? t.split(",").indexOf(e) > -1 : !!h(t) && t.test(e)
                }

                function Pr(t, e) {
                    var n = t.cache,
                        r = t.keys,
                        i = t._vnode;
                    for (var o in n) {
                        var a = n[o];
                        if (a) {
                            var s = Cr(a.componentOptions);
                            s && !e(s) && Ir(n, o, r, i)
                        }
                    }
                }

                function Ir(t, e, n, r) {
                    var i = t[e];
                    !i || r && i.tag === r.tag || i.componentInstance.$destroy(), t[e] = null, y(n, e)
                }
                _r(Mr), vr(Mr), Rn(Mr), In(Mr), yn(Mr);
                var Nr = [String, RegExp, Array],
                    Dr = {
                        name: "keep-alive",
                        abstract: !0,
                        props: {
                            include: Nr,
                            exclude: Nr,
                            max: [String, Number]
                        },
                        created: function() {
                            this.cache = Object.create(null), this.keys = []
                        },
                        destroyed: function() {
                            for (var t in this.cache) Ir(this.cache, t, this.keys)
                        },
                        mounted: function() {
                            var t = this;
                            this.$watch("include", (function(e) {
                                Pr(t, (function(t) {
                                    return Or(e, t)
                                }))
                            })), this.$watch("exclude", (function(e) {
                                Pr(t, (function(t) {
                                    return !Or(e, t)
                                }))
                            }))
                        },
                        render: function() {
                            var t = this.$slots.default,
                                e = Mn(t),
                                n = e && e.componentOptions;
                            if (n) {
                                var r = Cr(n),
                                    i = this,
                                    o = i.include,
                                    a = i.exclude;
                                if (o && (!r || !Or(o, r)) || a && r && Or(a, r)) return e;
                                var s = this,
                                    c = s.cache,
                                    l = s.keys,
                                    u = null == e.key ? n.Ctor.cid + (n.tag ? "::" + n.tag : "") : e.key;
                                c[u] ? (e.componentInstance = c[u].componentInstance, y(l, u), l.push(u)) : (c[u] = e, l.push(u), this.max && l.length > parseInt(this.max) && Ir(c, l[0], l, this._vnode)), e.data.keepAlive = !0
                            }
                            return e || t && t[0]
                        }
                    },
                    kr = {
                        KeepAlive: Dr
                    };

                function Fr(t) {
                    var e = {
                        get: function() {
                            return j
                        }
                    };
                    Object.defineProperty(t, "config", e), t.util = {
                        warn: pt,
                        extend: O,
                        mergeOptions: Yt,
                        defineReactive: Nt
                    }, t.set = Dt, t.delete = kt, t.nextTick = fe, t.observable = function(t) {
                        return It(t), t
                    }, t.options = Object.create(null), H.forEach((function(e) {
                        t.options[e + "s"] = Object.create(null)
                    })), t.options._base = t, O(t.options.components, kr), Tr(t), Sr(t), Er(t), Rr(t)
                }
                Fr(Mr), Object.defineProperty(Mr.prototype, "$isServer", {
                    get: ct
                }), Object.defineProperty(Mr.prototype, "$ssrContext", {
                    get: function() {
                        return this.$vnode && this.$vnode.ssrContext
                    }
                }), Object.defineProperty(Mr, "FunctionalRenderContext", {
                    value: Je
                }), Mr.version = "2.6.11";
                var Br = g("style,class"),
                    Ur = g("input,textarea,option,select,progress"),
                    Hr = function(t, e, n) {
                        return "value" === n && Ur(t) && "button" !== e || "selected" === n && "option" === t || "checked" === n && "input" === t || "muted" === n && "video" === t
                    },
                    zr = g("contenteditable,draggable,spellcheck"),
                    jr = g("events,caret,typing,plaintext-only"),
                    Gr = function(t, e) {
                        return Yr(e) || "false" === e ? "false" : "contenteditable" === t && jr(e) ? e : "true"
                    },
                    Vr = g("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),
                    Wr = "http://www.w3.org/1999/xlink",
                    Xr = function(t) {
                        return ":" === t.charAt(5) && "xlink" === t.slice(0, 5)
                    },
                    qr = function(t) {
                        return Xr(t) ? t.slice(6, t.length) : ""
                    },
                    Yr = function(t) {
                        return null == t || !1 === t
                    };

                function $r(t) {
                    var e = t.data,
                        n = t,
                        r = t;
                    while (i(r.componentInstance)) r = r.componentInstance._vnode, r && r.data && (e = Zr(r.data, e));
                    while (i(n = n.parent)) n && n.data && (e = Zr(e, n.data));
                    return Jr(e.staticClass, e.class)
                }

                function Zr(t, e) {
                    return {
                        staticClass: Kr(t.staticClass, e.staticClass),
                        class: i(t.class) ? [t.class, e.class] : e.class
                    }
                }

                function Jr(t, e) {
                    return i(t) || i(e) ? Kr(t, Qr(e)) : ""
                }

                function Kr(t, e) {
                    return t ? e ? t + " " + e : t : e || ""
                }

                function Qr(t) {
                    return Array.isArray(t) ? ti(t) : c(t) ? ei(t) : "string" === typeof t ? t : ""
                }

                function ti(t) {
                    for (var e, n = "", r = 0, o = t.length; r < o; r++) i(e = Qr(t[r])) && "" !== e && (n && (n += " "), n += e);
                    return n
                }

                function ei(t) {
                    var e = "";
                    for (var n in t) t[n] && (e && (e += " "), e += n);
                    return e
                }
                var ni = {
                        svg: "http://www.w3.org/2000/svg",
                        math: "http://www.w3.org/1998/Math/MathML"
                    },
                    ri = g("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),
                    ii = g("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", !0),
                    oi = function(t) {
                        return ri(t) || ii(t)
                    };

                function ai(t) {
                    return ii(t) ? "svg" : "math" === t ? "math" : void 0
                }
                var si = Object.create(null);

                function ci(t) {
                    if (!Z) return !0;
                    if (oi(t)) return !1;
                    if (t = t.toLowerCase(), null != si[t]) return si[t];
                    var e = document.createElement(t);
                    return t.indexOf("-") > -1 ? si[t] = e.constructor === window.HTMLUnknownElement || e.constructor === window.HTMLElement : si[t] = /HTMLUnknownElement/.test(e.toString())
                }
                var li = g("text,number,password,search,email,tel,url");

                function ui(t) {
                    if ("string" === typeof t) {
                        var e = document.querySelector(t);
                        return e || document.createElement("div")
                    }
                    return t
                }

                function hi(t, e) {
                    var n = document.createElement(t);
                    return "select" !== t || e.data && e.data.attrs && void 0 !== e.data.attrs.multiple && n.setAttribute("multiple", "multiple"), n
                }

                function di(t, e) {
                    return document.createElementNS(ni[t], e)
                }

                function pi(t) {
                    return document.createTextNode(t)
                }

                function fi(t) {
                    return document.createComment(t)
                }

                function mi(t, e, n) {
                    t.insertBefore(e, n)
                }

                function gi(t, e) {
                    t.removeChild(e)
                }

                function vi(t, e) {
                    t.appendChild(e)
                }

                function yi(t) {
                    return t.parentNode
                }

                function _i(t) {
                    return t.nextSibling
                }

                function bi(t) {
                    return t.tagName
                }

                function xi(t, e) {
                    t.textContent = e
                }

                function wi(t, e) {
                    t.setAttribute(e, "")
                }
                var Mi = Object.freeze({
                        createElement: hi,
                        createElementNS: di,
                        createTextNode: pi,
                        createComment: fi,
                        insertBefore: mi,
                        removeChild: gi,
                        appendChild: vi,
                        parentNode: yi,
                        nextSibling: _i,
                        tagName: bi,
                        setTextContent: xi,
                        setStyleScope: wi
                    }),
                    Ti = {
                        create: function(t, e) {
                            Si(e)
                        },
                        update: function(t, e) {
                            t.data.ref !== e.data.ref && (Si(t, !0), Si(e))
                        },
                        destroy: function(t) {
                            Si(t, !0)
                        }
                    };

                function Si(t, e) {
                    var n = t.data.ref;
                    if (i(n)) {
                        var r = t.context,
                            o = t.componentInstance || t.elm,
                            a = r.$refs;
                        e ? Array.isArray(a[n]) ? y(a[n], o) : a[n] === o && (a[n] = void 0) : t.data.refInFor ? Array.isArray(a[n]) ? a[n].indexOf(o) < 0 && a[n].push(o) : a[n] = [o] : a[n] = o
                    }
                }
                var Ei = new _t("", {}, []),
                    Ai = ["create", "activate", "update", "remove", "destroy"];

                function Li(t, e) {
                    return t.key === e.key && (t.tag === e.tag && t.isComment === e.isComment && i(t.data) === i(e.data) && Ri(t, e) || o(t.isAsyncPlaceholder) && t.asyncFactory === e.asyncFactory && r(e.asyncFactory.error))
                }

                function Ri(t, e) {
                    if ("input" !== t.tag) return !0;
                    var n, r = i(n = t.data) && i(n = n.attrs) && n.type,
                        o = i(n = e.data) && i(n = n.attrs) && n.type;
                    return r === o || li(r) && li(o)
                }

                function Ci(t, e, n) {
                    var r, o, a = {};
                    for (r = e; r <= n; ++r) o = t[r].key, i(o) && (a[o] = r);
                    return a
                }

                function Oi(t) {
                    var e, n, a = {},
                        c = t.modules,
                        l = t.nodeOps;
                    for (e = 0; e < Ai.length; ++e)
                        for (a[Ai[e]] = [], n = 0; n < c.length; ++n) i(c[n][Ai[e]]) && a[Ai[e]].push(c[n][Ai[e]]);

                    function u(t) {
                        return new _t(l.tagName(t).toLowerCase(), {}, [], void 0, t)
                    }

                    function h(t, e) {
                        function n() {
                            0 === --n.listeners && d(t)
                        }
                        return n.listeners = e, n
                    }

                    function d(t) {
                        var e = l.parentNode(t);
                        i(e) && l.removeChild(e, t)
                    }

                    function p(t, e, n, r, a, s, c) {
                        if (i(t.elm) && i(s) && (t = s[c] = Mt(t)), t.isRootInsert = !a, !f(t, e, n, r)) {
                            var u = t.data,
                                h = t.children,
                                d = t.tag;
                            i(d) ? (t.elm = t.ns ? l.createElementNS(t.ns, d) : l.createElement(d, t), w(t), _(t, h, e), i(u) && x(t, e), y(n, t.elm, r)) : o(t.isComment) ? (t.elm = l.createComment(t.text), y(n, t.elm, r)) : (t.elm = l.createTextNode(t.text), y(n, t.elm, r))
                        }
                    }

                    function f(t, e, n, r) {
                        var a = t.data;
                        if (i(a)) {
                            var s = i(t.componentInstance) && a.keepAlive;
                            if (i(a = a.hook) && i(a = a.init) && a(t, !1), i(t.componentInstance)) return m(t, e), y(n, t.elm, r), o(s) && v(t, e, n, r), !0
                        }
                    }

                    function m(t, e) {
                        i(t.data.pendingInsert) && (e.push.apply(e, t.data.pendingInsert), t.data.pendingInsert = null), t.elm = t.componentInstance.$el, b(t) ? (x(t, e), w(t)) : (Si(t), e.push(t))
                    }

                    function v(t, e, n, r) {
                        var o, s = t;
                        while (s.componentInstance)
                            if (s = s.componentInstance._vnode, i(o = s.data) && i(o = o.transition)) {
                                for (o = 0; o < a.activate.length; ++o) a.activate[o](Ei, s);
                                e.push(s);
                                break
                            }
                        y(n, t.elm, r)
                    }

                    function y(t, e, n) {
                        i(t) && (i(n) ? l.parentNode(n) === t && l.insertBefore(t, e, n) : l.appendChild(t, e))
                    }

                    function _(t, e, n) {
                        if (Array.isArray(e)) {
                            0;
                            for (var r = 0; r < e.length; ++r) p(e[r], n, t.elm, null, !0, e, r)
                        } else s(t.text) && l.appendChild(t.elm, l.createTextNode(String(t.text)))
                    }

                    function b(t) {
                        while (t.componentInstance) t = t.componentInstance._vnode;
                        return i(t.tag)
                    }

                    function x(t, n) {
                        for (var r = 0; r < a.create.length; ++r) a.create[r](Ei, t);
                        e = t.data.hook, i(e) && (i(e.create) && e.create(Ei, t), i(e.insert) && n.push(t))
                    }

                    function w(t) {
                        var e;
                        if (i(e = t.fnScopeId)) l.setStyleScope(t.elm, e);
                        else {
                            var n = t;
                            while (n) i(e = n.context) && i(e = e.$options._scopeId) && l.setStyleScope(t.elm, e), n = n.parent
                        }
                        i(e = Cn) && e !== t.context && e !== t.fnContext && i(e = e.$options._scopeId) && l.setStyleScope(t.elm, e)
                    }

                    function M(t, e, n, r, i, o) {
                        for (; r <= i; ++r) p(n[r], o, t, e, !1, n, r)
                    }

                    function T(t) {
                        var e, n, r = t.data;
                        if (i(r))
                            for (i(e = r.hook) && i(e = e.destroy) && e(t), e = 0; e < a.destroy.length; ++e) a.destroy[e](t);
                        if (i(e = t.children))
                            for (n = 0; n < t.children.length; ++n) T(t.children[n])
                    }

                    function S(t, e, n) {
                        for (; e <= n; ++e) {
                            var r = t[e];
                            i(r) && (i(r.tag) ? (E(r), T(r)) : d(r.elm))
                        }
                    }

                    function E(t, e) {
                        if (i(e) || i(t.data)) {
                            var n, r = a.remove.length + 1;
                            for (i(e) ? e.listeners += r : e = h(t.elm, r), i(n = t.componentInstance) && i(n = n._vnode) && i(n.data) && E(n, e), n = 0; n < a.remove.length; ++n) a.remove[n](t, e);
                            i(n = t.data.hook) && i(n = n.remove) ? n(t, e) : e()
                        } else d(t.elm)
                    }

                    function A(t, e, n, o, a) {
                        var s, c, u, h, d = 0,
                            f = 0,
                            m = e.length - 1,
                            g = e[0],
                            v = e[m],
                            y = n.length - 1,
                            _ = n[0],
                            b = n[y],
                            x = !a;
                        while (d <= m && f <= y) r(g) ? g = e[++d] : r(v) ? v = e[--m] : Li(g, _) ? (R(g, _, o, n, f), g = e[++d], _ = n[++f]) : Li(v, b) ? (R(v, b, o, n, y), v = e[--m], b = n[--y]) : Li(g, b) ? (R(g, b, o, n, y), x && l.insertBefore(t, g.elm, l.nextSibling(v.elm)), g = e[++d], b = n[--y]) : Li(v, _) ? (R(v, _, o, n, f), x && l.insertBefore(t, v.elm, g.elm), v = e[--m], _ = n[++f]) : (r(s) && (s = Ci(e, d, m)), c = i(_.key) ? s[_.key] : L(_, e, d, m), r(c) ? p(_, o, t, g.elm, !1, n, f) : (u = e[c], Li(u, _) ? (R(u, _, o, n, f), e[c] = void 0, x && l.insertBefore(t, u.elm, g.elm)) : p(_, o, t, g.elm, !1, n, f)), _ = n[++f]);
                        d > m ? (h = r(n[y + 1]) ? null : n[y + 1].elm, M(t, h, n, f, y, o)) : f > y && S(e, d, m)
                    }

                    function L(t, e, n, r) {
                        for (var o = n; o < r; o++) {
                            var a = e[o];
                            if (i(a) && Li(t, a)) return o
                        }
                    }

                    function R(t, e, n, s, c, u) {
                        if (t !== e) {
                            i(e.elm) && i(s) && (e = s[c] = Mt(e));
                            var h = e.elm = t.elm;
                            if (o(t.isAsyncPlaceholder)) i(e.asyncFactory.resolved) ? P(t.elm, e, n) : e.isAsyncPlaceholder = !0;
                            else if (o(e.isStatic) && o(t.isStatic) && e.key === t.key && (o(e.isCloned) || o(e.isOnce))) e.componentInstance = t.componentInstance;
                            else {
                                var d, p = e.data;
                                i(p) && i(d = p.hook) && i(d = d.prepatch) && d(t, e);
                                var f = t.children,
                                    m = e.children;
                                if (i(p) && b(e)) {
                                    for (d = 0; d < a.update.length; ++d) a.update[d](t, e);
                                    i(d = p.hook) && i(d = d.update) && d(t, e)
                                }
                                r(e.text) ? i(f) && i(m) ? f !== m && A(h, f, m, n, u) : i(m) ? (i(t.text) && l.setTextContent(h, ""), M(h, null, m, 0, m.length - 1, n)) : i(f) ? S(f, 0, f.length - 1) : i(t.text) && l.setTextContent(h, "") : t.text !== e.text && l.setTextContent(h, e.text), i(p) && i(d = p.hook) && i(d = d.postpatch) && d(t, e)
                            }
                        }
                    }

                    function C(t, e, n) {
                        if (o(n) && i(t.parent)) t.parent.data.pendingInsert = e;
                        else
                            for (var r = 0; r < e.length; ++r) e[r].data.hook.insert(e[r])
                    }
                    var O = g("attrs,class,staticClass,staticStyle,key");

                    function P(t, e, n, r) {
                        var a, s = e.tag,
                            c = e.data,
                            l = e.children;
                        if (r = r || c && c.pre, e.elm = t, o(e.isComment) && i(e.asyncFactory)) return e.isAsyncPlaceholder = !0, !0;
                        if (i(c) && (i(a = c.hook) && i(a = a.init) && a(e, !0), i(a = e.componentInstance))) return m(e, n), !0;
                        if (i(s)) {
                            if (i(l))
                                if (t.hasChildNodes())
                                    if (i(a = c) && i(a = a.domProps) && i(a = a.innerHTML)) {
                                        if (a !== t.innerHTML) return !1
                                    } else {
                                        for (var u = !0, h = t.firstChild, d = 0; d < l.length; d++) {
                                            if (!h || !P(h, l[d], n, r)) {
                                                u = !1;
                                                break
                                            }
                                            h = h.nextSibling
                                        }
                                        if (!u || h) return !1
                                    }
                            else _(e, l, n);
                            if (i(c)) {
                                var p = !1;
                                for (var f in c)
                                    if (!O(f)) {
                                        p = !0, x(e, n);
                                        break
                                    }!p && c["class"] && ge(c["class"])
                            }
                        } else t.data !== e.text && (t.data = e.text);
                        return !0
                    }
                    return function(t, e, n, s) {
                        if (!r(e)) {
                            var c = !1,
                                h = [];
                            if (r(t)) c = !0, p(e, h);
                            else {
                                var d = i(t.nodeType);
                                if (!d && Li(t, e)) R(t, e, h, null, null, s);
                                else {
                                    if (d) {
                                        if (1 === t.nodeType && t.hasAttribute(U) && (t.removeAttribute(U), n = !0), o(n) && P(t, e, h)) return C(e, h, !0), t;
                                        t = u(t)
                                    }
                                    var f = t.elm,
                                        m = l.parentNode(f);
                                    if (p(e, h, f._leaveCb ? null : m, l.nextSibling(f)), i(e.parent)) {
                                        var g = e.parent,
                                            v = b(e);
                                        while (g) {
                                            for (var y = 0; y < a.destroy.length; ++y) a.destroy[y](g);
                                            if (g.elm = e.elm, v) {
                                                for (var _ = 0; _ < a.create.length; ++_) a.create[_](Ei, g);
                                                var x = g.data.hook.insert;
                                                if (x.merged)
                                                    for (var w = 1; w < x.fns.length; w++) x.fns[w]()
                                            } else Si(g);
                                            g = g.parent
                                        }
                                    }
                                    i(m) ? S([t], 0, 0) : i(t.tag) && T(t)
                                }
                            }
                            return C(e, h, c), e.elm
                        }
                        i(t) && T(t)
                    }
                }
                var Pi = {
                    create: Ii,
                    update: Ii,
                    destroy: function(t) {
                        Ii(t, Ei)
                    }
                };

                function Ii(t, e) {
                    (t.data.directives || e.data.directives) && Ni(t, e)
                }

                function Ni(t, e) {
                    var n, r, i, o = t === Ei,
                        a = e === Ei,
                        s = ki(t.data.directives, t.context),
                        c = ki(e.data.directives, e.context),
                        l = [],
                        u = [];
                    for (n in c) r = s[n], i = c[n], r ? (i.oldValue = r.value, i.oldArg = r.arg, Bi(i, "update", e, t), i.def && i.def.componentUpdated && u.push(i)) : (Bi(i, "bind", e, t), i.def && i.def.inserted && l.push(i));
                    if (l.length) {
                        var h = function() {
                            for (var n = 0; n < l.length; n++) Bi(l[n], "inserted", e, t)
                        };
                        o ? xe(e, "insert", h) : h()
                    }
                    if (u.length && xe(e, "postpatch", (function() {
                            for (var n = 0; n < u.length; n++) Bi(u[n], "componentUpdated", e, t)
                        })), !o)
                        for (n in s) c[n] || Bi(s[n], "unbind", t, t, a)
                }
                var Di = Object.create(null);

                function ki(t, e) {
                    var n, r, i = Object.create(null);
                    if (!t) return i;
                    for (n = 0; n < t.length; n++) r = t[n], r.modifiers || (r.modifiers = Di), i[Fi(r)] = r, r.def = $t(e.$options, "directives", r.name, !0);
                    return i
                }

                function Fi(t) {
                    return t.rawName || t.name + "." + Object.keys(t.modifiers || {}).join(".")
                }

                function Bi(t, e, n, r, i) {
                    var o = t.def && t.def[e];
                    if (o) try {
                        o(n.elm, t, n, r, i)
                    } catch (Ma) {
                        ee(Ma, n.context, "directive " + t.name + " " + e + " hook")
                    }
                }
                var Ui = [Ti, Pi];

                function Hi(t, e) {
                    var n = e.componentOptions;
                    if ((!i(n) || !1 !== n.Ctor.options.inheritAttrs) && (!r(t.data.attrs) || !r(e.data.attrs))) {
                        var o, a, s, c = e.elm,
                            l = t.data.attrs || {},
                            u = e.data.attrs || {};
                        for (o in i(u.__ob__) && (u = e.data.attrs = O({}, u)), u) a = u[o], s = l[o], s !== a && zi(c, o, a);
                        for (o in (tt || nt) && u.value !== l.value && zi(c, "value", u.value), l) r(u[o]) && (Xr(o) ? c.removeAttributeNS(Wr, qr(o)) : zr(o) || c.removeAttribute(o))
                    }
                }

                function zi(t, e, n) {
                    t.tagName.indexOf("-") > -1 ? ji(t, e, n) : Vr(e) ? Yr(n) ? t.removeAttribute(e) : (n = "allowfullscreen" === e && "EMBED" === t.tagName ? "true" : e, t.setAttribute(e, n)) : zr(e) ? t.setAttribute(e, Gr(e, n)) : Xr(e) ? Yr(n) ? t.removeAttributeNS(Wr, qr(e)) : t.setAttributeNS(Wr, e, n) : ji(t, e, n)
                }

                function ji(t, e, n) {
                    if (Yr(n)) t.removeAttribute(e);
                    else {
                        if (tt && !et && "TEXTAREA" === t.tagName && "placeholder" === e && "" !== n && !t.__ieph) {
                            var r = function(e) {
                                e.stopImmediatePropagation(), t.removeEventListener("input", r)
                            };
                            t.addEventListener("input", r), t.__ieph = !0
                        }
                        t.setAttribute(e, n)
                    }
                }
                var Gi = {
                    create: Hi,
                    update: Hi
                };

                function Vi(t, e) {
                    var n = e.elm,
                        o = e.data,
                        a = t.data;
                    if (!(r(o.staticClass) && r(o.class) && (r(a) || r(a.staticClass) && r(a.class)))) {
                        var s = $r(e),
                            c = n._transitionClasses;
                        i(c) && (s = Kr(s, Qr(c))), s !== n._prevClass && (n.setAttribute("class", s), n._prevClass = s)
                    }
                }
                var Wi, Xi = {
                        create: Vi,
                        update: Vi
                    },
                    qi = "__r",
                    Yi = "__c";

                function $i(t) {
                    if (i(t[qi])) {
                        var e = tt ? "change" : "input";
                        t[e] = [].concat(t[qi], t[e] || []), delete t[qi]
                    }
                    i(t[Yi]) && (t.change = [].concat(t[Yi], t.change || []), delete t[Yi])
                }

                function Zi(t, e, n) {
                    var r = Wi;
                    return function i() {
                        var o = e.apply(null, arguments);
                        null !== o && Qi(t, i, n, r)
                    }
                }
                var Ji = ae && !(it && Number(it[1]) <= 53);

                function Ki(t, e, n, r) {
                    if (Ji) {
                        var i = qn,
                            o = e;
                        e = o._wrapper = function(t) {
                            if (t.target === t.currentTarget || t.timeStamp >= i || t.timeStamp <= 0 || t.target.ownerDocument !== document) return o.apply(this, arguments)
                        }
                    }
                    Wi.addEventListener(t, e, at ? {
                        capture: n,
                        passive: r
                    } : n)
                }

                function Qi(t, e, n, r) {
                    (r || Wi).removeEventListener(t, e._wrapper || e, n)
                }

                function to(t, e) {
                    if (!r(t.data.on) || !r(e.data.on)) {
                        var n = e.data.on || {},
                            i = t.data.on || {};
                        Wi = e.elm, $i(n), be(n, i, Ki, Qi, Zi, e.context), Wi = void 0
                    }
                }
                var eo, no = {
                    create: to,
                    update: to
                };

                function ro(t, e) {
                    if (!r(t.data.domProps) || !r(e.data.domProps)) {
                        var n, o, a = e.elm,
                            s = t.data.domProps || {},
                            c = e.data.domProps || {};
                        for (n in i(c.__ob__) && (c = e.data.domProps = O({}, c)), s) n in c || (a[n] = "");
                        for (n in c) {
                            if (o = c[n], "textContent" === n || "innerHTML" === n) {
                                if (e.children && (e.children.length = 0), o === s[n]) continue;
                                1 === a.childNodes.length && a.removeChild(a.childNodes[0])
                            }
                            if ("value" === n && "PROGRESS" !== a.tagName) {
                                a._value = o;
                                var l = r(o) ? "" : String(o);
                                io(a, l) && (a.value = l)
                            } else if ("innerHTML" === n && ii(a.tagName) && r(a.innerHTML)) {
                                eo = eo || document.createElement("div"), eo.innerHTML = "<svg>" + o + "</svg>";
                                var u = eo.firstChild;
                                while (a.firstChild) a.removeChild(a.firstChild);
                                while (u.firstChild) a.appendChild(u.firstChild)
                            } else if (o !== s[n]) try {
                                a[n] = o
                            } catch (Ma) {}
                        }
                    }
                }

                function io(t, e) {
                    return !t.composing && ("OPTION" === t.tagName || oo(t, e) || ao(t, e))
                }

                function oo(t, e) {
                    var n = !0;
                    try {
                        n = document.activeElement !== t
                    } catch (Ma) {}
                    return n && t.value !== e
                }

                function ao(t, e) {
                    var n = t.value,
                        r = t._vModifiers;
                    if (i(r)) {
                        if (r.number) return m(n) !== m(e);
                        if (r.trim) return n.trim() !== e.trim()
                    }
                    return n !== e
                }
                var so = {
                        create: ro,
                        update: ro
                    },
                    co = x((function(t) {
                        var e = {},
                            n = /;(?![^(]*\))/g,
                            r = /:(.+)/;
                        return t.split(n).forEach((function(t) {
                            if (t) {
                                var n = t.split(r);
                                n.length > 1 && (e[n[0].trim()] = n[1].trim())
                            }
                        })), e
                    }));

                function lo(t) {
                    var e = uo(t.style);
                    return t.staticStyle ? O(t.staticStyle, e) : e
                }

                function uo(t) {
                    return Array.isArray(t) ? P(t) : "string" === typeof t ? co(t) : t
                }

                function ho(t, e) {
                    var n, r = {};
                    if (e) {
                        var i = t;
                        while (i.componentInstance) i = i.componentInstance._vnode, i && i.data && (n = lo(i.data)) && O(r, n)
                    }(n = lo(t.data)) && O(r, n);
                    var o = t;
                    while (o = o.parent) o.data && (n = lo(o.data)) && O(r, n);
                    return r
                }
                var po, fo = /^--/,
                    mo = /\s*!important$/,
                    go = function(t, e, n) {
                        if (fo.test(e)) t.style.setProperty(e, n);
                        else if (mo.test(n)) t.style.setProperty(E(e), n.replace(mo, ""), "important");
                        else {
                            var r = yo(e);
                            if (Array.isArray(n))
                                for (var i = 0, o = n.length; i < o; i++) t.style[r] = n[i];
                            else t.style[r] = n
                        }
                    },
                    vo = ["Webkit", "Moz", "ms"],
                    yo = x((function(t) {
                        if (po = po || document.createElement("div").style, t = M(t), "filter" !== t && t in po) return t;
                        for (var e = t.charAt(0).toUpperCase() + t.slice(1), n = 0; n < vo.length; n++) {
                            var r = vo[n] + e;
                            if (r in po) return r
                        }
                    }));

                function _o(t, e) {
                    var n = e.data,
                        o = t.data;
                    if (!(r(n.staticStyle) && r(n.style) && r(o.staticStyle) && r(o.style))) {
                        var a, s, c = e.elm,
                            l = o.staticStyle,
                            u = o.normalizedStyle || o.style || {},
                            h = l || u,
                            d = uo(e.data.style) || {};
                        e.data.normalizedStyle = i(d.__ob__) ? O({}, d) : d;
                        var p = ho(e, !0);
                        for (s in h) r(p[s]) && go(c, s, "");
                        for (s in p) a = p[s], a !== h[s] && go(c, s, null == a ? "" : a)
                    }
                }
                var bo = {
                        create: _o,
                        update: _o
                    },
                    xo = /\s+/;

                function wo(t, e) {
                    if (e && (e = e.trim()))
                        if (t.classList) e.indexOf(" ") > -1 ? e.split(xo).forEach((function(e) {
                            return t.classList.add(e)
                        })) : t.classList.add(e);
                        else {
                            var n = " " + (t.getAttribute("class") || "") + " ";
                            n.indexOf(" " + e + " ") < 0 && t.setAttribute("class", (n + e).trim())
                        }
                }

                function Mo(t, e) {
                    if (e && (e = e.trim()))
                        if (t.classList) e.indexOf(" ") > -1 ? e.split(xo).forEach((function(e) {
                            return t.classList.remove(e)
                        })) : t.classList.remove(e), t.classList.length || t.removeAttribute("class");
                        else {
                            var n = " " + (t.getAttribute("class") || "") + " ",
                                r = " " + e + " ";
                            while (n.indexOf(r) >= 0) n = n.replace(r, " ");
                            n = n.trim(), n ? t.setAttribute("class", n) : t.removeAttribute("class")
                        }
                }

                function To(t) {
                    if (t) {
                        if ("object" === typeof t) {
                            var e = {};
                            return !1 !== t.css && O(e, So(t.name || "v")), O(e, t), e
                        }
                        return "string" === typeof t ? So(t) : void 0
                    }
                }
                var So = x((function(t) {
                        return {
                            enterClass: t + "-enter",
                            enterToClass: t + "-enter-to",
                            enterActiveClass: t + "-enter-active",
                            leaveClass: t + "-leave",
                            leaveToClass: t + "-leave-to",
                            leaveActiveClass: t + "-leave-active"
                        }
                    })),
                    Eo = Z && !et,
                    Ao = "transition",
                    Lo = "animation",
                    Ro = "transition",
                    Co = "transitionend",
                    Oo = "animation",
                    Po = "animationend";
                Eo && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (Ro = "WebkitTransition", Co = "webkitTransitionEnd"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (Oo = "WebkitAnimation", Po = "webkitAnimationEnd"));
                var Io = Z ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function(t) {
                    return t()
                };

                function No(t) {
                    Io((function() {
                        Io(t)
                    }))
                }

                function Do(t, e) {
                    var n = t._transitionClasses || (t._transitionClasses = []);
                    n.indexOf(e) < 0 && (n.push(e), wo(t, e))
                }

                function ko(t, e) {
                    t._transitionClasses && y(t._transitionClasses, e), Mo(t, e)
                }

                function Fo(t, e, n) {
                    var r = Uo(t, e),
                        i = r.type,
                        o = r.timeout,
                        a = r.propCount;
                    if (!i) return n();
                    var s = i === Ao ? Co : Po,
                        c = 0,
                        l = function() {
                            t.removeEventListener(s, u), n()
                        },
                        u = function(e) {
                            e.target === t && ++c >= a && l()
                        };
                    setTimeout((function() {
                        c < a && l()
                    }), o + 1), t.addEventListener(s, u)
                }
                var Bo = /\b(transform|all)(,|$)/;

                function Uo(t, e) {
                    var n, r = window.getComputedStyle(t),
                        i = (r[Ro + "Delay"] || "").split(", "),
                        o = (r[Ro + "Duration"] || "").split(", "),
                        a = Ho(i, o),
                        s = (r[Oo + "Delay"] || "").split(", "),
                        c = (r[Oo + "Duration"] || "").split(", "),
                        l = Ho(s, c),
                        u = 0,
                        h = 0;
                    e === Ao ? a > 0 && (n = Ao, u = a, h = o.length) : e === Lo ? l > 0 && (n = Lo, u = l, h = c.length) : (u = Math.max(a, l), n = u > 0 ? a > l ? Ao : Lo : null, h = n ? n === Ao ? o.length : c.length : 0);
                    var d = n === Ao && Bo.test(r[Ro + "Property"]);
                    return {
                        type: n,
                        timeout: u,
                        propCount: h,
                        hasTransform: d
                    }
                }

                function Ho(t, e) {
                    while (t.length < e.length) t = t.concat(t);
                    return Math.max.apply(null, e.map((function(e, n) {
                        return zo(e) + zo(t[n])
                    })))
                }

                function zo(t) {
                    return 1e3 * Number(t.slice(0, -1).replace(",", "."))
                }

                function jo(t, e) {
                    var n = t.elm;
                    i(n._leaveCb) && (n._leaveCb.cancelled = !0, n._leaveCb());
                    var o = To(t.data.transition);
                    if (!r(o) && !i(n._enterCb) && 1 === n.nodeType) {
                        var a = o.css,
                            s = o.type,
                            l = o.enterClass,
                            u = o.enterToClass,
                            h = o.enterActiveClass,
                            d = o.appearClass,
                            p = o.appearToClass,
                            f = o.appearActiveClass,
                            g = o.beforeEnter,
                            v = o.enter,
                            y = o.afterEnter,
                            _ = o.enterCancelled,
                            b = o.beforeAppear,
                            x = o.appear,
                            w = o.afterAppear,
                            M = o.appearCancelled,
                            T = o.duration,
                            S = Cn,
                            E = Cn.$vnode;
                        while (E && E.parent) S = E.context, E = E.parent;
                        var A = !S._isMounted || !t.isRootInsert;
                        if (!A || x || "" === x) {
                            var L = A && d ? d : l,
                                R = A && f ? f : h,
                                C = A && p ? p : u,
                                O = A && b || g,
                                P = A && "function" === typeof x ? x : v,
                                I = A && w || y,
                                N = A && M || _,
                                D = m(c(T) ? T.enter : T);
                            0;
                            var k = !1 !== a && !et,
                                F = Wo(P),
                                U = n._enterCb = B((function() {
                                    k && (ko(n, C), ko(n, R)), U.cancelled ? (k && ko(n, L), N && N(n)) : I && I(n), n._enterCb = null
                                }));
                            t.data.show || xe(t, "insert", (function() {
                                var e = n.parentNode,
                                    r = e && e._pending && e._pending[t.key];
                                r && r.tag === t.tag && r.elm._leaveCb && r.elm._leaveCb(), P && P(n, U)
                            })), O && O(n), k && (Do(n, L), Do(n, R), No((function() {
                                ko(n, L), U.cancelled || (Do(n, C), F || (Vo(D) ? setTimeout(U, D) : Fo(n, s, U)))
                            }))), t.data.show && (e && e(), P && P(n, U)), k || F || U()
                        }
                    }
                }

                function Go(t, e) {
                    var n = t.elm;
                    i(n._enterCb) && (n._enterCb.cancelled = !0, n._enterCb());
                    var o = To(t.data.transition);
                    if (r(o) || 1 !== n.nodeType) return e();
                    if (!i(n._leaveCb)) {
                        var a = o.css,
                            s = o.type,
                            l = o.leaveClass,
                            u = o.leaveToClass,
                            h = o.leaveActiveClass,
                            d = o.beforeLeave,
                            p = o.leave,
                            f = o.afterLeave,
                            g = o.leaveCancelled,
                            v = o.delayLeave,
                            y = o.duration,
                            _ = !1 !== a && !et,
                            b = Wo(p),
                            x = m(c(y) ? y.leave : y);
                        0;
                        var w = n._leaveCb = B((function() {
                            n.parentNode && n.parentNode._pending && (n.parentNode._pending[t.key] = null), _ && (ko(n, u), ko(n, h)), w.cancelled ? (_ && ko(n, l), g && g(n)) : (e(), f && f(n)), n._leaveCb = null
                        }));
                        v ? v(M) : M()
                    }

                    function M() {
                        w.cancelled || (!t.data.show && n.parentNode && ((n.parentNode._pending || (n.parentNode._pending = {}))[t.key] = t), d && d(n), _ && (Do(n, l), Do(n, h), No((function() {
                            ko(n, l), w.cancelled || (Do(n, u), b || (Vo(x) ? setTimeout(w, x) : Fo(n, s, w)))
                        }))), p && p(n, w), _ || b || w())
                    }
                }

                function Vo(t) {
                    return "number" === typeof t && !isNaN(t)
                }

                function Wo(t) {
                    if (r(t)) return !1;
                    var e = t.fns;
                    return i(e) ? Wo(Array.isArray(e) ? e[0] : e) : (t._length || t.length) > 1
                }

                function Xo(t, e) {
                    !0 !== e.data.show && jo(e)
                }
                var qo = Z ? {
                        create: Xo,
                        activate: Xo,
                        remove: function(t, e) {
                            !0 !== t.data.show ? Go(t, e) : e()
                        }
                    } : {},
                    Yo = [Gi, Xi, no, so, bo, qo],
                    $o = Yo.concat(Ui),
                    Zo = Oi({
                        nodeOps: Mi,
                        modules: $o
                    });
                et && document.addEventListener("selectionchange", (function() {
                    var t = document.activeElement;
                    t && t.vmodel && ia(t, "input")
                }));
                var Jo = {
                    inserted: function(t, e, n, r) {
                        "select" === n.tag ? (r.elm && !r.elm._vOptions ? xe(n, "postpatch", (function() {
                            Jo.componentUpdated(t, e, n)
                        })) : Ko(t, e, n.context), t._vOptions = [].map.call(t.options, ea)) : ("textarea" === n.tag || li(t.type)) && (t._vModifiers = e.modifiers, e.modifiers.lazy || (t.addEventListener("compositionstart", na), t.addEventListener("compositionend", ra), t.addEventListener("change", ra), et && (t.vmodel = !0)))
                    },
                    componentUpdated: function(t, e, n) {
                        if ("select" === n.tag) {
                            Ko(t, e, n.context);
                            var r = t._vOptions,
                                i = t._vOptions = [].map.call(t.options, ea);
                            if (i.some((function(t, e) {
                                    return !k(t, r[e])
                                }))) {
                                var o = t.multiple ? e.value.some((function(t) {
                                    return ta(t, i)
                                })) : e.value !== e.oldValue && ta(e.value, i);
                                o && ia(t, "change")
                            }
                        }
                    }
                };

                function Ko(t, e, n) {
                    Qo(t, e, n), (tt || nt) && setTimeout((function() {
                        Qo(t, e, n)
                    }), 0)
                }

                function Qo(t, e, n) {
                    var r = e.value,
                        i = t.multiple;
                    if (!i || Array.isArray(r)) {
                        for (var o, a, s = 0, c = t.options.length; s < c; s++)
                            if (a = t.options[s], i) o = F(r, ea(a)) > -1, a.selected !== o && (a.selected = o);
                            else if (k(ea(a), r)) return void(t.selectedIndex !== s && (t.selectedIndex = s));
                        i || (t.selectedIndex = -1)
                    }
                }

                function ta(t, e) {
                    return e.every((function(e) {
                        return !k(e, t)
                    }))
                }

                function ea(t) {
                    return "_value" in t ? t._value : t.value
                }

                function na(t) {
                    t.target.composing = !0
                }

                function ra(t) {
                    t.target.composing && (t.target.composing = !1, ia(t.target, "input"))
                }

                function ia(t, e) {
                    var n = document.createEvent("HTMLEvents");
                    n.initEvent(e, !0, !0), t.dispatchEvent(n)
                }

                function oa(t) {
                    return !t.componentInstance || t.data && t.data.transition ? t : oa(t.componentInstance._vnode)
                }
                var aa = {
                        bind: function(t, e, n) {
                            var r = e.value;
                            n = oa(n);
                            var i = n.data && n.data.transition,
                                o = t.__vOriginalDisplay = "none" === t.style.display ? "" : t.style.display;
                            r && i ? (n.data.show = !0, jo(n, (function() {
                                t.style.display = o
                            }))) : t.style.display = r ? o : "none"
                        },
                        update: function(t, e, n) {
                            var r = e.value,
                                i = e.oldValue;
                            if (!r !== !i) {
                                n = oa(n);
                                var o = n.data && n.data.transition;
                                o ? (n.data.show = !0, r ? jo(n, (function() {
                                    t.style.display = t.__vOriginalDisplay
                                })) : Go(n, (function() {
                                    t.style.display = "none"
                                }))) : t.style.display = r ? t.__vOriginalDisplay : "none"
                            }
                        },
                        unbind: function(t, e, n, r, i) {
                            i || (t.style.display = t.__vOriginalDisplay)
                        }
                    },
                    sa = {
                        model: Jo,
                        show: aa
                    },
                    ca = {
                        name: String,
                        appear: Boolean,
                        css: Boolean,
                        mode: String,
                        type: String,
                        enterClass: String,
                        leaveClass: String,
                        enterToClass: String,
                        leaveToClass: String,
                        enterActiveClass: String,
                        leaveActiveClass: String,
                        appearClass: String,
                        appearActiveClass: String,
                        appearToClass: String,
                        duration: [Number, String, Object]
                    };

                function la(t) {
                    var e = t && t.componentOptions;
                    return e && e.Ctor.options.abstract ? la(Mn(e.children)) : t
                }

                function ua(t) {
                    var e = {},
                        n = t.$options;
                    for (var r in n.propsData) e[r] = t[r];
                    var i = n._parentListeners;
                    for (var o in i) e[M(o)] = i[o];
                    return e
                }

                function ha(t, e) {
                    if (/\d-keep-alive$/.test(e.tag)) return t("keep-alive", {
                        props: e.componentOptions.propsData
                    })
                }

                function da(t) {
                    while (t = t.parent)
                        if (t.data.transition) return !0
                }

                function pa(t, e) {
                    return e.key === t.key && e.tag === t.tag
                }
                var fa = function(t) {
                        return t.tag || wn(t)
                    },
                    ma = function(t) {
                        return "show" === t.name
                    },
                    ga = {
                        name: "transition",
                        props: ca,
                        abstract: !0,
                        render: function(t) {
                            var e = this,
                                n = this.$slots.default;
                            if (n && (n = n.filter(fa), n.length)) {
                                0;
                                var r = this.mode;
                                0;
                                var i = n[0];
                                if (da(this.$vnode)) return i;
                                var o = la(i);
                                if (!o) return i;
                                if (this._leaving) return ha(t, i);
                                var a = "__transition-" + this._uid + "-";
                                o.key = null == o.key ? o.isComment ? a + "comment" : a + o.tag : s(o.key) ? 0 === String(o.key).indexOf(a) ? o.key : a + o.key : o.key;
                                var c = (o.data || (o.data = {})).transition = ua(this),
                                    l = this._vnode,
                                    u = la(l);
                                if (o.data.directives && o.data.directives.some(ma) && (o.data.show = !0), u && u.data && !pa(o, u) && !wn(u) && (!u.componentInstance || !u.componentInstance._vnode.isComment)) {
                                    var h = u.data.transition = O({}, c);
                                    if ("out-in" === r) return this._leaving = !0, xe(h, "afterLeave", (function() {
                                        e._leaving = !1, e.$forceUpdate()
                                    })), ha(t, i);
                                    if ("in-out" === r) {
                                        if (wn(o)) return l;
                                        var d, p = function() {
                                            d()
                                        };
                                        xe(c, "afterEnter", p), xe(c, "enterCancelled", p), xe(h, "delayLeave", (function(t) {
                                            d = t
                                        }))
                                    }
                                }
                                return i
                            }
                        }
                    },
                    va = O({
                        tag: String,
                        moveClass: String
                    }, ca);
                delete va.mode;
                var ya = {
                    props: va,
                    beforeMount: function() {
                        var t = this,
                            e = this._update;
                        this._update = function(n, r) {
                            var i = On(t);
                            t.__patch__(t._vnode, t.kept, !1, !0), t._vnode = t.kept, i(), e.call(t, n, r)
                        }
                    },
                    render: function(t) {
                        for (var e = this.tag || this.$vnode.data.tag || "span", n = Object.create(null), r = this.prevChildren = this.children, i = this.$slots.default || [], o = this.children = [], a = ua(this), s = 0; s < i.length; s++) {
                            var c = i[s];
                            if (c.tag)
                                if (null != c.key && 0 !== String(c.key).indexOf("__vlist")) o.push(c), n[c.key] = c, (c.data || (c.data = {})).transition = a;
                                else;
                        }
                        if (r) {
                            for (var l = [], u = [], h = 0; h < r.length; h++) {
                                var d = r[h];
                                d.data.transition = a, d.data.pos = d.elm.getBoundingClientRect(), n[d.key] ? l.push(d) : u.push(d)
                            }
                            this.kept = t(e, null, l), this.removed = u
                        }
                        return t(e, null, o)
                    },
                    updated: function() {
                        var t = this.prevChildren,
                            e = this.moveClass || (this.name || "v") + "-move";
                        t.length && this.hasMove(t[0].elm, e) && (t.forEach(_a), t.forEach(ba), t.forEach(xa), this._reflow = document.body.offsetHeight, t.forEach((function(t) {
                            if (t.data.moved) {
                                var n = t.elm,
                                    r = n.style;
                                Do(n, e), r.transform = r.WebkitTransform = r.transitionDuration = "", n.addEventListener(Co, n._moveCb = function t(r) {
                                    r && r.target !== n || r && !/transform$/.test(r.propertyName) || (n.removeEventListener(Co, t), n._moveCb = null, ko(n, e))
                                })
                            }
                        })))
                    },
                    methods: {
                        hasMove: function(t, e) {
                            if (!Eo) return !1;
                            if (this._hasMove) return this._hasMove;
                            var n = t.cloneNode();
                            t._transitionClasses && t._transitionClasses.forEach((function(t) {
                                Mo(n, t)
                            })), wo(n, e), n.style.display = "none", this.$el.appendChild(n);
                            var r = Uo(n);
                            return this.$el.removeChild(n), this._hasMove = r.hasTransform
                        }
                    }
                };

                function _a(t) {
                    t.elm._moveCb && t.elm._moveCb(), t.elm._enterCb && t.elm._enterCb()
                }

                function ba(t) {
                    t.data.newPos = t.elm.getBoundingClientRect()
                }

                function xa(t) {
                    var e = t.data.pos,
                        n = t.data.newPos,
                        r = e.left - n.left,
                        i = e.top - n.top;
                    if (r || i) {
                        t.data.moved = !0;
                        var o = t.elm.style;
                        o.transform = o.WebkitTransform = "translate(" + r + "px," + i + "px)", o.transitionDuration = "0s"
                    }
                }
                var wa = {
                    Transition: ga,
                    TransitionGroup: ya
                };
                Mr.config.mustUseProp = Hr, Mr.config.isReservedTag = oi, Mr.config.isReservedAttr = Br, Mr.config.getTagNamespace = ai, Mr.config.isUnknownElement = ci, O(Mr.options.directives, sa), O(Mr.options.components, wa), Mr.prototype.__patch__ = Z ? Zo : I, Mr.prototype.$mount = function(t, e) {
                    return t = t && Z ? ui(t) : void 0, Nn(this, t, e)
                }, Z && setTimeout((function() {
                    j.devtools && lt && lt.emit("init", Mr)
                }), 0), e["a"] = Mr
            }).call(this, n("c8ba"))
        },
        "2caf": function(t, e, n) {
            "use strict";
            n.d(e, "a", (function() {
                return c
            }));
            n("4ae1"), n("3410");

            function r(t) {
                return r = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                }, r(t)
            }
            n("d3b7"), n("25f0");

            function i() {
                if ("undefined" === typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" === typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
                } catch (t) {
                    return !1
                }
            }
            var o = n("53ca"),
                a = n("257e");

            function s(t, e) {
                return !e || "object" !== Object(o["a"])(e) && "function" !== typeof e ? Object(a["a"])(t) : e
            }

            function c(t) {
                var e = i();
                return function() {
                    var n, i = r(t);
                    if (e) {
                        var o = r(this).constructor;
                        n = Reflect.construct(i, arguments, o)
                    } else n = i.apply(this, arguments);
                    return s(this, n)
                }
            }
        },
        "2cf4": function(t, e, n) {
            var r, i, o, a = n("da84"),
                s = n("d039"),
                c = n("c6b6"),
                l = n("0366"),
                u = n("1be4"),
                h = n("cc12"),
                d = n("1cdc"),
                p = a.location,
                f = a.setImmediate,
                m = a.clearImmediate,
                g = a.process,
                v = a.MessageChannel,
                y = a.Dispatch,
                _ = 0,
                b = {},
                x = "onreadystatechange",
                w = function(t) {
                    if (b.hasOwnProperty(t)) {
                        var e = b[t];
                        delete b[t], e()
                    }
                },
                M = function(t) {
                    return function() {
                        w(t)
                    }
                },
                T = function(t) {
                    w(t.data)
                },
                S = function(t) {
                    a.postMessage(t + "", p.protocol + "//" + p.host)
                };
            f && m || (f = function(t) {
                var e = [],
                    n = 1;
                while (arguments.length > n) e.push(arguments[n++]);
                return b[++_] = function() {
                    ("function" == typeof t ? t : Function(t)).apply(void 0, e)
                }, r(_), _
            }, m = function(t) {
                delete b[t]
            }, "process" == c(g) ? r = function(t) {
                g.nextTick(M(t))
            } : y && y.now ? r = function(t) {
                y.now(M(t))
            } : v && !d ? (i = new v, o = i.port2, i.port1.onmessage = T, r = l(o.postMessage, o, 1)) : !a.addEventListener || "function" != typeof postMessage || a.importScripts || s(S) || "file:" === p.protocol ? r = x in h("script") ? function(t) {
                u.appendChild(h("script"))[x] = function() {
                    u.removeChild(this), w(t)
                }
            } : function(t) {
                setTimeout(M(t), 0)
            } : (r = S, a.addEventListener("message", T, !1))), t.exports = {
                set: f,
                clear: m
            }
        },
        "2d00": function(t, e, n) {
            var r, i, o = n("da84"),
                a = n("342f"),
                s = o.process,
                c = s && s.versions,
                l = c && c.v8;
            l ? (r = l.split("."), i = r[0] + r[1]) : a && (r = a.match(/Edge\/(\d+)/), (!r || r[1] >= 74) && (r = a.match(/Chrome\/(\d+)/), r && (i = r[1]))), t.exports = i && +i
        },
        3191: function(t, e, n) {
            (function(e, n) {
                t.exports = n()
            })(0, (function() {
                var t = function() {
                    function e(t) {
                        return i.appendChild(t.dom), t
                    }

                    function n(t) {
                        for (var e = 0; e < i.children.length; e++) i.children[e].style.display = e === t ? "block" : "none";
                        r = t
                    }
                    var r = 0,
                        i = document.createElement("div");
                    i.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", i.addEventListener("click", (function(t) {
                        t.preventDefault(), n(++r % i.children.length)
                    }), !1);
                    var o = (performance || Date).now(),
                        a = o,
                        s = 0,
                        c = e(new t.Panel("FPS", "#0ff", "#002")),
                        l = e(new t.Panel("MS", "#0f0", "#020"));
                    if (self.performance && self.performance.memory) var u = e(new t.Panel("MB", "#f08", "#201"));
                    return n(0), {
                        REVISION: 16,
                        dom: i,
                        addPanel: e,
                        showPanel: n,
                        begin: function() {
                            o = (performance || Date).now()
                        },
                        end: function() {
                            s++;
                            var t = (performance || Date).now();
                            if (l.update(t - o, 200), t > a + 1e3 && (c.update(1e3 * s / (t - a), 100), a = t, s = 0, u)) {
                                var e = performance.memory;
                                u.update(e.usedJSHeapSize / 1048576, e.jsHeapSizeLimit / 1048576)
                            }
                            return t
                        },
                        update: function() {
                            o = this.end()
                        },
                        domElement: i,
                        setMode: n
                    }
                };
                return t.Panel = function(t, e, n) {
                    var r = 1 / 0,
                        i = 0,
                        o = Math.round,
                        a = o(window.devicePixelRatio || 1),
                        s = 80 * a,
                        c = 48 * a,
                        l = 3 * a,
                        u = 2 * a,
                        h = 3 * a,
                        d = 15 * a,
                        p = 74 * a,
                        f = 30 * a,
                        m = document.createElement("canvas");
                    m.width = s, m.height = c, m.style.cssText = "width:80px;height:48px";
                    var g = m.getContext("2d");
                    return g.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif", g.textBaseline = "top", g.fillStyle = n, g.fillRect(0, 0, s, c), g.fillStyle = e, g.fillText(t, l, u), g.fillRect(h, d, p, f), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(h, d, p, f), {
                        dom: m,
                        update: function(c, v) {
                            r = Math.min(r, c), i = Math.max(i, c), g.fillStyle = n, g.globalAlpha = 1, g.fillRect(0, 0, s, d), g.fillStyle = e, g.fillText(o(c) + " " + t + " (" + o(r) + "-" + o(i) + ")", l, u), g.drawImage(m, h + a, d, p - a, f, h, d, p - a, f), g.fillRect(h + p - a, d, a, f), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(h + p - a, d, a, o((1 - c / v) * f))
                        }
                    }
                }, t
            }))
        },
        3280: function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("e58c"),
                o = r.aTypedArray,
                a = r.exportTypedArrayMethod;
            a("lastIndexOf", (function(t) {
                return i.apply(o(this), arguments)
            }))
        },
        "32d9": function(t, e, n) {
            "use strict";
            n.d(e, "a", (function() {
                return l
            }));
            var r = n("5a89"),
                i = {
                    uniforms: {
                        tDiffuse: {
                            value: null
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "\tvUv = uv;", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "\tvec4 texel = texture2D( tDiffuse, vUv );", "\tgl_FragColor = opacity * texel;", "}"].join("\n")
                },
                o = n("360d"),
                a = n("1b53"),
                s = function(t, e) {
                    a["a"].call(this), this.scene = t, this.camera = e, this.clear = !0, this.needsSwap = !1, this.inverse = !1
                };
            s.prototype = Object.assign(Object.create(a["a"].prototype), {
                constructor: s,
                render: function(t, e, n) {
                    var r, i, o = t.getContext(),
                        a = t.state;
                    a.buffers.color.setMask(!1), a.buffers.depth.setMask(!1), a.buffers.color.setLocked(!0), a.buffers.depth.setLocked(!0), this.inverse ? (r = 0, i = 1) : (r = 1, i = 0), a.buffers.stencil.setTest(!0), a.buffers.stencil.setOp(o.REPLACE, o.REPLACE, o.REPLACE), a.buffers.stencil.setFunc(o.ALWAYS, r, 4294967295), a.buffers.stencil.setClear(i), a.buffers.stencil.setLocked(!0), t.setRenderTarget(n), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), a.buffers.color.setLocked(!1), a.buffers.depth.setLocked(!1), a.buffers.stencil.setLocked(!1), a.buffers.stencil.setFunc(o.EQUAL, 1, 4294967295), a.buffers.stencil.setOp(o.KEEP, o.KEEP, o.KEEP), a.buffers.stencil.setLocked(!0)
                }
            });
            var c = function() {
                a["a"].call(this), this.needsSwap = !1
            };
            c.prototype = Object.create(a["a"].prototype), Object.assign(c.prototype, {
                render: function(t) {
                    t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1)
                }
            });
            var l = function(t, e) {
                if (this.renderer = t, void 0 === e) {
                    var n = {
                            minFilter: r["J"],
                            magFilter: r["J"],
                            format: r["sb"]
                        },
                        a = t.getSize(new r["Qb"]);
                    this._pixelRatio = t.getPixelRatio(), this._width = a.width, this._height = a.height, e = new r["Ub"](this._width * this._pixelRatio, this._height * this._pixelRatio, n), e.texture.name = "EffectComposer.rt1"
                } else this._pixelRatio = 1, this._width = e.width, this._height = e.height;
                this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], void 0 === i && console.error("THREE.EffectComposer relies on CopyShader"), void 0 === o["a"] && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new o["a"](i), this.clock = new r["i"]
            };
            Object.assign(l.prototype, {
                swapBuffers: function() {
                    var t = this.readBuffer;
                    this.readBuffer = this.writeBuffer, this.writeBuffer = t
                },
                addPass: function(t) {
                    this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                },
                insertPass: function(t, e) {
                    this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                },
                isLastEnabledPass: function(t) {
                    for (var e = t + 1; e < this.passes.length; e++)
                        if (this.passes[e].enabled) return !1;
                    return !0
                },
                render: function(t) {
                    void 0 === t && (t = this.clock.getDelta());
                    var e, n, r = this.renderer.getRenderTarget(),
                        i = !1,
                        o = this.passes.length;
                    for (n = 0; n < o; n++)
                        if (e = this.passes[n], !1 !== e.enabled) {
                            if (e.renderToScreen = this.renderToScreen && this.isLastEnabledPass(n), e.render(this.renderer, this.writeBuffer, this.readBuffer, t, i), e.needsSwap) {
                                if (i) {
                                    var a = this.renderer.getContext(),
                                        l = this.renderer.state.buffers.stencil;
                                    l.setFunc(a.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), l.setFunc(a.EQUAL, 1, 4294967295)
                                }
                                this.swapBuffers()
                            }
                            void 0 !== s && (e instanceof s ? i = !0 : e instanceof c && (i = !1))
                        }
                    this.renderer.setRenderTarget(r)
                },
                reset: function(t) {
                    if (void 0 === t) {
                        var e = this.renderer.getSize(new r["Qb"]);
                        this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, t = this.renderTarget1.clone(), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                    }
                    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
                },
                setSize: function(t, e) {
                    this._width = t, this._height = e;
                    var n = this._width * this._pixelRatio,
                        r = this._height * this._pixelRatio;
                    this.renderTarget1.setSize(n, r), this.renderTarget2.setSize(n, r);
                    for (var i = 0; i < this.passes.length; i++) this.passes[i].setSize(n, r)
                },
                setPixelRatio: function(t) {
                    this._pixelRatio = t, this.setSize(this._width, this._height)
                }
            });
            var u = function() {
                this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
            };
            Object.assign(u.prototype, {
                setSize: function() {},
                render: function() {
                    console.error("THREE.Pass: .render() must be implemented in derived pass.")
                }
            }), u.FullScreenQuad = function() {
                var t = new r["gb"](-1, 1, 1, -1, 0, 1),
                    e = new r["jb"](2, 2),
                    n = function(t) {
                        this._mesh = new r["T"](e, t)
                    };
                return Object.defineProperty(n.prototype, "material", {
                    get: function() {
                        return this._mesh.material
                    },
                    set: function(t) {
                        this._mesh.material = t
                    }
                }), Object.assign(n.prototype, {
                    dispose: function() {
                        this._mesh.geometry.dispose()
                    },
                    render: function(e) {
                        e.render(this._mesh, t)
                    }
                }), n
            }()
        },
        3410: function(t, e, n) {
            var r = n("23e7"),
                i = n("d039"),
                o = n("7b0b"),
                a = n("e163"),
                s = n("e177"),
                c = i((function() {
                    a(1)
                }));
            r({
                target: "Object",
                stat: !0,
                forced: c,
                sham: !s
            }, {
                getPrototypeOf: function(t) {
                    return a(o(t))
                }
            })
        },
        "342f": function(t, e, n) {
            var r = n("d066");
            t.exports = r("navigator", "userAgent") || ""
        },
        "34ad": function(t, e, n) {
            "use strict";
            n.d(e, "a", (function() {
                return i
            }));
            var r = n("5a89"),
                i = function() {
                    function t(t) {
                        r["M"].call(this, t), this.dracoLoader = null, this.ddsLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(t) {
                            return new s(t)
                        })), this.register((function(t) {
                            return new l(t)
                        })), this.register((function(t) {
                            return new u(t)
                        })), this.register((function(t) {
                            return new c(t)
                        })), this.register((function(t) {
                            return new o(t)
                        })), this.register((function(t) {
                            return new h(t)
                        }))
                    }

                    function e() {
                        var t = {};
                        return {
                            get: function(e) {
                                return t[e]
                            },
                            add: function(e, n) {
                                t[e] = n
                            },
                            remove: function(e) {
                                delete t[e]
                            },
                            removeAll: function() {
                                t = {}
                            }
                        }
                    }
                    t.prototype = Object.assign(Object.create(r["M"].prototype), {
                        constructor: t,
                        load: function(t, e, n, i) {
                            var o, a = this;
                            o = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : r["N"].extractUrlBase(t), this.manager.itemStart(t);
                            var s = function(e) {
                                    i ? i(e) : console.error(e), a.manager.itemError(t), a.manager.itemEnd(t)
                                },
                                c = new r["t"](this.manager);
                            c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(this.withCredentials), c.load(t, (function(n) {
                                try {
                                    a.parse(n, o, (function(n) {
                                        e(n), a.manager.itemEnd(t)
                                    }), s)
                                } catch (r) {
                                    s(r)
                                }
                            }), n, s)
                        },
                        setDRACOLoader: function(t) {
                            return this.dracoLoader = t, this
                        },
                        setDDSLoader: function(t) {
                            return this.ddsLoader = t, this
                        },
                        setKTX2Loader: function(t) {
                            return this.ktx2Loader = t, this
                        },
                        setMeshoptDecoder: function(t) {
                            return this.meshoptDecoder = t, this
                        },
                        register: function(t) {
                            return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this
                        },
                        unregister: function(t) {
                            return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this
                        },
                        parse: function(t, e, o, s) {
                            var c, l = {},
                                u = {};
                            if ("string" === typeof t) c = t;
                            else {
                                var h = r["N"].decodeText(new Uint8Array(t, 0, 4));
                                if (h === d) {
                                    try {
                                        l[n.KHR_BINARY_GLTF] = new m(t)
                                    } catch (T) {
                                        return void(s && s(T))
                                    }
                                    c = l[n.KHR_BINARY_GLTF].content
                                } else c = r["N"].decodeText(new Uint8Array(t))
                            }
                            var p = JSON.parse(c);
                            if (void 0 === p.asset || p.asset.version[0] < 2) s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                            else {
                                var f = new U(p, {
                                    path: e || this.resourcePath || "",
                                    crossOrigin: this.crossOrigin,
                                    manager: this.manager,
                                    ktx2Loader: this.ktx2Loader,
                                    meshoptDecoder: this.meshoptDecoder
                                });
                                f.fileLoader.setRequestHeader(this.requestHeader);
                                for (var y = 0; y < this.pluginCallbacks.length; y++) {
                                    var x = this.pluginCallbacks[y](f);
                                    u[x.name] = x, l[x.name] = !0
                                }
                                if (p.extensionsUsed)
                                    for (y = 0; y < p.extensionsUsed.length; ++y) {
                                        var w = p.extensionsUsed[y],
                                            M = p.extensionsRequired || [];
                                        switch (w) {
                                            case n.KHR_MATERIALS_UNLIT:
                                                l[w] = new a;
                                                break;
                                            case n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                                l[w] = new _;
                                                break;
                                            case n.KHR_DRACO_MESH_COMPRESSION:
                                                l[w] = new g(p, this.dracoLoader);
                                                break;
                                            case n.MSFT_TEXTURE_DDS:
                                                l[w] = new i(this.ddsLoader);
                                                break;
                                            case n.KHR_TEXTURE_TRANSFORM:
                                                l[w] = new v;
                                                break;
                                            case n.KHR_MESH_QUANTIZATION:
                                                l[w] = new b;
                                                break;
                                            default:
                                                M.indexOf(w) >= 0 && void 0 === u[w] && console.warn('THREE.GLTFLoader: Unknown extension "' + w + '".')
                                        }
                                    }
                                f.setExtensions(l), f.setPlugins(u), f.parse(o, s)
                            }
                        }
                    });
                    var n = {
                        KHR_BINARY_GLTF: "KHR_binary_glTF",
                        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
                        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
                        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
                        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                        EXT_TEXTURE_WEBP: "EXT_texture_webp",
                        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
                        MSFT_TEXTURE_DDS: "MSFT_texture_dds"
                    };

                    function i(t) {
                        if (!t) throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader");
                        this.name = n.MSFT_TEXTURE_DDS, this.ddsLoader = t
                    }

                    function o(t) {
                        this.parser = t, this.name = n.KHR_LIGHTS_PUNCTUAL, this.cache = {
                            refs: {},
                            uses: {}
                        }
                    }

                    function a() {
                        this.name = n.KHR_MATERIALS_UNLIT
                    }

                    function s(t) {
                        this.parser = t, this.name = n.KHR_MATERIALS_CLEARCOAT
                    }

                    function c(t) {
                        this.parser = t, this.name = n.KHR_MATERIALS_TRANSMISSION
                    }

                    function l(t) {
                        this.parser = t, this.name = n.KHR_TEXTURE_BASISU
                    }

                    function u(t) {
                        this.parser = t, this.name = n.EXT_TEXTURE_WEBP, this.isSupported = null
                    }

                    function h(t) {
                        this.name = n.EXT_MESHOPT_COMPRESSION, this.parser = t
                    }
                    o.prototype._markDefs = function() {
                        for (var t = this.parser, e = this.parser.json.nodes || [], n = 0, r = e.length; n < r; n++) {
                            var i = e[n];
                            i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && t._addNodeRef(this.cache, i.extensions[this.name].light)
                        }
                    }, o.prototype._loadLight = function(t) {
                        var e = this.parser,
                            n = "light:" + t,
                            i = e.cache.get(n);
                        if (i) return i;
                        var o, a = e.json,
                            s = a.extensions && a.extensions[this.name] || {},
                            c = s.lights || [],
                            l = c[t],
                            u = new r["j"](16777215);
                        void 0 !== l.color && u.fromArray(l.color);
                        var h = void 0 !== l.range ? l.range : 0;
                        switch (l.type) {
                            case "directional":
                                o = new r["m"](u), o.target.position.set(0, 0, -1), o.add(o.target);
                                break;
                            case "point":
                                o = new r["lb"](u), o.distance = h;
                                break;
                            case "spot":
                                o = new r["Fb"](u), o.distance = h, l.spot = l.spot || {}, l.spot.innerConeAngle = void 0 !== l.spot.innerConeAngle ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = void 0 !== l.spot.outerConeAngle ? l.spot.outerConeAngle : Math.PI / 4, o.angle = l.spot.outerConeAngle, o.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target);
                                break;
                            default:
                                throw new Error('THREE.GLTFLoader: Unexpected light type, "' + l.type + '".')
                        }
                        return o.position.set(0, 0, 0), o.decay = 2, void 0 !== l.intensity && (o.intensity = l.intensity), o.name = e.createUniqueName(l.name || "light_" + t), i = Promise.resolve(o), e.cache.add(n, i), i
                    }, o.prototype.createNodeAttachment = function(t) {
                        var e = this,
                            n = this.parser,
                            r = n.json,
                            i = r.nodes[t],
                            o = i.extensions && i.extensions[this.name] || {},
                            a = o.light;
                        return void 0 === a ? null : this._loadLight(a).then((function(t) {
                            return n._getNodeRef(e.cache, a, t)
                        }))
                    }, a.prototype.getMaterialType = function() {
                        return r["U"]
                    }, a.prototype.extendParams = function(t, e, n) {
                        var i = [];
                        t.color = new r["j"](1, 1, 1), t.opacity = 1;
                        var o = e.pbrMetallicRoughness;
                        if (o) {
                            if (Array.isArray(o.baseColorFactor)) {
                                var a = o.baseColorFactor;
                                t.color.fromArray(a), t.opacity = a[3]
                            }
                            void 0 !== o.baseColorTexture && i.push(n.assignTexture(t, "map", o.baseColorTexture))
                        }
                        return Promise.all(i)
                    }, s.prototype.getMaterialType = function(t) {
                        var e = this.parser,
                            n = e.json.materials[t];
                        return n.extensions && n.extensions[this.name] ? r["X"] : null
                    }, s.prototype.extendMaterialParams = function(t, e) {
                        var n = this.parser,
                            i = n.json.materials[t];
                        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                        var o = [],
                            a = i.extensions[this.name];
                        if (void 0 !== a.clearcoatFactor && (e.clearcoat = a.clearcoatFactor), void 0 !== a.clearcoatTexture && o.push(n.assignTexture(e, "clearcoatMap", a.clearcoatTexture)), void 0 !== a.clearcoatRoughnessFactor && (e.clearcoatRoughness = a.clearcoatRoughnessFactor), void 0 !== a.clearcoatRoughnessTexture && o.push(n.assignTexture(e, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), void 0 !== a.clearcoatNormalTexture && (o.push(n.assignTexture(e, "clearcoatNormalMap", a.clearcoatNormalTexture)), void 0 !== a.clearcoatNormalTexture.scale)) {
                            var s = a.clearcoatNormalTexture.scale;
                            e.clearcoatNormalScale = new r["Qb"](s, s)
                        }
                        return Promise.all(o)
                    }, c.prototype.getMaterialType = function(t) {
                        var e = this.parser,
                            n = e.json.materials[t];
                        return n.extensions && n.extensions[this.name] ? r["X"] : null
                    }, c.prototype.extendMaterialParams = function(t, e) {
                        var n = this.parser,
                            r = n.json.materials[t];
                        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                        var i = [],
                            o = r.extensions[this.name];
                        return void 0 !== o.transmissionFactor && (e.transmission = o.transmissionFactor), void 0 !== o.transmissionTexture && i.push(n.assignTexture(e, "transmissionMap", o.transmissionTexture)), Promise.all(i)
                    }, l.prototype.loadTexture = function(t) {
                        var e = this.parser,
                            n = e.json,
                            r = n.textures[t];
                        if (!r.extensions || !r.extensions[this.name]) return null;
                        var i = r.extensions[this.name],
                            o = n.images[i.source],
                            a = e.options.ktx2Loader;
                        if (!a) {
                            if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                            return null
                        }
                        return e.loadTextureImage(t, o, a)
                    }, u.prototype.loadTexture = function(t) {
                        var e = this.name,
                            n = this.parser,
                            r = n.json,
                            i = r.textures[t];
                        if (!i.extensions || !i.extensions[e]) return null;
                        var o = i.extensions[e],
                            a = r.images[o.source],
                            s = a.uri ? n.options.manager.getHandler(a.uri) : n.textureLoader;
                        return this.detectSupport().then((function(i) {
                            if (i) return n.loadTextureImage(t, a, s);
                            if (r.extensionsRequired && r.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                            return n.loadTexture(t)
                        }))
                    }, u.prototype.detectSupport = function() {
                        return this.isSupported || (this.isSupported = new Promise((function(t) {
                            var e = new Image;
                            e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function() {
                                t(1 === e.height)
                            }
                        }))), this.isSupported
                    }, h.prototype.loadBufferView = function(t) {
                        var e = this.parser.json,
                            n = e.bufferViews[t];
                        if (n.extensions && n.extensions[this.name]) {
                            var r = n.extensions[this.name],
                                i = this.parser.getDependency("buffer", r.buffer),
                                o = this.parser.options.meshoptDecoder;
                            if (!o || !o.supported) {
                                if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                                return null
                            }
                            return Promise.all([i, o.ready]).then((function(t) {
                                var e = r.byteOffset || 0,
                                    n = r.byteLength || 0,
                                    i = r.count,
                                    a = r.byteStride,
                                    s = new ArrayBuffer(i * a),
                                    c = new Uint8Array(t[0], e, n);
                                return o.decodeGltfBuffer(new Uint8Array(s), i, a, c, r.mode, r.filter), s
                            }))
                        }
                        return null
                    };
                    var d = "glTF",
                        p = 12,
                        f = {
                            JSON: 1313821514,
                            BIN: 5130562
                        };

                    function m(t) {
                        this.name = n.KHR_BINARY_GLTF, this.content = null, this.body = null;
                        var e = new DataView(t, 0, p);
                        if (this.header = {
                                magic: r["N"].decodeText(new Uint8Array(t.slice(0, 4))),
                                version: e.getUint32(4, !0),
                                length: e.getUint32(8, !0)
                            }, this.header.magic !== d) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                        if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                        var i = new DataView(t, p),
                            o = 0;
                        while (o < i.byteLength) {
                            var a = i.getUint32(o, !0);
                            o += 4;
                            var s = i.getUint32(o, !0);
                            if (o += 4, s === f.JSON) {
                                var c = new Uint8Array(t, p + o, a);
                                this.content = r["N"].decodeText(c)
                            } else if (s === f.BIN) {
                                var l = p + o;
                                this.body = t.slice(l, l + a)
                            }
                            o += a
                        }
                        if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
                    }

                    function g(t, e) {
                        if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                        this.name = n.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload()
                    }

                    function v() {
                        this.name = n.KHR_TEXTURE_TRANSFORM
                    }

                    function y(t) {
                        r["Y"].call(this), this.isGLTFSpecularGlossinessMaterial = !0;
                        var e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                            n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                            i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                            o = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                            a = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
                            s = {
                                specular: {
                                    value: (new r["j"]).setHex(16777215)
                                },
                                glossiness: {
                                    value: 1
                                },
                                specularMap: {
                                    value: null
                                },
                                glossinessMap: {
                                    value: null
                                }
                            };
                        this._extraUniforms = s, this.onBeforeCompile = function(t) {
                            for (var r in s) t.uniforms[r] = s[r];
                            t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", o).replace("#include <lights_physical_fragment>", a)
                        }, Object.defineProperties(this, {
                            specular: {
                                get: function() {
                                    return s.specular.value
                                },
                                set: function(t) {
                                    s.specular.value = t
                                }
                            },
                            specularMap: {
                                get: function() {
                                    return s.specularMap.value
                                },
                                set: function(t) {
                                    s.specularMap.value = t, t ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                                }
                            },
                            glossiness: {
                                get: function() {
                                    return s.glossiness.value
                                },
                                set: function(t) {
                                    s.glossiness.value = t
                                }
                            },
                            glossinessMap: {
                                get: function() {
                                    return s.glossinessMap.value
                                },
                                set: function(t) {
                                    s.glossinessMap.value = t, t ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                                }
                            }
                        }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(t)
                    }

                    function _() {
                        return {
                            name: n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                            specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"],
                            getMaterialType: function() {
                                return y
                            },
                            extendParams: function(t, e, n) {
                                var i = e.extensions[this.name];
                                t.color = new r["j"](1, 1, 1), t.opacity = 1;
                                var o = [];
                                if (Array.isArray(i.diffuseFactor)) {
                                    var a = i.diffuseFactor;
                                    t.color.fromArray(a), t.opacity = a[3]
                                }
                                if (void 0 !== i.diffuseTexture && o.push(n.assignTexture(t, "map", i.diffuseTexture)), t.emissive = new r["j"](0, 0, 0), t.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, t.specular = new r["j"](1, 1, 1), Array.isArray(i.specularFactor) && t.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) {
                                    var s = i.specularGlossinessTexture;
                                    o.push(n.assignTexture(t, "glossinessMap", s)), o.push(n.assignTexture(t, "specularMap", s))
                                }
                                return Promise.all(o)
                            },
                            createMaterial: function(t) {
                                var e = new y(t);
                                return e.fog = !0, e.color = t.color, e.map = void 0 === t.map ? null : t.map, e.lightMap = null, e.lightMapIntensity = 1, e.aoMap = void 0 === t.aoMap ? null : t.aoMap, e.aoMapIntensity = 1, e.emissive = t.emissive, e.emissiveIntensity = 1, e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap, e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap, e.bumpScale = 1, e.normalMap = void 0 === t.normalMap ? null : t.normalMap, e.normalMapType = r["Hb"], t.normalScale && (e.normalScale = t.normalScale), e.displacementMap = null, e.displacementScale = 1, e.displacementBias = 0, e.specularMap = void 0 === t.specularMap ? null : t.specularMap, e.specular = t.specular, e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap, e.glossiness = t.glossiness, e.alphaMap = null, e.envMap = void 0 === t.envMap ? null : t.envMap, e.envMapIntensity = 1, e.refractionRatio = .98, e
                            }
                        }
                    }

                    function b() {
                        this.name = n.KHR_MESH_QUANTIZATION
                    }

                    function x(t, e, n, i) {
                        r["C"].call(this, t, e, n, i)
                    }
                    g.prototype.decodePrimitive = function(t, e) {
                        var n = this.json,
                            r = this.dracoLoader,
                            i = t.extensions[this.name].bufferView,
                            o = t.extensions[this.name].attributes,
                            a = {},
                            s = {},
                            c = {};
                        for (var l in o) {
                            var u = A[l] || l.toLowerCase();
                            a[u] = o[l]
                        }
                        for (l in t.attributes) {
                            u = A[l] || l.toLowerCase();
                            if (void 0 !== o[l]) {
                                var h = n.accessors[t.attributes[l]],
                                    d = M[h.componentType];
                                c[u] = d, s[u] = !0 === h.normalized
                            }
                        }
                        return e.getDependency("bufferView", i).then((function(t) {
                            return new Promise((function(e) {
                                r.decodeDracoFile(t, (function(t) {
                                    for (var n in t.attributes) {
                                        var r = t.attributes[n],
                                            i = s[n];
                                        void 0 !== i && (r.normalized = i)
                                    }
                                    e(t)
                                }), a, c)
                            }))
                        }))
                    }, v.prototype.extendTexture = function(t, e) {
                        return t = t.clone(), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), t.needsUpdate = !0, t
                    }, y.prototype = Object.create(r["Y"].prototype), y.prototype.constructor = y, y.prototype.copy = function(t) {
                        return r["Y"].prototype.copy.call(this, t), this.specularMap = t.specularMap, this.specular.copy(t.specular), this.glossinessMap = t.glossinessMap, this.glossiness = t.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
                    }, x.prototype = Object.create(r["C"].prototype), x.prototype.constructor = x, x.prototype.copySampleValue_ = function(t) {
                        for (var e = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = t * r * 3 + r, o = 0; o !== r; o++) e[o] = n[i + o];
                        return e
                    }, x.prototype.beforeStart_ = x.prototype.copySampleValue_, x.prototype.afterEnd_ = x.prototype.copySampleValue_, x.prototype.interpolate_ = function(t, e, n, r) {
                        for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = 2 * a, c = 3 * a, l = r - e, u = (n - e) / l, h = u * u, d = h * u, p = t * c, f = p - c, m = -2 * d + 3 * h, g = d - h, v = 1 - m, y = g - h + u, _ = 0; _ !== a; _++) {
                            var b = o[f + _ + a],
                                x = o[f + _ + s] * l,
                                w = o[p + _ + a],
                                M = o[p + _] * l;
                            i[_] = v * b + y * x + m * w + g * M
                        }
                        return i
                    };
                    var w = {
                            FLOAT: 5126,
                            FLOAT_MAT3: 35675,
                            FLOAT_MAT4: 35676,
                            FLOAT_VEC2: 35664,
                            FLOAT_VEC3: 35665,
                            FLOAT_VEC4: 35666,
                            LINEAR: 9729,
                            REPEAT: 10497,
                            SAMPLER_2D: 35678,
                            POINTS: 0,
                            LINES: 1,
                            LINE_LOOP: 2,
                            LINE_STRIP: 3,
                            TRIANGLES: 4,
                            TRIANGLE_STRIP: 5,
                            TRIANGLE_FAN: 6,
                            UNSIGNED_BYTE: 5121,
                            UNSIGNED_SHORT: 5123
                        },
                        M = {
                            5120: Int8Array,
                            5121: Uint8Array,
                            5122: Int16Array,
                            5123: Uint16Array,
                            5125: Uint32Array,
                            5126: Float32Array
                        },
                        T = {
                            9728: r["ab"],
                            9729: r["J"],
                            9984: r["cb"],
                            9985: r["L"],
                            9986: r["bb"],
                            9987: r["K"]
                        },
                        S = {
                            33071: r["h"],
                            33648: r["Z"],
                            10497: r["xb"]
                        },
                        E = {
                            SCALAR: 1,
                            VEC2: 2,
                            VEC3: 3,
                            VEC4: 4,
                            MAT2: 4,
                            MAT3: 9,
                            MAT4: 16
                        },
                        A = {
                            POSITION: "position",
                            NORMAL: "normal",
                            TANGENT: "tangent",
                            TEXCOORD_0: "uv",
                            TEXCOORD_1: "uv2",
                            COLOR_0: "color",
                            WEIGHTS_0: "skinWeight",
                            JOINTS_0: "skinIndex"
                        },
                        L = {
                            scale: "scale",
                            translation: "position",
                            rotation: "quaternion",
                            weights: "morphTargetInfluences"
                        },
                        R = {
                            CUBICSPLINE: void 0,
                            LINEAR: r["E"],
                            STEP: r["D"]
                        },
                        C = {
                            OPAQUE: "OPAQUE",
                            MASK: "MASK",
                            BLEND: "BLEND"
                        };

                    function O(t, e) {
                        return "string" !== typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
                    }

                    function P(t) {
                        return void 0 === t["DefaultMaterial"] && (t["DefaultMaterial"] = new r["Y"]({
                            color: 16777215,
                            emissive: 0,
                            metalness: 1,
                            roughness: 1,
                            transparent: !1,
                            depthTest: !0,
                            side: r["w"]
                        })), t["DefaultMaterial"]
                    }

                    function I(t, e, n) {
                        for (var r in n.extensions) void 0 === t[r] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[r] = n.extensions[r])
                    }

                    function N(t, e) {
                        void 0 !== e.extras && ("object" === typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
                    }

                    function D(t, e, n) {
                        for (var r = !1, i = !1, o = 0, a = e.length; o < a; o++) {
                            var s = e[o];
                            if (void 0 !== s.POSITION && (r = !0), void 0 !== s.NORMAL && (i = !0), r && i) break
                        }
                        if (!r && !i) return Promise.resolve(t);
                        var c = [],
                            l = [];
                        for (o = 0, a = e.length; o < a; o++) {
                            s = e[o];
                            if (r) {
                                var u = void 0 !== s.POSITION ? n.getDependency("accessor", s.POSITION) : t.attributes.position;
                                c.push(u)
                            }
                            if (i) {
                                u = void 0 !== s.NORMAL ? n.getDependency("accessor", s.NORMAL) : t.attributes.normal;
                                l.push(u)
                            }
                        }
                        return Promise.all([Promise.all(c), Promise.all(l)]).then((function(e) {
                            var n = e[0],
                                o = e[1];
                            return r && (t.morphAttributes.position = n), i && (t.morphAttributes.normal = o), t.morphTargetsRelative = !0, t
                        }))
                    }

                    function k(t, e) {
                        if (t.updateMorphTargets(), void 0 !== e.weights)
                            for (var n = 0, r = e.weights.length; n < r; n++) t.morphTargetInfluences[n] = e.weights[n];
                        if (e.extras && Array.isArray(e.extras.targetNames)) {
                            var i = e.extras.targetNames;
                            if (t.morphTargetInfluences.length === i.length) {
                                t.morphTargetDictionary = {};
                                for (n = 0, r = i.length; n < r; n++) t.morphTargetDictionary[i[n]] = n
                            } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
                        }
                    }

                    function F(t) {
                        var e, r = t.extensions && t.extensions[n.KHR_DRACO_MESH_COMPRESSION];
                        return e = r ? "draco:" + r.bufferView + ":" + r.indices + ":" + B(r.attributes) : t.indices + ":" + B(t.attributes) + ":" + t.mode, e
                    }

                    function B(t) {
                        for (var e = "", n = Object.keys(t).sort(), r = 0, i = n.length; r < i; r++) e += n[r] + ":" + t[n[r]] + ";";
                        return e
                    }

                    function U(t, n) {
                        this.json = t || {}, this.extensions = {}, this.plugins = {}, this.options = n || {}, this.cache = new e, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
                            refs: {},
                            uses: {}
                        }, this.cameraCache = {
                            refs: {},
                            uses: {}
                        }, this.lightCache = {
                            refs: {},
                            uses: {}
                        }, this.nodeNamesUsed = {}, "undefined" !== typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new r["y"](this.options.manager) : this.textureLoader = new r["Jb"](this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.fileLoader = new r["t"](this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
                    }

                    function H(t, e, n) {
                        var i = e.attributes,
                            o = new r["d"];
                        if (void 0 !== i.POSITION) {
                            var a = n.json.accessors[i.POSITION],
                                s = a.min,
                                c = a.max;
                            if (void 0 !== s && void 0 !== c) {
                                o.set(new r["Rb"](s[0], s[1], s[2]), new r["Rb"](c[0], c[1], c[2]));
                                var l = e.targets;
                                if (void 0 !== l) {
                                    for (var u = new r["Rb"], h = new r["Rb"], d = 0, p = l.length; d < p; d++) {
                                        var f = l[d];
                                        if (void 0 !== f.POSITION) {
                                            a = n.json.accessors[f.POSITION], s = a.min, c = a.max;
                                            void 0 !== s && void 0 !== c ? (h.setX(Math.max(Math.abs(s[0]), Math.abs(c[0]))), h.setY(Math.max(Math.abs(s[1]), Math.abs(c[1]))), h.setZ(Math.max(Math.abs(s[2]), Math.abs(c[2]))), u.max(h)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                                        }
                                    }
                                    o.expandByVector(u)
                                }
                                t.boundingBox = o;
                                var m = new r["Cb"];
                                o.getCenter(m.center), m.radius = o.min.distanceTo(o.max) / 2, t.boundingSphere = m
                            } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                        }
                    }

                    function z(t, e, n) {
                        var r = e.attributes,
                            i = [];

                        function o(e, r) {
                            return n.getDependency("accessor", e).then((function(e) {
                                t.setAttribute(r, e)
                            }))
                        }
                        for (var a in r) {
                            var s = A[a] || a.toLowerCase();
                            s in t.attributes || i.push(o(r[a], s))
                        }
                        if (void 0 !== e.indices && !t.index) {
                            var c = n.getDependency("accessor", e.indices).then((function(e) {
                                t.setIndex(e)
                            }));
                            i.push(c)
                        }
                        return N(t, e), H(t, e, n), Promise.all(i).then((function() {
                            return void 0 !== e.targets ? D(t, e.targets, n) : t
                        }))
                    }

                    function j(t, e) {
                        var n = t.getIndex();
                        if (null === n) {
                            var i = [],
                                o = t.getAttribute("position");
                            if (void 0 === o) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t;
                            for (var a = 0; a < o.count; a++) i.push(a);
                            t.setIndex(i), n = t.getIndex()
                        }
                        var s = n.count - 2,
                            c = [];
                        if (e === r["Kb"])
                            for (a = 1; a <= s; a++) c.push(n.getX(0)), c.push(n.getX(a)), c.push(n.getX(a + 1));
                        else
                            for (a = 0; a < s; a++) a % 2 === 0 ? (c.push(n.getX(a)), c.push(n.getX(a + 1)), c.push(n.getX(a + 2))) : (c.push(n.getX(a + 2)), c.push(n.getX(a + 1)), c.push(n.getX(a)));
                        c.length / 3 !== s && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                        var l = t.clone();
                        return l.setIndex(c), l
                    }
                    return U.prototype.setExtensions = function(t) {
                        this.extensions = t
                    }, U.prototype.setPlugins = function(t) {
                        this.plugins = t
                    }, U.prototype.parse = function(t, e) {
                        var n = this,
                            r = this.json,
                            i = this.extensions;
                        this.cache.removeAll(), this._invokeAll((function(t) {
                            return t._markDefs && t._markDefs()
                        })), Promise.all([this.getDependencies("scene"), this.getDependencies("animation"), this.getDependencies("camera")]).then((function(e) {
                            var o = {
                                scene: e[0][r.scene || 0],
                                scenes: e[0],
                                animations: e[1],
                                cameras: e[2],
                                asset: r.asset,
                                parser: n,
                                userData: {}
                            };
                            I(i, o, r), N(o, r), t(o)
                        })).catch(e)
                    }, U.prototype._markDefs = function() {
                        for (var t = this.json.nodes || [], e = this.json.skins || [], n = this.json.meshes || [], r = 0, i = e.length; r < i; r++)
                            for (var o = e[r].joints, a = 0, s = o.length; a < s; a++) t[o[a]].isBone = !0;
                        for (var c = 0, l = t.length; c < l; c++) {
                            var u = t[c];
                            void 0 !== u.mesh && (this._addNodeRef(this.meshCache, u.mesh), void 0 !== u.skin && (n[u.mesh].isSkinnedMesh = !0)), void 0 !== u.camera && this._addNodeRef(this.cameraCache, u.camera)
                        }
                    }, U.prototype._addNodeRef = function(t, e) {
                        void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++)
                    }, U.prototype._getNodeRef = function(t, e, n) {
                        if (t.refs[e] <= 1) return n;
                        var r = n.clone();
                        return r.name += "_instance_" + t.uses[e]++, r
                    }, U.prototype._invokeOne = function(t) {
                        var e = Object.values(this.plugins);
                        e.push(this);
                        for (var n = 0; n < e.length; n++) {
                            var r = t(e[n]);
                            if (r) return r
                        }
                    }, U.prototype._invokeAll = function(t) {
                        var e = Object.values(this.plugins);
                        e.unshift(this);
                        for (var n = [], r = 0; r < e.length; r++) {
                            var i = t(e[r]);
                            i && n.push(i)
                        }
                        return n
                    }, U.prototype.getDependency = function(t, e) {
                        var n = t + ":" + e,
                            r = this.cache.get(n);
                        if (!r) {
                            switch (t) {
                                case "scene":
                                    r = this.loadScene(e);
                                    break;
                                case "node":
                                    r = this.loadNode(e);
                                    break;
                                case "mesh":
                                    r = this._invokeOne((function(t) {
                                        return t.loadMesh && t.loadMesh(e)
                                    }));
                                    break;
                                case "accessor":
                                    r = this.loadAccessor(e);
                                    break;
                                case "bufferView":
                                    r = this._invokeOne((function(t) {
                                        return t.loadBufferView && t.loadBufferView(e)
                                    }));
                                    break;
                                case "buffer":
                                    r = this.loadBuffer(e);
                                    break;
                                case "material":
                                    r = this._invokeOne((function(t) {
                                        return t.loadMaterial && t.loadMaterial(e)
                                    }));
                                    break;
                                case "texture":
                                    r = this._invokeOne((function(t) {
                                        return t.loadTexture && t.loadTexture(e)
                                    }));
                                    break;
                                case "skin":
                                    r = this.loadSkin(e);
                                    break;
                                case "animation":
                                    r = this.loadAnimation(e);
                                    break;
                                case "camera":
                                    r = this.loadCamera(e);
                                    break;
                                default:
                                    throw new Error("Unknown type: " + t)
                            }
                            this.cache.add(n, r)
                        }
                        return r
                    }, U.prototype.getDependencies = function(t) {
                        var e = this.cache.get(t);
                        if (!e) {
                            var n = this,
                                r = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                            e = Promise.all(r.map((function(e, r) {
                                return n.getDependency(t, r)
                            }))), this.cache.add(t, e)
                        }
                        return e
                    }, U.prototype.loadBuffer = function(t) {
                        var e = this.json.buffers[t],
                            r = this.fileLoader;
                        if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
                        if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[n.KHR_BINARY_GLTF].body);
                        var i = this.options;
                        return new Promise((function(t, n) {
                            r.load(O(e.uri, i.path), t, void 0, (function() {
                                n(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
                            }))
                        }))
                    }, U.prototype.loadBufferView = function(t) {
                        var e = this.json.bufferViews[t];
                        return this.getDependency("buffer", e.buffer).then((function(t) {
                            var n = e.byteLength || 0,
                                r = e.byteOffset || 0;
                            return t.slice(r, r + n)
                        }))
                    }, U.prototype.loadAccessor = function(t) {
                        var e = this,
                            n = this.json,
                            i = this.json.accessors[t];
                        if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null);
                        var o = [];
                        return void 0 !== i.bufferView ? o.push(this.getDependency("bufferView", i.bufferView)) : o.push(null), void 0 !== i.sparse && (o.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), o.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(o).then((function(t) {
                            var o, a, s = t[0],
                                c = E[i.type],
                                l = M[i.componentType],
                                u = l.BYTES_PER_ELEMENT,
                                h = u * c,
                                d = i.byteOffset || 0,
                                p = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                                f = !0 === i.normalized;
                            if (p && p !== h) {
                                var m = Math.floor(d / p),
                                    g = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + m + ":" + i.count,
                                    v = e.cache.get(g);
                                v || (o = new l(s, m * p, i.count * p / u), v = new r["A"](o, p / u), e.cache.add(g, v)), a = new r["B"](v, c, d % p / u, f)
                            } else o = null === s ? new l(i.count * c) : new l(s, d, i.count * c), a = new r["e"](o, c, f);
                            if (void 0 !== i.sparse) {
                                var y = E.SCALAR,
                                    _ = M[i.sparse.indices.componentType],
                                    b = i.sparse.indices.byteOffset || 0,
                                    x = i.sparse.values.byteOffset || 0,
                                    w = new _(t[1], b, i.sparse.count * y),
                                    T = new l(t[2], x, i.sparse.count * c);
                                null !== s && (a = new r["e"](a.array.slice(), a.itemSize, a.normalized));
                                for (var S = 0, A = w.length; S < A; S++) {
                                    var L = w[S];
                                    if (a.setX(L, T[S * c]), c >= 2 && a.setY(L, T[S * c + 1]), c >= 3 && a.setZ(L, T[S * c + 2]), c >= 4 && a.setW(L, T[S * c + 3]), c >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                                }
                            }
                            return a
                        }))
                    }, U.prototype.loadTexture = function(t) {
                        var e, r, i = this,
                            o = this.json,
                            a = this.options,
                            s = o.textures[t],
                            c = s.extensions || {};
                        return e = c[n.MSFT_TEXTURE_DDS] ? o.images[c[n.MSFT_TEXTURE_DDS].source] : o.images[s.source], e.uri && (r = a.manager.getHandler(e.uri)), r || (r = c[n.MSFT_TEXTURE_DDS] ? i.extensions[n.MSFT_TEXTURE_DDS].ddsLoader : this.textureLoader), this.loadTextureImage(t, e, r)
                    }, U.prototype.loadTextureImage = function(t, e, n) {
                        var i = this,
                            o = this.json,
                            a = this.options,
                            s = o.textures[t],
                            c = self.URL || self.webkitURL,
                            l = e.uri,
                            u = !1,
                            h = !0;
                        return "image/jpeg" === e.mimeType && (h = !1), void 0 !== e.bufferView && (l = i.getDependency("bufferView", e.bufferView).then((function(t) {
                            if ("image/png" === e.mimeType) {
                                var n = new DataView(t, 25, 1).getUint8(0, !1);
                                h = 6 === n || 4 === n || 3 === n
                            }
                            u = !0;
                            var r = new Blob([t], {
                                type: e.mimeType
                            });
                            return l = c.createObjectURL(r), l
                        }))), Promise.resolve(l).then((function(t) {
                            return new Promise((function(e, i) {
                                var o = e;
                                !0 === n.isImageBitmapLoader && (o = function(t) {
                                    e(new r["g"](t))
                                }), n.load(O(t, a.path), o, void 0, i)
                            }))
                        })).then((function(e) {
                            !0 === u && c.revokeObjectURL(l), e.flipY = !1, s.name && (e.name = s.name), h || (e.format = r["tb"]);
                            var n = o.samplers || {},
                                a = n[s.sampler] || {};
                            return e.magFilter = T[a.magFilter] || r["J"], e.minFilter = T[a.minFilter] || r["K"], e.wrapS = S[a.wrapS] || r["xb"], e.wrapT = S[a.wrapT] || r["xb"], i.associations.set(e, {
                                type: "textures",
                                index: t
                            }), e
                        }))
                    }, U.prototype.assignTexture = function(t, e, r) {
                        var i = this;
                        return this.getDependency("texture", r.index).then((function(o) {
                            if (void 0 === r.texCoord || 0 == r.texCoord || "aoMap" === e && 1 == r.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + r.texCoord + " for texture " + e + " not yet supported."), i.extensions[n.KHR_TEXTURE_TRANSFORM]) {
                                var a = void 0 !== r.extensions ? r.extensions[n.KHR_TEXTURE_TRANSFORM] : void 0;
                                if (a) {
                                    var s = i.associations.get(o);
                                    o = i.extensions[n.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), i.associations.set(o, s)
                                }
                            }
                            t[e] = o
                        }))
                    }, U.prototype.assignFinalMaterial = function(t) {
                        var e = t.geometry,
                            n = t.material,
                            i = void 0 !== e.attributes.tangent,
                            o = void 0 !== e.attributes.color,
                            a = void 0 === e.attributes.normal,
                            s = !0 === t.isSkinnedMesh,
                            c = Object.keys(e.morphAttributes).length > 0,
                            l = c && void 0 !== e.morphAttributes.normal;
                        if (t.isPoints) {
                            var u = "PointsMaterial:" + n.uuid,
                                h = this.cache.get(u);
                            h || (h = new r["nb"], r["P"].prototype.copy.call(h, n), h.color.copy(n.color), h.map = n.map, h.sizeAttenuation = !1, this.cache.add(u, h)), n = h
                        } else if (t.isLine) {
                            u = "LineBasicMaterial:" + n.uuid;
                            var d = this.cache.get(u);
                            d || (d = new r["G"], r["P"].prototype.copy.call(d, n), d.color.copy(n.color), this.cache.add(u, d)), n = d
                        }
                        if (i || o || a || s || c) {
                            u = "ClonedMaterial:" + n.uuid + ":";
                            n.isGLTFSpecularGlossinessMaterial && (u += "specular-glossiness:"), s && (u += "skinning:"), i && (u += "vertex-tangents:"), o && (u += "vertex-colors:"), a && (u += "flat-shading:"), c && (u += "morph-targets:"), l && (u += "morph-normals:");
                            var p = this.cache.get(u);
                            p || (p = n.clone(), s && (p.skinning = !0), i && (p.vertexTangents = !0), o && (p.vertexColors = !0), a && (p.flatShading = !0), c && (p.morphTargets = !0), l && (p.morphNormals = !0), this.cache.add(u, p), this.associations.set(p, this.associations.get(n))), n = p
                        }
                        n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv), n.normalScale && !i && (n.normalScale.y = -n.normalScale.y), n.clearcoatNormalScale && !i && (n.clearcoatNormalScale.y = -n.clearcoatNormalScale.y), t.material = n
                    }, U.prototype.getMaterialType = function() {
                        return r["Y"]
                    }, U.prototype.loadMaterial = function(t) {
                        var e, i = this,
                            o = this.json,
                            a = this.extensions,
                            s = o.materials[t],
                            c = {},
                            l = s.extensions || {},
                            u = [];
                        if (l[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                            var h = a[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                            e = h.getMaterialType(), u.push(h.extendParams(c, s, i))
                        } else if (l[n.KHR_MATERIALS_UNLIT]) {
                            var d = a[n.KHR_MATERIALS_UNLIT];
                            e = d.getMaterialType(), u.push(d.extendParams(c, s, i))
                        } else {
                            var p = s.pbrMetallicRoughness || {};
                            if (c.color = new r["j"](1, 1, 1), c.opacity = 1, Array.isArray(p.baseColorFactor)) {
                                var f = p.baseColorFactor;
                                c.color.fromArray(f), c.opacity = f[3]
                            }
                            void 0 !== p.baseColorTexture && u.push(i.assignTexture(c, "map", p.baseColorTexture)), c.metalness = void 0 !== p.metallicFactor ? p.metallicFactor : 1, c.roughness = void 0 !== p.roughnessFactor ? p.roughnessFactor : 1, void 0 !== p.metallicRoughnessTexture && (u.push(i.assignTexture(c, "metalnessMap", p.metallicRoughnessTexture)), u.push(i.assignTexture(c, "roughnessMap", p.metallicRoughnessTexture))), e = this._invokeOne((function(e) {
                                return e.getMaterialType && e.getMaterialType(t)
                            })), u.push(Promise.all(this._invokeAll((function(e) {
                                return e.extendMaterialParams && e.extendMaterialParams(t, c)
                            }))))
                        }!0 === s.doubleSided && (c.side = r["o"]);
                        var m = s.alphaMode || C.OPAQUE;
                        return m === C.BLEND ? (c.transparent = !0, c.depthWrite = !1) : (c.transparent = !1, m === C.MASK && (c.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : .5)), void 0 !== s.normalTexture && e !== r["U"] && (u.push(i.assignTexture(c, "normalMap", s.normalTexture)), c.normalScale = new r["Qb"](1, 1), void 0 !== s.normalTexture.scale && c.normalScale.set(s.normalTexture.scale, s.normalTexture.scale)), void 0 !== s.occlusionTexture && e !== r["U"] && (u.push(i.assignTexture(c, "aoMap", s.occlusionTexture)), void 0 !== s.occlusionTexture.strength && (c.aoMapIntensity = s.occlusionTexture.strength)), void 0 !== s.emissiveFactor && e !== r["U"] && (c.emissive = (new r["j"]).fromArray(s.emissiveFactor)), void 0 !== s.emissiveTexture && e !== r["U"] && u.push(i.assignTexture(c, "emissiveMap", s.emissiveTexture)), Promise.all(u).then((function() {
                            var o;
                            return o = e === y ? a[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(c) : new e(c), s.name && (o.name = s.name), o.map && (o.map.encoding = r["Wb"]), o.emissiveMap && (o.emissiveMap.encoding = r["Wb"]), N(o, s), i.associations.set(o, {
                                type: "materials",
                                index: t
                            }), s.extensions && I(a, o, s), o
                        }))
                    }, U.prototype.createUniqueName = function(t) {
                        for (var e = r["ob"].sanitizeNodeName(t || ""), n = 1; this.nodeNamesUsed[e]; ++n) e = t + "_" + n;
                        return this.nodeNamesUsed[e] = !0, e
                    }, U.prototype.loadGeometries = function(t) {
                        var e = this,
                            i = this.extensions,
                            o = this.primitiveCache;

                        function a(t) {
                            return i[n.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function(n) {
                                return z(n, t, e)
                            }))
                        }
                        for (var s = [], c = 0, l = t.length; c < l; c++) {
                            var u, h = t[c],
                                d = F(h),
                                p = o[d];
                            if (p) s.push(p.promise);
                            else u = h.extensions && h.extensions[n.KHR_DRACO_MESH_COMPRESSION] ? a(h) : z(new r["f"], h, e), o[d] = {
                                primitive: h,
                                promise: u
                            }, s.push(u)
                        }
                        return Promise.all(s)
                    }, U.prototype.loadMesh = function(t) {
                        for (var e = this, n = this.json, i = n.meshes[t], o = i.primitives, a = [], s = 0, c = o.length; s < c; s++) {
                            var l = void 0 === o[s].material ? P(this.cache) : this.getDependency("material", o[s].material);
                            a.push(l)
                        }
                        return a.push(e.loadGeometries(o)), Promise.all(a).then((function(n) {
                            for (var a = n.slice(0, n.length - 1), s = n[n.length - 1], c = [], l = 0, u = s.length; l < u; l++) {
                                var h, d = s[l],
                                    p = o[l],
                                    f = a[l];
                                if (p.mode === w.TRIANGLES || p.mode === w.TRIANGLE_STRIP || p.mode === w.TRIANGLE_FAN || void 0 === p.mode) h = !0 === i.isSkinnedMesh ? new r["Bb"](d, f) : new r["T"](d, f), !0 !== h.isSkinnedMesh || h.geometry.attributes.skinWeight.normalized || h.normalizeSkinWeights(), p.mode === w.TRIANGLE_STRIP ? h.geometry = j(h.geometry, r["Lb"]) : p.mode === w.TRIANGLE_FAN && (h.geometry = j(h.geometry, r["Kb"]));
                                else if (p.mode === w.LINES) h = new r["I"](d, f);
                                else if (p.mode === w.LINE_STRIP) h = new r["F"](d, f);
                                else if (p.mode === w.LINE_LOOP) h = new r["H"](d, f);
                                else {
                                    if (p.mode !== w.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p.mode);
                                    h = new r["mb"](d, f)
                                }
                                Object.keys(h.geometry.morphAttributes).length > 0 && k(h, i), h.name = e.createUniqueName(i.name || "mesh_" + t), N(h, i), e.assignFinalMaterial(h), c.push(h)
                            }
                            if (1 === c.length) return c[0];
                            var m = new r["x"];
                            for (l = 0, u = c.length; l < u; l++) m.add(c[l]);
                            return m
                        }))
                    }, U.prototype.loadCamera = function(t) {
                        var e, n = this.json.cameras[t],
                            i = n[n.type];
                        if (i) return "perspective" === n.type ? e = new r["ib"](r["Q"].radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (e = new r["gb"](-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (e.name = this.createUniqueName(n.name)), N(e, n), Promise.resolve(e);
                        console.warn("THREE.GLTFLoader: Missing camera parameters.")
                    }, U.prototype.loadSkin = function(t) {
                        var e = this.json.skins[t],
                            n = {
                                joints: e.joints
                            };
                        return void 0 === e.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", e.inverseBindMatrices).then((function(t) {
                            return n.inverseBindMatrices = t, n
                        }))
                    }, U.prototype.loadAnimation = function(t) {
                        for (var e = this.json, n = e.animations[t], i = [], o = [], a = [], s = [], c = [], l = 0, u = n.channels.length; l < u; l++) {
                            var h = n.channels[l],
                                d = n.samplers[h.sampler],
                                p = h.target,
                                f = void 0 !== p.node ? p.node : p.id,
                                m = void 0 !== n.parameters ? n.parameters[d.input] : d.input,
                                g = void 0 !== n.parameters ? n.parameters[d.output] : d.output;
                            i.push(this.getDependency("node", f)), o.push(this.getDependency("accessor", m)), a.push(this.getDependency("accessor", g)), s.push(d), c.push(p)
                        }
                        return Promise.all([Promise.all(i), Promise.all(o), Promise.all(a), Promise.all(s), Promise.all(c)]).then((function(e) {
                            for (var i = e[0], o = e[1], a = e[2], s = e[3], c = e[4], l = [], u = 0, h = i.length; u < h; u++) {
                                var d = i[u],
                                    p = o[u],
                                    f = a[u],
                                    m = s[u],
                                    g = c[u];
                                if (void 0 !== d) {
                                    var v;
                                    switch (d.updateMatrix(), d.matrixAutoUpdate = !0, L[g.path]) {
                                        case L.weights:
                                            v = r["eb"];
                                            break;
                                        case L.rotation:
                                            v = r["qb"];
                                            break;
                                        case L.position:
                                        case L.scale:
                                        default:
                                            v = r["Tb"];
                                            break
                                    }
                                    var y = d.name ? d.name : d.uuid,
                                        _ = void 0 !== m.interpolation ? R[m.interpolation] : r["E"],
                                        b = [];
                                    L[g.path] === L.weights ? d.traverse((function(t) {
                                        !0 === t.isMesh && t.morphTargetInfluences && b.push(t.name ? t.name : t.uuid)
                                    })) : b.push(y);
                                    var w = f.array;
                                    if (f.normalized) {
                                        var M;
                                        if (w.constructor === Int8Array) M = 1 / 127;
                                        else if (w.constructor === Uint8Array) M = 1 / 255;
                                        else if (w.constructor == Int16Array) M = 1 / 32767;
                                        else {
                                            if (w.constructor !== Uint16Array) throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
                                            M = 1 / 65535
                                        }
                                        for (var T = new Float32Array(w.length), S = 0, E = w.length; S < E; S++) T[S] = w[S] * M;
                                        w = T
                                    }
                                    for (S = 0, E = b.length; S < E; S++) {
                                        var A = new v(b[S] + "." + L[g.path], p.array, w, _);
                                        "CUBICSPLINE" === m.interpolation && (A.createInterpolant = function(t) {
                                            return new x(this.times, this.values, this.getValueSize() / 3, t)
                                        }, A.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(A)
                                    }
                                }
                            }
                            var C = n.name ? n.name : "animation_" + t;
                            return new r["b"](C, void 0, l)
                        }))
                    }, U.prototype.loadNode = function(t) {
                        var e = this.json,
                            n = this.extensions,
                            i = this,
                            o = e.nodes[t],
                            a = o.name ? i.createUniqueName(o.name) : "";
                        return function() {
                            var e = [];
                            return void 0 !== o.mesh && e.push(i.getDependency("mesh", o.mesh).then((function(t) {
                                var e = i._getNodeRef(i.meshCache, o.mesh, t);
                                return void 0 !== o.weights && e.traverse((function(t) {
                                    if (t.isMesh)
                                        for (var e = 0, n = o.weights.length; e < n; e++) t.morphTargetInfluences[e] = o.weights[e]
                                })), e
                            }))), void 0 !== o.camera && e.push(i.getDependency("camera", o.camera).then((function(t) {
                                return i._getNodeRef(i.cameraCache, o.camera, t)
                            }))), i._invokeAll((function(e) {
                                return e.createNodeAttachment && e.createNodeAttachment(t)
                            })).forEach((function(t) {
                                e.push(t)
                            })), Promise.all(e)
                        }().then((function(e) {
                            var s;
                            if (s = !0 === o.isBone ? new r["c"] : e.length > 1 ? new r["x"] : 1 === e.length ? e[0] : new r["fb"], s !== e[0])
                                for (var c = 0, l = e.length; c < l; c++) s.add(e[c]);
                            if (o.name && (s.userData.name = o.name, s.name = a), N(s, o), o.extensions && I(n, s, o), void 0 !== o.matrix) {
                                var u = new r["S"];
                                u.fromArray(o.matrix), s.applyMatrix4(u)
                            } else void 0 !== o.translation && s.position.fromArray(o.translation), void 0 !== o.rotation && s.quaternion.fromArray(o.rotation), void 0 !== o.scale && s.scale.fromArray(o.scale);
                            return i.associations.set(s, {
                                type: "nodes",
                                index: t
                            }), s
                        }))
                    }, U.prototype.loadScene = function() {
                        function t(e, n, i, o) {
                            var a = i.nodes[e];
                            return o.getDependency("node", e).then((function(t) {
                                return void 0 === a.skin ? t : o.getDependency("skin", a.skin).then((function(t) {
                                    e = t;
                                    for (var n = [], r = 0, i = e.joints.length; r < i; r++) n.push(o.getDependency("node", e.joints[r]));
                                    return Promise.all(n)
                                })).then((function(n) {
                                    return t.traverse((function(t) {
                                        if (t.isMesh) {
                                            for (var i = [], o = [], a = 0, s = n.length; a < s; a++) {
                                                var c = n[a];
                                                if (c) {
                                                    i.push(c);
                                                    var l = new r["S"];
                                                    void 0 !== e.inverseBindMatrices && l.fromArray(e.inverseBindMatrices.array, 16 * a), o.push(l)
                                                } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[a])
                                            }
                                            t.bind(new r["Ab"](i, o), t.matrixWorld)
                                        }
                                    })), t
                                }));
                                var e
                            })).then((function(e) {
                                n.add(e);
                                var r = [];
                                if (a.children)
                                    for (var s = a.children, c = 0, l = s.length; c < l; c++) {
                                        var u = s[c];
                                        r.push(t(u, e, i, o))
                                    }
                                return Promise.all(r)
                            }))
                        }
                        return function(e) {
                            var n = this.json,
                                i = this.extensions,
                                o = this.json.scenes[e],
                                a = this,
                                s = new r["x"];
                            o.name && (s.name = a.createUniqueName(o.name)), N(s, o), o.extensions && I(i, s, o);
                            for (var c = o.nodes || [], l = [], u = 0, h = c.length; u < h; u++) l.push(t(c[u], s, n, a));
                            return Promise.all(l).then((function() {
                                return s
                            }))
                        }
                    }(), t
                }()
        },
        "35a1": function(t, e, n) {
            var r = n("f5df"),
                i = n("3f8c"),
                o = n("b622"),
                a = o("iterator");
            t.exports = function(t) {
                if (void 0 != t) return t[a] || t["@@iterator"] || i[r(t)]
            }
        },
        "360d": function(t, e, n) {
            "use strict";
            n.d(e, "a", (function() {
                return o
            }));
            var r = n("5a89"),
                i = n("1b53"),
                o = function(t, e) {
                    i["a"].call(this), this.textureID = void 0 !== e ? e : "tDiffuse", t instanceof r["zb"] ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = r["Pb"].clone(t.uniforms), this.material = new r["zb"]({
                        defines: Object.assign({}, t.defines),
                        uniforms: this.uniforms,
                        vertexShader: t.vertexShader,
                        fragmentShader: t.fragmentShader
                    })), this.fsQuad = new i["a"].FullScreenQuad(this.material)
                };
            o.prototype = Object.assign(Object.create(i["a"].prototype), {
                constructor: o,
                render: function(t, e, n) {
                    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t))
                }
            })
        },
        "37e8": function(t, e, n) {
            var r = n("83ab"),
                i = n("9bf2"),
                o = n("825a"),
                a = n("df75");
            t.exports = r ? Object.defineProperties : function(t, e) {
                o(t);
                var n, r = a(e),
                    s = r.length,
                    c = 0;
                while (s > c) i.f(t, n = r[c++], e[n]);
                return t
            }
        },
        "3a7b": function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("b727").findIndex,
                o = r.aTypedArray,
                a = r.exportTypedArrayMethod;
            a("findIndex", (function(t) {
                return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0)
            }))
        },
        "3bbe": function(t, e, n) {
            var r = n("861d");
            t.exports = function(t) {
                if (!r(t) && null !== t) throw TypeError("Can't set " + String(t) + " as a prototype");
                return t
            }
        },
        "3c5d": function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("50c4"),
                o = n("182d"),
                a = n("7b0b"),
                s = n("d039"),
                c = r.aTypedArray,
                l = r.exportTypedArrayMethod,
                u = s((function() {
                    new Int8Array(1).set({})
                }));
            l("set", (function(t) {
                c(this);
                var e = o(arguments.length > 1 ? arguments[1] : void 0, 1),
                    n = this.length,
                    r = a(t),
                    s = i(r.length),
                    l = 0;
                if (s + e > n) throw RangeError("Wrong length");
                while (l < s) this[e + l] = r[l++]
            }), u)
        },
        "3ca3": function(t, e, n) {
            "use strict";
            var r = n("6547").charAt,
                i = n("69f3"),
                o = n("7dd0"),
                a = "String Iterator",
                s = i.set,
                c = i.getterFor(a);
            o(String, "String", (function(t) {
                s(this, {
                    type: a,
                    string: String(t),
                    index: 0
                })
            }), (function() {
                var t, e = c(this),
                    n = e.string,
                    i = e.index;
                return i >= n.length ? {
                    value: void 0,
                    done: !0
                } : (t = r(n, i), e.index += t.length, {
                    value: t,
                    done: !1
                })
            }))
        },
        "3f8c": function(t, e) {
            t.exports = {}
        },
        "3fcc": function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("b727").map,
                o = n("4840"),
                a = r.aTypedArray,
                s = r.aTypedArrayConstructor,
                c = r.exportTypedArrayMethod;
            c("map", (function(t) {
                return i(a(this), t, arguments.length > 1 ? arguments[1] : void 0, (function(t, e) {
                    return new(s(o(t, t.constructor)))(e)
                }))
            }))
        },
        4057: function(t, e, n) {
            var r = n("23e7"),
                i = Math.hypot,
                o = Math.abs,
                a = Math.sqrt,
                s = !!i && i(1 / 0, NaN) !== 1 / 0;
            r({
                target: "Math",
                stat: !0,
                forced: s
            }, {
                hypot: function(t, e) {
                    var n, r, i = 0,
                        s = 0,
                        c = arguments.length,
                        l = 0;
                    while (s < c) n = o(arguments[s++]), l < n ? (r = l / n, i = i * r * r + 1, l = n) : n > 0 ? (r = n / l, i += r * r) : i += n;
                    return l === 1 / 0 ? 1 / 0 : l * a(i)
                }
            })
        },
        "408a": function(t, e, n) {
            var r = n("c6b6");
            t.exports = function(t) {
                if ("number" != typeof t && "Number" != r(t)) throw TypeError("Incorrect invocation");
                return +t
            }
        },
        4160: function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("17c2");
            r({
                target: "Array",
                proto: !0,
                forced: [].forEach != i
            }, {
                forEach: i
            })
        },
        "428f": function(t, e, n) {
            var r = n("da84");
            t.exports = r
        },
        "44ad": function(t, e, n) {
            var r = n("d039"),
                i = n("c6b6"),
                o = "".split;
            t.exports = r((function() {
                return !Object("z").propertyIsEnumerable(0)
            })) ? function(t) {
                return "String" == i(t) ? o.call(t, "") : Object(t)
            } : Object
        },
        "44d2": function(t, e, n) {
            var r = n("b622"),
                i = n("7c73"),
                o = n("9bf2"),
                a = r("unscopables"),
                s = Array.prototype;
            void 0 == s[a] && o.f(s, a, {
                configurable: !0,
                value: i(null)
            }), t.exports = function(t) {
                s[a][t] = !0
            }
        },
        "44de": function(t, e, n) {
            var r = n("da84");
            t.exports = function(t, e) {
                var n = r.console;
                n && n.error && (1 === arguments.length ? n.error(t) : n.error(t, e))
            }
        },
        "44e7": function(t, e, n) {
            var r = n("861d"),
                i = n("c6b6"),
                o = n("b622"),
                a = o("match");
            t.exports = function(t) {
                var e;
                return r(t) && (void 0 !== (e = t[a]) ? !!e : "RegExp" == i(t))
            }
        },
        "466d": function(t, e, n) {
            "use strict";
            var r = n("d784"),
                i = n("825a"),
                o = n("50c4"),
                a = n("1d80"),
                s = n("8aa5"),
                c = n("14c3");
            r("match", 1, (function(t, e, n) {
                return [function(e) {
                    var n = a(this),
                        r = void 0 == e ? void 0 : e[t];
                    return void 0 !== r ? r.call(e, n) : new RegExp(e)[t](String(n))
                }, function(t) {
                    var r = n(e, t, this);
                    if (r.done) return r.value;
                    var a = i(t),
                        l = String(this);
                    if (!a.global) return c(a, l);
                    var u = a.unicode;
                    a.lastIndex = 0;
                    var h, d = [],
                        p = 0;
                    while (null !== (h = c(a, l))) {
                        var f = String(h[0]);
                        d[p] = f, "" === f && (a.lastIndex = s(l, o(a.lastIndex), u)), p++
                    }
                    return 0 === p ? null : d
                }]
            }))
        },
        4721: function(t, e, n) {
            "use strict";
            n.d(e, "a", (function() {
                return o
            }));
            var r = n("5a89"),
                i = function(t, e) {
                    void 0 === e && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), e === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = t, this.domElement = e, this.enabled = !0, this.target = new r["Rb"], this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = {
                        LEFT: 37,
                        UP: 38,
                        RIGHT: 39,
                        BOTTOM: 40
                    }, this.mouseButtons = {
                        LEFT: r["O"].ROTATE,
                        MIDDLE: r["O"].DOLLY,
                        RIGHT: r["O"].PAN
                    }, this.touches = {
                        ONE: r["Gb"].ROTATE,
                        TWO: r["Gb"].DOLLY_PAN
                    }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function() {
                        return u.phi
                    }, this.getAzimuthalAngle = function() {
                        return u.theta
                    }, this.saveState = function() {
                        n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom
                    }, this.reset = function() {
                        n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(i), n.update(), c = s.NONE
                    }, this.update = function() {
                        var e = new r["Rb"],
                            o = (new r["pb"]).setFromUnitVectors(t.up, new r["Rb"](0, 1, 0)),
                            a = o.clone().inverse(),
                            m = new r["Rb"],
                            g = new r["pb"],
                            v = 2 * Math.PI;
                        return function() {
                            var t = n.object.position;
                            e.copy(t).sub(n.target), e.applyQuaternion(o), u.setFromVector3(e), n.autoRotate && c === s.NONE && E(T()), n.enableDamping ? (u.theta += h.theta * n.dampingFactor, u.phi += h.phi * n.dampingFactor) : (u.theta += h.theta, u.phi += h.phi);
                            var r = n.minAzimuthAngle,
                                y = n.maxAzimuthAngle;
                            return isFinite(r) && isFinite(y) && (r < -Math.PI ? r += v : r > Math.PI && (r -= v), y < -Math.PI ? y += v : y > Math.PI && (y -= v), u.theta = r < y ? Math.max(r, Math.min(y, u.theta)) : u.theta > (r + y) / 2 ? Math.max(r, u.theta) : Math.min(y, u.theta)), u.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, u.phi)), u.makeSafe(), u.radius *= d, u.radius = Math.max(n.minDistance, Math.min(n.maxDistance, u.radius)), !0 === n.enableDamping ? n.target.addScaledVector(p, n.dampingFactor) : n.target.add(p), e.setFromSpherical(u), e.applyQuaternion(a), t.copy(n.target).add(e), n.object.lookAt(n.target), !0 === n.enableDamping ? (h.theta *= 1 - n.dampingFactor, h.phi *= 1 - n.dampingFactor, p.multiplyScalar(1 - n.dampingFactor)) : (h.set(0, 0, 0), p.set(0, 0, 0)), d = 1, !!(f || m.distanceToSquared(n.object.position) > l || 8 * (1 - g.dot(n.object.quaternion)) > l) && (n.dispatchEvent(i), m.copy(n.object.position), g.copy(n.object.quaternion), f = !1, !0)
                        }
                    }(), this.dispose = function() {
                        n.domElement.removeEventListener("contextmenu", ut, !1), n.domElement.removeEventListener("pointerdown", Q, !1), n.domElement.removeEventListener("wheel", ot, !1), n.domElement.removeEventListener("touchstart", st, !1), n.domElement.removeEventListener("touchend", lt, !1), n.domElement.removeEventListener("touchmove", ct, !1), n.domElement.ownerDocument.removeEventListener("pointermove", tt, !1), n.domElement.ownerDocument.removeEventListener("pointerup", et, !1), n.domElement.removeEventListener("keydown", at, !1)
                    };
                    var n = this,
                        i = {
                            type: "change"
                        },
                        o = {
                            type: "start"
                        },
                        a = {
                            type: "end"
                        },
                        s = {
                            NONE: -1,
                            ROTATE: 0,
                            DOLLY: 1,
                            PAN: 2,
                            TOUCH_ROTATE: 3,
                            TOUCH_PAN: 4,
                            TOUCH_DOLLY_PAN: 5,
                            TOUCH_DOLLY_ROTATE: 6
                        },
                        c = s.NONE,
                        l = 1e-6,
                        u = new r["Eb"],
                        h = new r["Eb"],
                        d = 1,
                        p = new r["Rb"],
                        f = !1,
                        m = new r["Qb"],
                        g = new r["Qb"],
                        v = new r["Qb"],
                        y = new r["Qb"],
                        _ = new r["Qb"],
                        b = new r["Qb"],
                        x = new r["Qb"],
                        w = new r["Qb"],
                        M = new r["Qb"];

                    function T() {
                        return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed
                    }

                    function S() {
                        return Math.pow(.95, n.zoomSpeed)
                    }

                    function E(t) {
                        h.theta -= t
                    }

                    function A(t) {
                        h.phi -= t
                    }
                    var L = function() {
                            var t = new r["Rb"];
                            return function(e, n) {
                                t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), p.add(t)
                            }
                        }(),
                        R = function() {
                            var t = new r["Rb"];
                            return function(e, r) {
                                !0 === n.screenSpacePanning ? t.setFromMatrixColumn(r, 1) : (t.setFromMatrixColumn(r, 0), t.crossVectors(n.object.up, t)), t.multiplyScalar(e), p.add(t)
                            }
                        }(),
                        C = function() {
                            var t = new r["Rb"];
                            return function(e, r) {
                                var i = n.domElement;
                                if (n.object.isPerspectiveCamera) {
                                    var o = n.object.position;
                                    t.copy(o).sub(n.target);
                                    var a = t.length();
                                    a *= Math.tan(n.object.fov / 2 * Math.PI / 180), L(2 * e * a / i.clientHeight, n.object.matrix), R(2 * r * a / i.clientHeight, n.object.matrix)
                                } else n.object.isOrthographicCamera ? (L(e * (n.object.right - n.object.left) / n.object.zoom / i.clientWidth, n.object.matrix), R(r * (n.object.top - n.object.bottom) / n.object.zoom / i.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1)
                            }
                        }();

                    function O(t) {
                        n.object.isPerspectiveCamera ? d /= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * t)), n.object.updateProjectionMatrix(), f = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
                    }

                    function P(t) {
                        n.object.isPerspectiveCamera ? d *= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / t)), n.object.updateProjectionMatrix(), f = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
                    }

                    function I(t) {
                        m.set(t.clientX, t.clientY)
                    }

                    function N(t) {
                        x.set(t.clientX, t.clientY)
                    }

                    function D(t) {
                        y.set(t.clientX, t.clientY)
                    }

                    function k(t) {
                        g.set(t.clientX, t.clientY), v.subVectors(g, m).multiplyScalar(n.rotateSpeed);
                        var e = n.domElement;
                        E(2 * Math.PI * v.x / e.clientHeight), A(2 * Math.PI * v.y / e.clientHeight), m.copy(g), n.update()
                    }

                    function F(t) {
                        w.set(t.clientX, t.clientY), M.subVectors(w, x), M.y > 0 ? O(S()) : M.y < 0 && P(S()), x.copy(w), n.update()
                    }

                    function B(t) {
                        _.set(t.clientX, t.clientY), b.subVectors(_, y).multiplyScalar(n.panSpeed), C(b.x, b.y), y.copy(_), n.update()
                    }

                    function U() {}

                    function H(t) {
                        t.deltaY < 0 ? P(S()) : t.deltaY > 0 && O(S()), n.update()
                    }

                    function z(t) {
                        var e = !1;
                        switch (t.keyCode) {
                            case n.keys.UP:
                                C(0, n.keyPanSpeed), e = !0;
                                break;
                            case n.keys.BOTTOM:
                                C(0, -n.keyPanSpeed), e = !0;
                                break;
                            case n.keys.LEFT:
                                C(n.keyPanSpeed, 0), e = !0;
                                break;
                            case n.keys.RIGHT:
                                C(-n.keyPanSpeed, 0), e = !0;
                                break
                        }
                        e && (t.preventDefault(), n.update())
                    }

                    function j(t) {
                        if (1 == t.touches.length) m.set(t.touches[0].pageX, t.touches[0].pageY);
                        else {
                            var e = .5 * (t.touches[0].pageX + t.touches[1].pageX),
                                n = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                            m.set(e, n)
                        }
                    }

                    function G(t) {
                        if (1 == t.touches.length) y.set(t.touches[0].pageX, t.touches[0].pageY);
                        else {
                            var e = .5 * (t.touches[0].pageX + t.touches[1].pageX),
                                n = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                            y.set(e, n)
                        }
                    }

                    function V(t) {
                        var e = t.touches[0].pageX - t.touches[1].pageX,
                            n = t.touches[0].pageY - t.touches[1].pageY,
                            r = Math.sqrt(e * e + n * n);
                        x.set(0, r)
                    }

                    function W(t) {
                        n.enableZoom && V(t), n.enablePan && G(t)
                    }

                    function X(t) {
                        n.enableZoom && V(t), n.enableRotate && j(t)
                    }

                    function q(t) {
                        if (1 == t.touches.length) g.set(t.touches[0].pageX, t.touches[0].pageY);
                        else {
                            var e = .5 * (t.touches[0].pageX + t.touches[1].pageX),
                                r = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                            g.set(e, r)
                        }
                        v.subVectors(g, m).multiplyScalar(n.rotateSpeed);
                        var i = n.domElement;
                        E(2 * Math.PI * v.x / i.clientHeight), A(2 * Math.PI * v.y / i.clientHeight), m.copy(g)
                    }

                    function Y(t) {
                        if (1 == t.touches.length) _.set(t.touches[0].pageX, t.touches[0].pageY);
                        else {
                            var e = .5 * (t.touches[0].pageX + t.touches[1].pageX),
                                r = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                            _.set(e, r)
                        }
                        b.subVectors(_, y).multiplyScalar(n.panSpeed), C(b.x, b.y), y.copy(_)
                    }

                    function $(t) {
                        var e = t.touches[0].pageX - t.touches[1].pageX,
                            r = t.touches[0].pageY - t.touches[1].pageY,
                            i = Math.sqrt(e * e + r * r);
                        w.set(0, i), M.set(0, Math.pow(w.y / x.y, n.zoomSpeed)), O(M.y), x.copy(w)
                    }

                    function Z(t) {
                        n.enableZoom && $(t), n.enablePan && Y(t)
                    }

                    function J(t) {
                        n.enableZoom && $(t), n.enableRotate && q(t)
                    }

                    function K() {}

                    function Q(t) {
                        if (!1 !== n.enabled) switch (t.pointerType) {
                            case "mouse":
                            case "pen":
                                nt(t);
                                break
                        }
                    }

                    function tt(t) {
                        if (!1 !== n.enabled) switch (t.pointerType) {
                            case "mouse":
                            case "pen":
                                rt(t);
                                break
                        }
                    }

                    function et(t) {
                        if (!1 !== n.enabled) switch (t.pointerType) {
                            case "mouse":
                            case "pen":
                                it(t);
                                break
                        }
                    }

                    function nt(t) {
                        var e;
                        switch (t.preventDefault(), n.domElement.focus ? n.domElement.focus() : window.focus(), t.button) {
                            case 0:
                                e = n.mouseButtons.LEFT;
                                break;
                            case 1:
                                e = n.mouseButtons.MIDDLE;
                                break;
                            case 2:
                                e = n.mouseButtons.RIGHT;
                                break;
                            default:
                                e = -1
                        }
                        switch (e) {
                            case r["O"].DOLLY:
                                if (!1 === n.enableZoom) return;
                                N(t), c = s.DOLLY;
                                break;
                            case r["O"].ROTATE:
                                if (t.ctrlKey || t.metaKey || t.shiftKey) {
                                    if (!1 === n.enablePan) return;
                                    D(t), c = s.PAN
                                } else {
                                    if (!1 === n.enableRotate) return;
                                    I(t), c = s.ROTATE
                                }
                                break;
                            case r["O"].PAN:
                                if (t.ctrlKey || t.metaKey || t.shiftKey) {
                                    if (!1 === n.enableRotate) return;
                                    I(t), c = s.ROTATE
                                } else {
                                    if (!1 === n.enablePan) return;
                                    D(t), c = s.PAN
                                }
                                break;
                            default:
                                c = s.NONE
                        }
                        c !== s.NONE && (n.domElement.ownerDocument.addEventListener("pointermove", tt, !1), n.domElement.ownerDocument.addEventListener("pointerup", et, !1), n.dispatchEvent(o))
                    }

                    function rt(t) {
                        if (!1 !== n.enabled) switch (t.preventDefault(), c) {
                            case s.ROTATE:
                                if (!1 === n.enableRotate) return;
                                k(t);
                                break;
                            case s.DOLLY:
                                if (!1 === n.enableZoom) return;
                                F(t);
                                break;
                            case s.PAN:
                                if (!1 === n.enablePan) return;
                                B(t);
                                break
                        }
                    }

                    function it(t) {
                        !1 !== n.enabled && (U(t), n.domElement.ownerDocument.removeEventListener("pointermove", tt, !1), n.domElement.ownerDocument.removeEventListener("pointerup", et, !1), n.dispatchEvent(a), c = s.NONE)
                    }

                    function ot(t) {
                        !1 === n.enabled || !1 === n.enableZoom || c !== s.NONE && c !== s.ROTATE || (t.preventDefault(), t.stopPropagation(), n.dispatchEvent(o), H(t), n.dispatchEvent(a))
                    }

                    function at(t) {
                        !1 !== n.enabled && !1 !== n.enableKeys && !1 !== n.enablePan && z(t)
                    }

                    function st(t) {
                        if (!1 !== n.enabled) {
                            switch (t.preventDefault(), t.touches.length) {
                                case 1:
                                    switch (n.touches.ONE) {
                                        case r["Gb"].ROTATE:
                                            if (!1 === n.enableRotate) return;
                                            j(t), c = s.TOUCH_ROTATE;
                                            break;
                                        case r["Gb"].PAN:
                                            if (!1 === n.enablePan) return;
                                            G(t), c = s.TOUCH_PAN;
                                            break;
                                        default:
                                            c = s.NONE
                                    }
                                    break;
                                case 2:
                                    switch (n.touches.TWO) {
                                        case r["Gb"].DOLLY_PAN:
                                            if (!1 === n.enableZoom && !1 === n.enablePan) return;
                                            W(t), c = s.TOUCH_DOLLY_PAN;
                                            break;
                                        case r["Gb"].DOLLY_ROTATE:
                                            if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                                            X(t), c = s.TOUCH_DOLLY_ROTATE;
                                            break;
                                        default:
                                            c = s.NONE
                                    }
                                    break;
                                default:
                                    c = s.NONE
                            }
                            c !== s.NONE && n.dispatchEvent(o)
                        }
                    }

                    function ct(t) {
                        if (!1 !== n.enabled) switch (t.preventDefault(), t.stopPropagation(), c) {
                            case s.TOUCH_ROTATE:
                                if (!1 === n.enableRotate) return;
                                q(t), n.update();
                                break;
                            case s.TOUCH_PAN:
                                if (!1 === n.enablePan) return;
                                Y(t), n.update();
                                break;
                            case s.TOUCH_DOLLY_PAN:
                                if (!1 === n.enableZoom && !1 === n.enablePan) return;
                                Z(t), n.update();
                                break;
                            case s.TOUCH_DOLLY_ROTATE:
                                if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                                J(t), n.update();
                                break;
                            default:
                                c = s.NONE
                        }
                    }

                    function lt(t) {
                        !1 !== n.enabled && (K(t), n.dispatchEvent(a), c = s.NONE)
                    }

                    function ut(t) {
                        !1 !== n.enabled && t.preventDefault()
                    }
                    n.domElement.addEventListener("contextmenu", ut, !1), n.domElement.addEventListener("pointerdown", Q, !1), n.domElement.addEventListener("wheel", ot, !1), n.domElement.addEventListener("touchstart", st, !1), n.domElement.addEventListener("touchend", lt, !1), n.domElement.addEventListener("touchmove", ct, !1), n.domElement.addEventListener("keydown", at, !1), -1 === n.domElement.tabIndex && (n.domElement.tabIndex = 0), this.update()
                };
            i.prototype = Object.create(r["s"].prototype), i.prototype.constructor = i;
            var o = function(t, e) {
                i.call(this, t, e), this.screenSpacePanning = !1, this.mouseButtons.LEFT = r["O"].PAN, this.mouseButtons.RIGHT = r["O"].ROTATE, this.touches.ONE = r["Gb"].PAN, this.touches.TWO = r["Gb"].DOLLY_ROTATE
            };
            o.prototype = Object.create(r["s"].prototype), o.prototype.constructor = o
        },
        4840: function(t, e, n) {
            var r = n("825a"),
                i = n("1c0b"),
                o = n("b622"),
                a = o("species");
            t.exports = function(t, e) {
                var n, o = r(t).constructor;
                return void 0 === o || void 0 == (n = r(o)[a]) ? e : i(n)
            }
        },
        4930: function(t, e, n) {
            var r = n("d039");
            t.exports = !!Object.getOwnPropertySymbols && !r((function() {
                return !String(Symbol())
            }))
        },
        "4ae1": function(t, e, n) {
            var r = n("23e7"),
                i = n("d066"),
                o = n("1c0b"),
                a = n("825a"),
                s = n("861d"),
                c = n("7c73"),
                l = n("0538"),
                u = n("d039"),
                h = i("Reflect", "construct"),
                d = u((function() {
                    function t() {}
                    return !(h((function() {}), [], t) instanceof t)
                })),
                p = !u((function() {
                    h((function() {}))
                })),
                f = d || p;
            r({
                target: "Reflect",
                stat: !0,
                forced: f,
                sham: f
            }, {
                construct: function(t, e) {
                    o(t), a(e);
                    var n = arguments.length < 3 ? t : o(arguments[2]);
                    if (p && !d) return h(t, e, n);
                    if (t == n) {
                        switch (e.length) {
                            case 0:
                                return new t;
                            case 1:
                                return new t(e[0]);
                            case 2:
                                return new t(e[0], e[1]);
                            case 3:
                                return new t(e[0], e[1], e[2]);
                            case 4:
                                return new t(e[0], e[1], e[2], e[3])
                        }
                        var r = [null];
                        return r.push.apply(r, e), new(l.apply(t, r))
                    }
                    var i = n.prototype,
                        u = c(s(i) ? i : Object.prototype),
                        f = Function.apply.call(t, u, e);
                    return s(f) ? f : u
                }
            })
        },
        "4d63": function(t, e, n) {
            var r = n("83ab"),
                i = n("da84"),
                o = n("94ca"),
                a = n("7156"),
                s = n("9bf2").f,
                c = n("241c").f,
                l = n("44e7"),
                u = n("ad6d"),
                h = n("9f7f"),
                d = n("6eeb"),
                p = n("d039"),
                f = n("69f3").set,
                m = n("2626"),
                g = n("b622"),
                v = g("match"),
                y = i.RegExp,
                _ = y.prototype,
                b = /a/g,
                x = /a/g,
                w = new y(b) !== b,
                M = h.UNSUPPORTED_Y,
                T = r && o("RegExp", !w || M || p((function() {
                    return x[v] = !1, y(b) != b || y(x) == x || "/a/i" != y(b, "i")
                })));
            if (T) {
                var S = function(t, e) {
                        var n, r = this instanceof S,
                            i = l(t),
                            o = void 0 === e;
                        if (!r && i && t.constructor === S && o) return t;
                        w ? i && !o && (t = t.source) : t instanceof S && (o && (e = u.call(t)), t = t.source), M && (n = !!e && e.indexOf("y") > -1, n && (e = e.replace(/y/g, "")));
                        var s = a(w ? new y(t, e) : y(t, e), r ? this : _, S);
                        return M && n && f(s, {
                            sticky: n
                        }), s
                    },
                    E = function(t) {
                        t in S || s(S, t, {
                            configurable: !0,
                            get: function() {
                                return y[t]
                            },
                            set: function(e) {
                                y[t] = e
                            }
                        })
                    },
                    A = c(y),
                    L = 0;
                while (A.length > L) E(A[L++]);
                _.constructor = S, S.prototype = _, d(i, "RegExp", S)
            }
            m("RegExp")
        },
        "4d64": function(t, e, n) {
            var r = n("fc6a"),
                i = n("50c4"),
                o = n("23cb"),
                a = function(t) {
                    return function(e, n, a) {
                        var s, c = r(e),
                            l = i(c.length),
                            u = o(a, l);
                        if (t && n != n) {
                            while (l > u)
                                if (s = c[u++], s != s) return !0
                        } else
                            for (; l > u; u++)
                                if ((t || u in c) && c[u] === n) return t || u || 0;
                        return !t && -1
                    }
                };
            t.exports = {
                includes: a(!0),
                indexOf: a(!1)
            }
        },
        "4de4": function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("b727").filter,
                o = n("1dde"),
                a = n("ae40"),
                s = o("filter"),
                c = a("filter");
            r({
                target: "Array",
                proto: !0,
                forced: !s || !c
            }, {
                filter: function(t) {
                    return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
                }
            })
        },
        "4df4": function(t, e, n) {
            "use strict";
            var r = n("0366"),
                i = n("7b0b"),
                o = n("9bdd"),
                a = n("e95a"),
                s = n("50c4"),
                c = n("8418"),
                l = n("35a1");
            t.exports = function(t) {
                var e, n, u, h, d, p, f = i(t),
                    m = "function" == typeof this ? this : Array,
                    g = arguments.length,
                    v = g > 1 ? arguments[1] : void 0,
                    y = void 0 !== v,
                    _ = l(f),
                    b = 0;
                if (y && (v = r(v, g > 2 ? arguments[2] : void 0, 2)), void 0 == _ || m == Array && a(_))
                    for (e = s(f.length), n = new m(e); e > b; b++) p = y ? v(f[b], b) : f[b], c(n, b, p);
                else
                    for (h = _.call(f), d = h.next, n = new m; !(u = d.call(h)).done; b++) p = y ? o(h, v, [u.value, b], !0) : u.value, c(n, b, p);
                return n.length = b, n
            }
        },
        "50c4": function(t, e, n) {
            var r = n("a691"),
                i = Math.min;
            t.exports = function(t) {
                return t > 0 ? i(r(t), 9007199254740991) : 0
            }
        },
        5135: function(t, e) {
            var n = {}.hasOwnProperty;
            t.exports = function(t, e) {
                return n.call(t, e)
            }
        },
        5319: function(t, e, n) {
            "use strict";
            var r = n("d784"),
                i = n("825a"),
                o = n("7b0b"),
                a = n("50c4"),
                s = n("a691"),
                c = n("1d80"),
                l = n("8aa5"),
                u = n("14c3"),
                h = Math.max,
                d = Math.min,
                p = Math.floor,
                f = /\$([$&'`]|\d\d?|<[^>]*>)/g,
                m = /\$([$&'`]|\d\d?)/g,
                g = function(t) {
                    return void 0 === t ? t : String(t)
                };
            r("replace", 2, (function(t, e, n, r) {
                var v = r.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE,
                    y = r.REPLACE_KEEPS_$0,
                    _ = v ? "$" : "$0";
                return [function(n, r) {
                    var i = c(this),
                        o = void 0 == n ? void 0 : n[t];
                    return void 0 !== o ? o.call(n, i, r) : e.call(String(i), n, r)
                }, function(t, r) {
                    if (!v && y || "string" === typeof r && -1 === r.indexOf(_)) {
                        var o = n(e, t, this, r);
                        if (o.done) return o.value
                    }
                    var c = i(t),
                        p = String(this),
                        f = "function" === typeof r;
                    f || (r = String(r));
                    var m = c.global;
                    if (m) {
                        var x = c.unicode;
                        c.lastIndex = 0
                    }
                    var w = [];
                    while (1) {
                        var M = u(c, p);
                        if (null === M) break;
                        if (w.push(M), !m) break;
                        var T = String(M[0]);
                        "" === T && (c.lastIndex = l(p, a(c.lastIndex), x))
                    }
                    for (var S = "", E = 0, A = 0; A < w.length; A++) {
                        M = w[A];
                        for (var L = String(M[0]), R = h(d(s(M.index), p.length), 0), C = [], O = 1; O < M.length; O++) C.push(g(M[O]));
                        var P = M.groups;
                        if (f) {
                            var I = [L].concat(C, R, p);
                            void 0 !== P && I.push(P);
                            var N = String(r.apply(void 0, I))
                        } else N = b(L, p, R, C, P, r);
                        R >= E && (S += p.slice(E, R) + N, E = R + L.length)
                    }
                    return S + p.slice(E)
                }];

                function b(t, n, r, i, a, s) {
                    var c = r + t.length,
                        l = i.length,
                        u = m;
                    return void 0 !== a && (a = o(a), u = f), e.call(s, u, (function(e, o) {
                        var s;
                        switch (o.charAt(0)) {
                            case "$":
                                return "$";
                            case "&":
                                return t;
                            case "`":
                                return n.slice(0, r);
                            case "'":
                                return n.slice(c);
                            case "<":
                                s = a[o.slice(1, -1)];
                                break;
                            default:
                                var u = +o;
                                if (0 === u) return e;
                                if (u > l) {
                                    var h = p(u / 10);
                                    return 0 === h ? e : h <= l ? void 0 === i[h - 1] ? o.charAt(1) : i[h - 1] + o.charAt(1) : e
                                }
                                s = i[u - 1]
                        }
                        return void 0 === s ? "" : s
                    }))
                }
            }))
        },
        "53ca": function(t, e, n) {
            "use strict";
            n.d(e, "a", (function() {
                return r
            }));
            n("a4d3"), n("e01a"), n("d28b"), n("d3b7"), n("3ca3"), n("ddb0");

            function r(t) {
                return r = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(t) {
                    return typeof t
                } : function(t) {
                    return t && "function" === typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                }, r(t)
            }
        },
        5530: function(t, e, n) {
            "use strict";
            n.d(e, "a", (function() {
                return o
            }));
            n("a4d3"), n("4de4"), n("4160"), n("e439"), n("dbb4"), n("b64b"), n("159b");

            function r(t, e, n) {
                return e in t ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = n, t
            }

            function i(t, e) {
                var n = Object.keys(t);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(t);
                    e && (r = r.filter((function(e) {
                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                    }))), n.push.apply(n, r)
                }
                return n
            }

            function o(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var n = null != arguments[e] ? arguments[e] : {};
                    e % 2 ? i(Object(n), !0).forEach((function(e) {
                        r(t, e, n[e])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : i(Object(n)).forEach((function(e) {
                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                    }))
                }
                return t
            }
        },
        5692: function(t, e, n) {
            var r = n("c430"),
                i = n("c6cd");
            (t.exports = function(t, e) {
                return i[t] || (i[t] = void 0 !== e ? e : {})
            })("versions", []).push({
                version: "3.6.5",
                mode: r ? "pure" : "global",
                copyright: " 2020 Denis Pushkarev (zloirock.ru)"
            })
        },
        "56ef": function(t, e, n) {
            var r = n("d066"),
                i = n("241c"),
                o = n("7418"),
                a = n("825a");
            t.exports = r("Reflect", "ownKeys") || function(t) {
                var e = i.f(a(t)),
                    n = o.f;
                return n ? e.concat(n(t)) : e
            }
        },
        5899: function(t, e) {
            t.exports = "\t\n\v\f\r \u2028\u2029\ufeff"
        },
        "58a8": function(t, e, n) {
            var r = n("1d80"),
                i = n("5899"),
                o = "[" + i + "]",
                a = RegExp("^" + o + o + "*"),
                s = RegExp(o + o + "*$"),
                c = function(t) {
                    return function(e) {
                        var n = String(r(e));
                        return 1 & t && (n = n.replace(a, "")), 2 & t && (n = n.replace(s, "")), n
                    }
                };
            t.exports = {
                start: c(1),
                end: c(2),
                trim: c(3)
            }
        },
        "5a34": function(t, e, n) {
            var r = n("44e7");
            t.exports = function(t) {
                if (r(t)) throw TypeError("The method doesn't accept regular expressions");
                return t
            }
        },
        "5a89": function(t, e, n) {
            "use strict";
            n.d(e, "a", (function() {
                return dp
            })), n.d(e, "b", (function() {
                return hd
            })), n.d(e, "c", (function() {
                return fu
            })), n.d(e, "d", (function() {
                return Mn
            })), n.d(e, "e", (function() {
                return Yr
            })), n.d(e, "f", (function() {
                return pi
            })), n.d(e, "g", (function() {
                return Hu
            })), n.d(e, "h", (function() {
                return lt
            })), n.d(e, "i", (function() {
                return kp
            })), n.d(e, "j", (function() {
                return zr
            })), n.d(e, "k", (function() {
                return Ed
            })), n.d(e, "l", (function() {
                return Yi
            })), n.d(e, "m", (function() {
                return hp
            })), n.d(e, "n", (function() {
                return Tf
            })), n.d(e, "o", (function() {
                return f
            })), n.d(e, "p", (function() {
                return rn
            })), n.d(e, "q", (function() {
                return it
            })), n.d(e, "r", (function() {
                return nr
            })), n.d(e, "s", (function() {
                return an
            })), n.d(e, "t", (function() {
                return _d
            })), n.d(e, "u", (function() {
                return ni
            })), n.d(e, "v", (function() {
                return Mt
            })), n.d(e, "w", (function() {
                return d
            })), n.d(e, "x", (function() {
                return Dl
            })), n.d(e, "y", (function() {
                return wp
            })), n.d(e, "z", (function() {
                return _u
            })), n.d(e, "A", (function() {
                return jl
            })), n.d(e, "B", (function() {
                return Vl
            })), n.d(e, "C", (function() {
                return Qh
            })), n.d(e, "D", (function() {
                return Oe
            })), n.d(e, "E", (function() {
                return Pe
            })), n.d(e, "F", (function() {
                return Eu
            })), n.d(e, "G", (function() {
                return bu
            })), n.d(e, "H", (function() {
                return Cu
            })), n.d(e, "I", (function() {
                return Ru
            })), n.d(e, "J", (function() {
                return ft
            })), n.d(e, "K", (function() {
                return gt
            })), n.d(e, "L", (function() {
                return mt
            })), n.d(e, "M", (function() {
                return vd
            })), n.d(e, "N", (function() {
                return vp
            })), n.d(e, "O", (function() {
                return i
            })), n.d(e, "P", (function() {
                return Vr
            })), n.d(e, "Q", (function() {
                return ln
            })), n.d(e, "R", (function() {
                return hn
            })), n.d(e, "S", (function() {
                return Yn
            })), n.d(e, "T", (function() {
                return Oi
            })), n.d(e, "U", (function() {
                return Wr
            })), n.d(e, "V", (function() {
                return Yh
            })), n.d(e, "W", (function() {
                return Wh
            })), n.d(e, "X", (function() {
                return Vh
            })), n.d(e, "Y", (function() {
                return Gh
            })), n.d(e, "Z", (function() {
                return ut
            })), n.d(e, "ab", (function() {
                return ht
            })), n.d(e, "bb", (function() {
                return pt
            })), n.d(e, "cb", (function() {
                return dt
            })), n.d(e, "db", (function() {
                return g
            })), n.d(e, "eb", (function() {
                return ad
            })), n.d(e, "fb", (function() {
                return _r
            })), n.d(e, "gb", (function() {
                return lp
            })), n.d(e, "hb", (function() {
                return u
            })), n.d(e, "ib", (function() {
                return ji
            })), n.d(e, "jb", (function() {
                return to
            })), n.d(e, "kb", (function() {
                return Dh
            })), n.d(e, "lb", (function() {
                return cp
            })), n.d(e, "mb", (function() {
                return ku
            })), n.d(e, "nb", (function() {
                return Ou
            })), n.d(e, "ob", (function() {
                return Jp
            })), n.d(e, "pb", (function() {
                return _n
            })), n.d(e, "qb", (function() {
                return cd
            })), n.d(e, "rb", (function() {
                return Je
            })), n.d(e, "sb", (function() {
                return Ot
            })), n.d(e, "tb", (function() {
                return Ct
            })), n.d(e, "ub", (function() {
                return jh
            })), n.d(e, "vb", (function() {
                return of
            })), n.d(e, "wb", (function() {
                return kt
            })), n.d(e, "xb", (function() {
                return ct
            })), n.d(e, "yb", (function() {
                return zl
            })), n.d(e, "zb", (function() {
                return Hi
            })), n.d(e, "Ab", (function() {
                return pu
            })), n.d(e, "Bb", (function() {
                return uu
            })), n.d(e, "Cb", (function() {
                return Un
            })), n.d(e, "Db", (function() {
                return Hh
            })), n.d(e, "Eb", (function() {
                return cf
            })), n.d(e, "Fb", (function() {
                return ap
            })), n.d(e, "Gb", (function() {
                return o
            })), n.d(e, "Hb", (function() {
                return Ke
            })), n.d(e, "Ib", (function() {
                return mn
            })), n.d(e, "Jb", (function() {
                return Sd
            })), n.d(e, "Kb", (function() {
                return ze
            })), n.d(e, "Lb", (function() {
                return He
            })), n.d(e, "Mb", (function() {
                return Ue
            })), n.d(e, "Nb", (function() {
                return Qr
            })), n.d(e, "Ob", (function() {
                return Ts
            })), n.d(e, "Pb", (function() {
                return Fi
            })), n.d(e, "Qb", (function() {
                return un
            })), n.d(e, "Rb", (function() {
                return bn
            })), n.d(e, "Sb", (function() {
                return gn
            })), n.d(e, "Tb", (function() {
                return ud
            })), n.d(e, "Ub", (function() {
                return vn
            })), n.d(e, "Vb", (function() {
                return Ul
            })), n.d(e, "Wb", (function() {
                return Ge
            }));
            const r = "122",
                i = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2
                },
                o = {
                    ROTATE: 0,
                    PAN: 1,
                    DOLLY_PAN: 2,
                    DOLLY_ROTATE: 3
                },
                a = 0,
                s = 1,
                c = 2,
                l = 1,
                u = 2,
                h = 3,
                d = 0,
                p = 1,
                f = 2,
                m = 1,
                g = 0,
                v = 1,
                y = 2,
                _ = 3,
                b = 4,
                x = 5,
                w = 100,
                M = 101,
                T = 102,
                S = 103,
                E = 104,
                A = 200,
                L = 201,
                R = 202,
                C = 203,
                O = 204,
                P = 205,
                I = 206,
                N = 207,
                D = 208,
                k = 209,
                F = 210,
                B = 0,
                U = 1,
                H = 2,
                z = 3,
                j = 4,
                G = 5,
                V = 6,
                W = 7,
                X = 0,
                q = 1,
                Y = 2,
                $ = 0,
                Z = 1,
                J = 2,
                K = 3,
                Q = 4,
                tt = 5,
                et = 300,
                nt = 301,
                rt = 302,
                it = 303,
                ot = 304,
                at = 306,
                st = 307,
                ct = 1e3,
                lt = 1001,
                ut = 1002,
                ht = 1003,
                dt = 1004,
                pt = 1005,
                ft = 1006,
                mt = 1007,
                gt = 1008,
                vt = 1009,
                yt = 1010,
                _t = 1011,
                bt = 1012,
                xt = 1013,
                wt = 1014,
                Mt = 1015,
                Tt = 1016,
                St = 1017,
                Et = 1018,
                At = 1019,
                Lt = 1020,
                Rt = 1021,
                Ct = 1022,
                Ot = 1023,
                Pt = 1024,
                It = 1025,
                Nt = 1026,
                Dt = 1027,
                kt = 1028,
                Ft = 1029,
                Bt = 1030,
                Ut = 1031,
                Ht = 1032,
                zt = 1033,
                jt = 33776,
                Gt = 33777,
                Vt = 33778,
                Wt = 33779,
                Xt = 35840,
                qt = 35841,
                Yt = 35842,
                $t = 35843,
                Zt = 36196,
                Jt = 37492,
                Kt = 37496,
                Qt = 37808,
                te = 37809,
                ee = 37810,
                ne = 37811,
                re = 37812,
                ie = 37813,
                oe = 37814,
                ae = 37815,
                se = 37816,
                ce = 37817,
                le = 37818,
                ue = 37819,
                he = 37820,
                de = 37821,
                pe = 36492,
                fe = 37840,
                me = 37841,
                ge = 37842,
                ve = 37843,
                ye = 37844,
                _e = 37845,
                be = 37846,
                xe = 37847,
                we = 37848,
                Me = 37849,
                Te = 37850,
                Se = 37851,
                Ee = 37852,
                Ae = 37853,
                Le = 2200,
                Re = 2201,
                Ce = 2202,
                Oe = 2300,
                Pe = 2301,
                Ie = 2302,
                Ne = 2400,
                De = 2401,
                ke = 2402,
                Fe = 2500,
                Be = 2501,
                Ue = 0,
                He = 1,
                ze = 2,
                je = 3e3,
                Ge = 3001,
                Ve = 3007,
                We = 3002,
                Xe = 3003,
                qe = 3004,
                Ye = 3005,
                $e = 3006,
                Ze = 3200,
                Je = 3201,
                Ke = 0,
                Qe = 1,
                tn = 7680,
                en = 519,
                nn = 35044,
                rn = 35048,
                on = "300 es";

            function an() {}
            Object.assign(an.prototype, {
                addEventListener: function(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    const n = this._listeners;
                    void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                },
                hasEventListener: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    const n = this._listeners;
                    return void 0 !== n[t] && -1 !== n[t].indexOf(e)
                },
                removeEventListener: function(t, e) {
                    if (void 0 === this._listeners) return;
                    const n = this._listeners,
                        r = n[t];
                    if (void 0 !== r) {
                        const t = r.indexOf(e); - 1 !== t && r.splice(t, 1)
                    }
                },
                dispatchEvent: function(t) {
                    if (void 0 === this._listeners) return;
                    const e = this._listeners,
                        n = e[t.type];
                    if (void 0 !== n) {
                        t.target = this;
                        const e = n.slice(0);
                        for (let n = 0, r = e.length; n < r; n++) e[n].call(this, t)
                    }
                }
            });
            const sn = [];
            for (let kf = 0; kf < 256; kf++) sn[kf] = (kf < 16 ? "0" : "") + kf.toString(16);
            let cn = 1234567;
            const ln = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: function() {
                    const t = 4294967295 * Math.random() | 0,
                        e = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0,
                        r = 4294967295 * Math.random() | 0,
                        i = sn[255 & t] + sn[t >> 8 & 255] + sn[t >> 16 & 255] + sn[t >> 24 & 255] + "-" + sn[255 & e] + sn[e >> 8 & 255] + "-" + sn[e >> 16 & 15 | 64] + sn[e >> 24 & 255] + "-" + sn[63 & n | 128] + sn[n >> 8 & 255] + "-" + sn[n >> 16 & 255] + sn[n >> 24 & 255] + sn[255 & r] + sn[r >> 8 & 255] + sn[r >> 16 & 255] + sn[r >> 24 & 255];
                    return i.toUpperCase()
                },
                clamp: function(t, e, n) {
                    return Math.max(e, Math.min(n, t))
                },
                euclideanModulo: function(t, e) {
                    return (t % e + e) % e
                },
                mapLinear: function(t, e, n, r, i) {
                    return r + (t - e) * (i - r) / (n - e)
                },
                lerp: function(t, e, n) {
                    return (1 - n) * t + n * e
                },
                smoothstep: function(t, e, n) {
                    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * (3 - 2 * t))
                },
                smootherstep: function(t, e, n) {
                    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * t * (t * (6 * t - 15) + 10))
                },
                randInt: function(t, e) {
                    return t + Math.floor(Math.random() * (e - t + 1))
                },
                randFloat: function(t, e) {
                    return t + Math.random() * (e - t)
                },
                randFloatSpread: function(t) {
                    return t * (.5 - Math.random())
                },
                seededRandom: function(t) {
                    return void 0 !== t && (cn = t % 2147483647), cn = 16807 * cn % 2147483647, (cn - 1) / 2147483646
                },
                degToRad: function(t) {
                    return t * ln.DEG2RAD
                },
                radToDeg: function(t) {
                    return t * ln.RAD2DEG
                },
                isPowerOfTwo: function(t) {
                    return 0 === (t & t - 1) && 0 !== t
                },
                ceilPowerOfTwo: function(t) {
                    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                },
                floorPowerOfTwo: function(t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                },
                setQuaternionFromProperEuler: function(t, e, n, r, i) {
                    const o = Math.cos,
                        a = Math.sin,
                        s = o(n / 2),
                        c = a(n / 2),
                        l = o((e + r) / 2),
                        u = a((e + r) / 2),
                        h = o((e - r) / 2),
                        d = a((e - r) / 2),
                        p = o((r - e) / 2),
                        f = a((r - e) / 2);
                    switch (i) {
                        case "XYX":
                            t.set(s * u, c * h, c * d, s * l);
                            break;
                        case "YZY":
                            t.set(c * d, s * u, c * h, s * l);
                            break;
                        case "ZXZ":
                            t.set(c * h, c * d, s * u, s * l);
                            break;
                        case "XZX":
                            t.set(s * u, c * f, c * p, s * l);
                            break;
                        case "YXY":
                            t.set(c * p, s * u, c * f, s * l);
                            break;
                        case "ZYZ":
                            t.set(c * f, c * p, s * u, s * l);
                            break;
                        default:
                            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
                    }
                }
            };
            class un {
                constructor(t = 0, e = 0) {
                    Object.defineProperty(this, "isVector2", {
                        value: !0
                    }), this.x = t, this.y = e
                }
                get width() {
                    return this.x
                }
                set width(t) {
                    this.x = t
                }
                get height() {
                    return this.y
                }
                set height(t) {
                    this.y = t
                }
                set(t, e) {
                    return this.x = t, this.y = e, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this
                }
                multiply(t) {
                    return this.x *= t.x, this.y *= t.y, this
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this
                }
                divide(t) {
                    return this.x /= t.x, this.y /= t.y, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                applyMatrix3(t) {
                    const e = this.x,
                        n = this.y,
                        r = t.elements;
                    return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
                }
                clampLength(t, e) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y
                }
                cross(t) {
                    return this.x * t.y - this.y * t.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    const t = Math.atan2(-this.y, -this.x) + Math.PI;
                    return t
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                }
                distanceToSquared(t) {
                    const e = this.x - t.x,
                        n = this.y - t.y;
                    return e * e + n * n
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                }
                lerpVectors(t, e, n) {
                    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t
                }
                fromBufferAttribute(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
                }
                rotateAround(t, e) {
                    const n = Math.cos(e),
                        r = Math.sin(e),
                        i = this.x - t.x,
                        o = this.y - t.y;
                    return this.x = i * n - o * r + t.x, this.y = i * r + o * n + t.y, this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }
            }
            class hn {
                constructor() {
                    Object.defineProperty(this, "isMatrix3", {
                        value: !0
                    }), this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                }
                set(t, e, n, r, i, o, a, s, c) {
                    const l = this.elements;
                    return l[0] = t, l[1] = r, l[2] = a, l[3] = e, l[4] = i, l[5] = s, l[6] = n, l[7] = o, l[8] = c, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
                clone() {
                    return (new this.constructor).fromArray(this.elements)
                }
                copy(t) {
                    const e = this.elements,
                        n = t.elements;
                    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
                }
                extractBasis(t, e, n) {
                    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
                }
                setFromMatrix4(t) {
                    const e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                }
                multiply(t) {
                    return this.multiplyMatrices(this, t)
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this)
                }
                multiplyMatrices(t, e) {
                    const n = t.elements,
                        r = e.elements,
                        i = this.elements,
                        o = n[0],
                        a = n[3],
                        s = n[6],
                        c = n[1],
                        l = n[4],
                        u = n[7],
                        h = n[2],
                        d = n[5],
                        p = n[8],
                        f = r[0],
                        m = r[3],
                        g = r[6],
                        v = r[1],
                        y = r[4],
                        _ = r[7],
                        b = r[2],
                        x = r[5],
                        w = r[8];
                    return i[0] = o * f + a * v + s * b, i[3] = o * m + a * y + s * x, i[6] = o * g + a * _ + s * w, i[1] = c * f + l * v + u * b, i[4] = c * m + l * y + u * x, i[7] = c * g + l * _ + u * w, i[2] = h * f + d * v + p * b, i[5] = h * m + d * y + p * x, i[8] = h * g + d * _ + p * w, this
                }
                multiplyScalar(t) {
                    const e = this.elements;
                    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                }
                determinant() {
                    const t = this.elements,
                        e = t[0],
                        n = t[1],
                        r = t[2],
                        i = t[3],
                        o = t[4],
                        a = t[5],
                        s = t[6],
                        c = t[7],
                        l = t[8];
                    return e * o * l - e * a * c - n * i * l + n * a * s + r * i * c - r * o * s
                }
                getInverse(t, e) {
                    void 0 !== e && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
                    const n = t.elements,
                        r = this.elements,
                        i = n[0],
                        o = n[1],
                        a = n[2],
                        s = n[3],
                        c = n[4],
                        l = n[5],
                        u = n[6],
                        h = n[7],
                        d = n[8],
                        p = d * c - l * h,
                        f = l * u - d * s,
                        m = h * s - c * u,
                        g = i * p + o * f + a * m;
                    if (0 === g) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const v = 1 / g;
                    return r[0] = p * v, r[1] = (a * h - d * o) * v, r[2] = (l * o - a * c) * v, r[3] = f * v, r[4] = (d * i - a * u) * v, r[5] = (a * s - l * i) * v, r[6] = m * v, r[7] = (o * u - h * i) * v, r[8] = (c * i - o * s) * v, this
                }
                transpose() {
                    let t;
                    const e = this.elements;
                    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                }
                getNormalMatrix(t) {
                    return this.setFromMatrix4(t).getInverse(this).transpose()
                }
                transposeIntoArray(t) {
                    const e = this.elements;
                    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                }
                setUvTransform(t, e, n, r, i, o, a) {
                    const s = Math.cos(i),
                        c = Math.sin(i);
                    this.set(n * s, n * c, -n * (s * o + c * a) + o + t, -r * c, r * s, -r * (-c * o + s * a) + a + e, 0, 0, 1)
                }
                scale(t, e) {
                    const n = this.elements;
                    return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
                }
                rotate(t) {
                    const e = Math.cos(t),
                        n = Math.sin(t),
                        r = this.elements,
                        i = r[0],
                        o = r[3],
                        a = r[6],
                        s = r[1],
                        c = r[4],
                        l = r[7];
                    return r[0] = e * i + n * s, r[3] = e * o + n * c, r[6] = e * a + n * l, r[1] = -n * i + e * s, r[4] = -n * o + e * c, r[7] = -n * a + e * l, this
                }
                translate(t, e) {
                    const n = this.elements;
                    return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
                }
                equals(t) {
                    const e = this.elements,
                        n = t.elements;
                    for (let r = 0; r < 9; r++)
                        if (e[r] !== n[r]) return !1;
                    return !0
                }
                fromArray(t, e = 0) {
                    for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                    return this
                }
                toArray(t = [], e = 0) {
                    const n = this.elements;
                    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
                }
            }
            let dn;
            const pn = {
                getDataURL: function(t) {
                    if (/^data:/i.test(t.src)) return t.src;
                    if ("undefined" == typeof HTMLCanvasElement) return t.src;
                    let e;
                    if (t instanceof HTMLCanvasElement) e = t;
                    else {
                        void 0 === dn && (dn = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), dn.width = t.width, dn.height = t.height;
                        const n = dn.getContext("2d");
                        t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = dn
                    }
                    return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                }
            };
            let fn = 0;

            function mn(t, e, n, r, i, o, a, s, c, l) {
                Object.defineProperty(this, "id", {
                    value: fn++
                }), this.uuid = ln.generateUUID(), this.name = "", this.image = void 0 !== t ? t : mn.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : mn.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : lt, this.wrapT = void 0 !== r ? r : lt, this.magFilter = void 0 !== i ? i : ft, this.minFilter = void 0 !== o ? o : gt, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== a ? a : Ot, this.internalFormat = null, this.type = void 0 !== s ? s : vt, this.offset = new un(0, 0), this.repeat = new un(1, 1), this.center = new un(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new hn, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : je, this.version = 0, this.onUpdate = null
            }
            mn.DEFAULT_IMAGE = void 0, mn.DEFAULT_MAPPING = et, mn.prototype = Object.assign(Object.create(an.prototype), {
                constructor: mn,
                isTexture: !0,
                updateMatrix: function() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
                },
                toJSON: function(t) {
                    const e = void 0 === t || "string" === typeof t;
                    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                    const n = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    if (void 0 !== this.image) {
                        const r = this.image;
                        if (void 0 === r.uuid && (r.uuid = ln.generateUUID()), !e && void 0 === t.images[r.uuid]) {
                            let e;
                            if (Array.isArray(r)) {
                                e = [];
                                for (let t = 0, n = r.length; t < n; t++) e.push(pn.getDataURL(r[t]))
                            } else e = pn.getDataURL(r);
                            t.images[r.uuid] = {
                                uuid: r.uuid,
                                url: e
                            }
                        }
                        n.image = r.uuid
                    }
                    return e || (t.textures[this.uuid] = n), n
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(t) {
                    if (this.mapping !== et) return t;
                    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                        case ct:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case lt:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case ut:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
                            break
                    }
                    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                        case ct:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case lt:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case ut:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
                            break
                    }
                    return this.flipY && (t.y = 1 - t.y), t
                }
            }), Object.defineProperty(mn.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            });
            class gn {
                constructor(t = 0, e = 0, n = 0, r = 1) {
                    Object.defineProperty(this, "isVector4", {
                        value: !0
                    }), this.x = t, this.y = e, this.z = n, this.w = r
                }
                get width() {
                    return this.z
                }
                set width(t) {
                    this.z = t
                }
                get height() {
                    return this.w
                }
                set height(t) {
                    this.w = t
                }
                set(t, e, n, r) {
                    return this.x = t, this.y = e, this.z = n, this.w = r, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this.z = t, this.w = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setZ(t) {
                    return this.z = t, this
                }
                setW(t) {
                    return this.w = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this.z += t, this.w += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                }
                applyMatrix4(t) {
                    const e = this.x,
                        n = this.y,
                        r = this.z,
                        i = this.w,
                        o = t.elements;
                    return this.x = o[0] * e + o[4] * n + o[8] * r + o[12] * i, this.y = o[1] * e + o[5] * n + o[9] * r + o[13] * i, this.z = o[2] * e + o[6] * n + o[10] * r + o[14] * i, this.w = o[3] * e + o[7] * n + o[11] * r + o[15] * i, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                setAxisAngleFromQuaternion(t) {
                    this.w = 2 * Math.acos(t.w);
                    const e = Math.sqrt(1 - t.w * t.w);
                    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                }
                setAxisAngleFromRotationMatrix(t) {
                    let e, n, r, i;
                    const o = .01,
                        a = .1,
                        s = t.elements,
                        c = s[0],
                        l = s[4],
                        u = s[8],
                        h = s[1],
                        d = s[5],
                        p = s[9],
                        f = s[2],
                        m = s[6],
                        g = s[10];
                    if (Math.abs(l - h) < o && Math.abs(u - f) < o && Math.abs(p - m) < o) {
                        if (Math.abs(l + h) < a && Math.abs(u + f) < a && Math.abs(p + m) < a && Math.abs(c + d + g - 3) < a) return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        const t = (c + 1) / 2,
                            s = (d + 1) / 2,
                            v = (g + 1) / 2,
                            y = (l + h) / 4,
                            _ = (u + f) / 4,
                            b = (p + m) / 4;
                        return t > s && t > v ? t < o ? (n = 0, r = .707106781, i = .707106781) : (n = Math.sqrt(t), r = y / n, i = _ / n) : s > v ? s < o ? (n = .707106781, r = 0, i = .707106781) : (r = Math.sqrt(s), n = y / r, i = b / r) : v < o ? (n = .707106781, r = .707106781, i = 0) : (i = Math.sqrt(v), n = _ / i, r = b / i), this.set(n, r, i, e), this
                    }
                    let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - l) * (h - l));
                    return Math.abs(v) < .001 && (v = 1), this.x = (m - p) / v, this.y = (u - f) / v, this.z = (h - l) / v, this.w = Math.acos((c + d + g - 1) / 2), this
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
                }
                clampLength(t, e) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                }
                lerpVectors(t, e, n) {
                    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                }
                fromBufferAttribute(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                }
            }

            function vn(t, e, n) {
                this.width = t, this.height = e, this.scissor = new gn(0, 0, t, e), this.scissorTest = !1, this.viewport = new gn(0, 0, t, e), n = n || {}, this.texture = new mn(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : ft, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }

            function yn(t, e, n) {
                vn.call(this, t, e, n), this.samples = 4
            }
            vn.prototype = Object.assign(Object.create(an.prototype), {
                constructor: vn,
                isWebGLRenderTarget: !0,
                setSize: function(t, e) {
                    this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), yn.prototype = Object.assign(Object.create(vn.prototype), {
                constructor: yn,
                isWebGLMultisampleRenderTarget: !0,
                copy: function(t) {
                    return vn.prototype.copy.call(this, t), this.samples = t.samples, this
                }
            });
            class _n {
                constructor(t = 0, e = 0, n = 0, r = 1) {
                    Object.defineProperty(this, "isQuaternion", {
                        value: !0
                    }), this._x = t, this._y = e, this._z = n, this._w = r
                }
                static slerp(t, e, n, r) {
                    return n.copy(t).slerp(e, r)
                }
                static slerpFlat(t, e, n, r, i, o, a) {
                    let s = n[r + 0],
                        c = n[r + 1],
                        l = n[r + 2],
                        u = n[r + 3];
                    const h = i[o + 0],
                        d = i[o + 1],
                        p = i[o + 2],
                        f = i[o + 3];
                    if (u !== f || s !== h || c !== d || l !== p) {
                        let t = 1 - a;
                        const e = s * h + c * d + l * p + u * f,
                            n = e >= 0 ? 1 : -1,
                            r = 1 - e * e;
                        if (r > Number.EPSILON) {
                            const i = Math.sqrt(r),
                                o = Math.atan2(i, e * n);
                            t = Math.sin(t * o) / i, a = Math.sin(a * o) / i
                        }
                        const i = a * n;
                        if (s = s * t + h * i, c = c * t + d * i, l = l * t + p * i, u = u * t + f * i, t === 1 - a) {
                            const t = 1 / Math.sqrt(s * s + c * c + l * l + u * u);
                            s *= t, c *= t, l *= t, u *= t
                        }
                    }
                    t[e] = s, t[e + 1] = c, t[e + 2] = l, t[e + 3] = u
                }
                static multiplyQuaternionsFlat(t, e, n, r, i, o) {
                    const a = n[r],
                        s = n[r + 1],
                        c = n[r + 2],
                        l = n[r + 3],
                        u = i[o],
                        h = i[o + 1],
                        d = i[o + 2],
                        p = i[o + 3];
                    return t[e] = a * p + l * u + s * d - c * h, t[e + 1] = s * p + l * h + c * u - a * d, t[e + 2] = c * p + l * d + a * h - s * u, t[e + 3] = l * p - a * u - s * h - c * d, t
                }
                get x() {
                    return this._x
                }
                set x(t) {
                    this._x = t, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(t) {
                    this._y = t, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(t) {
                    this._z = t, this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(t) {
                    this._w = t, this._onChangeCallback()
                }
                set(t, e, n, r) {
                    return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
                copy(t) {
                    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
                }
                setFromEuler(t, e) {
                    if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    const n = t._x,
                        r = t._y,
                        i = t._z,
                        o = t._order,
                        a = Math.cos,
                        s = Math.sin,
                        c = a(n / 2),
                        l = a(r / 2),
                        u = a(i / 2),
                        h = s(n / 2),
                        d = s(r / 2),
                        p = s(i / 2);
                    switch (o) {
                        case "XYZ":
                            this._x = h * l * u + c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u - h * d * p;
                            break;
                        case "YXZ":
                            this._x = h * l * u + c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u + h * d * p;
                            break;
                        case "ZXY":
                            this._x = h * l * u - c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u - h * d * p;
                            break;
                        case "ZYX":
                            this._x = h * l * u - c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u + h * d * p;
                            break;
                        case "YZX":
                            this._x = h * l * u + c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u - h * d * p;
                            break;
                        case "XZY":
                            this._x = h * l * u - c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u + h * d * p;
                            break;
                        default:
                            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
                    }
                    return !1 !== e && this._onChangeCallback(), this
                }
                setFromAxisAngle(t, e) {
                    const n = e / 2,
                        r = Math.sin(n);
                    return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
                }
                setFromRotationMatrix(t) {
                    const e = t.elements,
                        n = e[0],
                        r = e[4],
                        i = e[8],
                        o = e[1],
                        a = e[5],
                        s = e[9],
                        c = e[2],
                        l = e[6],
                        u = e[10],
                        h = n + a + u;
                    if (h > 0) {
                        const t = .5 / Math.sqrt(h + 1);
                        this._w = .25 / t, this._x = (l - s) * t, this._y = (i - c) * t, this._z = (o - r) * t
                    } else if (n > a && n > u) {
                        const t = 2 * Math.sqrt(1 + n - a - u);
                        this._w = (l - s) / t, this._x = .25 * t, this._y = (r + o) / t, this._z = (i + c) / t
                    } else if (a > u) {
                        const t = 2 * Math.sqrt(1 + a - n - u);
                        this._w = (i - c) / t, this._x = (r + o) / t, this._y = .25 * t, this._z = (s + l) / t
                    } else {
                        const t = 2 * Math.sqrt(1 + u - n - a);
                        this._w = (o - r) / t, this._x = (i + c) / t, this._y = (s + l) / t, this._z = .25 * t
                    }
                    return this._onChangeCallback(), this
                }
                setFromUnitVectors(t, e) {
                    const n = 1e-6;
                    let r = t.dot(e) + 1;
                    return r < n ? (r = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = r)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = r), this.normalize()
                }
                angleTo(t) {
                    return 2 * Math.acos(Math.abs(ln.clamp(this.dot(t), -1, 1)))
                }
                rotateTowards(t, e) {
                    const n = this.angleTo(t);
                    if (0 === n) return this;
                    const r = Math.min(1, e / n);
                    return this.slerp(t, r), this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                inverse() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
                dot(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let t = this.length();
                    return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
                }
                premultiply(t) {
                    return this.multiplyQuaternions(t, this)
                }
                multiplyQuaternions(t, e) {
                    const n = t._x,
                        r = t._y,
                        i = t._z,
                        o = t._w,
                        a = e._x,
                        s = e._y,
                        c = e._z,
                        l = e._w;
                    return this._x = n * l + o * a + r * c - i * s, this._y = r * l + o * s + i * a - n * c, this._z = i * l + o * c + n * s - r * a, this._w = o * l - n * a - r * s - i * c, this._onChangeCallback(), this
                }
                slerp(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    const n = this._x,
                        r = this._y,
                        i = this._z,
                        o = this._w;
                    let a = o * t._w + n * t._x + r * t._y + i * t._z;
                    if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = n, this._y = r, this._z = i, this;
                    const s = 1 - a * a;
                    if (s <= Number.EPSILON) {
                        const t = 1 - e;
                        return this._w = t * o + e * this._w, this._x = t * n + e * this._x, this._y = t * r + e * this._y, this._z = t * i + e * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    const c = Math.sqrt(s),
                        l = Math.atan2(c, a),
                        u = Math.sin((1 - e) * l) / c,
                        h = Math.sin(e * l) / c;
                    return this._w = o * u + this._w * h, this._x = n * u + this._x * h, this._y = r * u + this._y * h, this._z = i * u + this._z * h, this._onChangeCallback(), this
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                }
                fromArray(t, e = 0) {
                    return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                }
                fromBufferAttribute(t, e) {
                    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
                }
                _onChange(t) {
                    return this._onChangeCallback = t, this
                }
                _onChangeCallback() {}
            }
            class bn {
                constructor(t = 0, e = 0, n = 0) {
                    Object.defineProperty(this, "isVector3", {
                        value: !0
                    }), this.x = t, this.y = e, this.z = n
                }
                set(t, e, n) {
                    return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this.z = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setZ(t) {
                    return this.z = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this.z += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this
                }
                multiplyVectors(t, e) {
                    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                }
                applyEuler(t) {
                    return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(wn.setFromEuler(t))
                }
                applyAxisAngle(t, e) {
                    return this.applyQuaternion(wn.setFromAxisAngle(t, e))
                }
                applyMatrix3(t) {
                    const e = this.x,
                        n = this.y,
                        r = this.z,
                        i = t.elements;
                    return this.x = i[0] * e + i[3] * n + i[6] * r, this.y = i[1] * e + i[4] * n + i[7] * r, this.z = i[2] * e + i[5] * n + i[8] * r, this
                }
                applyNormalMatrix(t) {
                    return this.applyMatrix3(t).normalize()
                }
                applyMatrix4(t) {
                    const e = this.x,
                        n = this.y,
                        r = this.z,
                        i = t.elements,
                        o = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
                    return this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * o, this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * o, this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * o, this
                }
                applyQuaternion(t) {
                    const e = this.x,
                        n = this.y,
                        r = this.z,
                        i = t.x,
                        o = t.y,
                        a = t.z,
                        s = t.w,
                        c = s * e + o * r - a * n,
                        l = s * n + a * e - i * r,
                        u = s * r + i * n - o * e,
                        h = -i * e - o * n - a * r;
                    return this.x = c * s + h * -i + l * -a - u * -o, this.y = l * s + h * -o + u * -i - c * -a, this.z = u * s + h * -a + c * -o - l * -i, this
                }
                project(t) {
                    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                }
                unproject(t) {
                    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                }
                transformDirection(t) {
                    const e = this.x,
                        n = this.y,
                        r = this.z,
                        i = t.elements;
                    return this.x = i[0] * e + i[4] * n + i[8] * r, this.y = i[1] * e + i[5] * n + i[9] * r, this.z = i[2] * e + i[6] * n + i[10] * r, this.normalize()
                }
                divide(t) {
                    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
                }
                clampLength(t, e) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                }
                lerpVectors(t, e, n) {
                    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
                }
                cross(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
                }
                crossVectors(t, e) {
                    const n = t.x,
                        r = t.y,
                        i = t.z,
                        o = e.x,
                        a = e.y,
                        s = e.z;
                    return this.x = r * s - i * a, this.y = i * o - n * s, this.z = n * a - r * o, this
                }
                projectOnVector(t) {
                    const e = t.lengthSq();
                    if (0 === e) return this.set(0, 0, 0);
                    const n = t.dot(this) / e;
                    return this.copy(t).multiplyScalar(n)
                }
                projectOnPlane(t) {
                    return xn.copy(this).projectOnVector(t), this.sub(xn)
                }
                reflect(t) {
                    return this.sub(xn.copy(t).multiplyScalar(2 * this.dot(t)))
                }
                angleTo(t) {
                    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                    if (0 === e) return Math.PI / 2;
                    const n = this.dot(t) / e;
                    return Math.acos(ln.clamp(n, -1, 1))
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                }
                distanceToSquared(t) {
                    const e = this.x - t.x,
                        n = this.y - t.y,
                        r = this.z - t.z;
                    return e * e + n * n + r * r
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                }
                setFromSpherical(t) {
                    return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                }
                setFromSphericalCoords(t, e, n) {
                    const r = Math.sin(e) * t;
                    return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this
                }
                setFromCylindrical(t) {
                    return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                }
                setFromCylindricalCoords(t, e, n) {
                    return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
                }
                setFromMatrixPosition(t) {
                    const e = t.elements;
                    return this.x = e[12], this.y = e[13], this.z = e[14], this
                }
                setFromMatrixScale(t) {
                    const e = this.setFromMatrixColumn(t, 0).length(),
                        n = this.setFromMatrixColumn(t, 1).length(),
                        r = this.setFromMatrixColumn(t, 2).length();
                    return this.x = e, this.y = n, this.z = r, this
                }
                setFromMatrixColumn(t, e) {
                    return this.fromArray(t.elements, 4 * e)
                }
                setFromMatrix3Column(t, e) {
                    return this.fromArray(t.elements, 3 * e)
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                }
                fromBufferAttribute(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                }
            }
            const xn = new bn,
                wn = new _n;
            class Mn {
                constructor(t, e) {
                    Object.defineProperty(this, "isBox3", {
                        value: !0
                    }), this.min = void 0 !== t ? t : new bn(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new bn(-1 / 0, -1 / 0, -1 / 0)
                }
                set(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                }
                setFromArray(t) {
                    let e = 1 / 0,
                        n = 1 / 0,
                        r = 1 / 0,
                        i = -1 / 0,
                        o = -1 / 0,
                        a = -1 / 0;
                    for (let s = 0, c = t.length; s < c; s += 3) {
                        const c = t[s],
                            l = t[s + 1],
                            u = t[s + 2];
                        c < e && (e = c), l < n && (n = l), u < r && (r = u), c > i && (i = c), l > o && (o = l), u > a && (a = u)
                    }
                    return this.min.set(e, n, r), this.max.set(i, o, a), this
                }
                setFromBufferAttribute(t) {
                    let e = 1 / 0,
                        n = 1 / 0,
                        r = 1 / 0,
                        i = -1 / 0,
                        o = -1 / 0,
                        a = -1 / 0;
                    for (let s = 0, c = t.count; s < c; s++) {
                        const c = t.getX(s),
                            l = t.getY(s),
                            u = t.getZ(s);
                        c < e && (e = c), l < n && (n = l), u < r && (r = u), c > i && (i = c), l > o && (o = l), u > a && (a = u)
                    }
                    return this.min.set(e, n, r), this.max.set(i, o, a), this
                }
                setFromPoints(t) {
                    this.makeEmpty();
                    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                    return this
                }
                setFromCenterAndSize(t, e) {
                    const n = En.copy(e).multiplyScalar(.5);
                    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                }
                setFromObject(t) {
                    return this.makeEmpty(), this.expandByObject(t)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new bn), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new bn), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                }
                expandByPoint(t) {
                    return this.min.min(t), this.max.max(t), this
                }
                expandByVector(t) {
                    return this.min.sub(t), this.max.add(t), this
                }
                expandByScalar(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                }
                expandByObject(t) {
                    t.updateWorldMatrix(!1, !1);
                    const e = t.geometry;
                    void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), An.copy(e.boundingBox), An.applyMatrix4(t.matrixWorld), this.union(An));
                    const n = t.children;
                    for (let r = 0, i = n.length; r < i; r++) this.expandByObject(n[r]);
                    return this
                }
                containsPoint(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                }
                containsBox(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                }
                getParameter(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new bn), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                }
                intersectsSphere(t) {
                    return this.clampPoint(t.center, En), En.distanceToSquared(t.center) <= t.radius * t.radius
                }
                intersectsPlane(t) {
                    let e, n;
                    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
                }
                intersectsTriangle(t) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(Nn), Dn.subVectors(this.max, Nn), Ln.subVectors(t.a, Nn), Rn.subVectors(t.b, Nn), Cn.subVectors(t.c, Nn), On.subVectors(Rn, Ln), Pn.subVectors(Cn, Rn), In.subVectors(Ln, Cn);
                    let e = [0, -On.z, On.y, 0, -Pn.z, Pn.y, 0, -In.z, In.y, On.z, 0, -On.x, Pn.z, 0, -Pn.x, In.z, 0, -In.x, -On.y, On.x, 0, -Pn.y, Pn.x, 0, -In.y, In.x, 0];
                    return !!Tn(e, Ln, Rn, Cn, Dn) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Tn(e, Ln, Rn, Cn, Dn) && (kn.crossVectors(On, Pn), e = [kn.x, kn.y, kn.z], Tn(e, Ln, Rn, Cn, Dn)))
                }
                clampPoint(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new bn), e.copy(t).clamp(this.min, this.max)
                }
                distanceToPoint(t) {
                    const e = En.copy(t).clamp(this.min, this.max);
                    return e.sub(t).length()
                }
                getBoundingSphere(t) {
                    return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(En).length(), t
                }
                intersect(t) {
                    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                }
                union(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                }
                applyMatrix4(t) {
                    return this.isEmpty() || (Sn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Sn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Sn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Sn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Sn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Sn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Sn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Sn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Sn)), this
                }
                translate(t) {
                    return this.min.add(t), this.max.add(t), this
                }
                equals(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }

            function Tn(t, e, n, r, i) {
                for (let o = 0, a = t.length - 3; o <= a; o += 3) {
                    Fn.fromArray(t, o);
                    const a = i.x * Math.abs(Fn.x) + i.y * Math.abs(Fn.y) + i.z * Math.abs(Fn.z),
                        s = e.dot(Fn),
                        c = n.dot(Fn),
                        l = r.dot(Fn);
                    if (Math.max(-Math.max(s, c, l), Math.min(s, c, l)) > a) return !1
                }
                return !0
            }
            const Sn = [new bn, new bn, new bn, new bn, new bn, new bn, new bn, new bn],
                En = new bn,
                An = new Mn,
                Ln = new bn,
                Rn = new bn,
                Cn = new bn,
                On = new bn,
                Pn = new bn,
                In = new bn,
                Nn = new bn,
                Dn = new bn,
                kn = new bn,
                Fn = new bn,
                Bn = new Mn;
            class Un {
                constructor(t, e) {
                    this.center = void 0 !== t ? t : new bn, this.radius = void 0 !== e ? e : -1
                }
                set(t, e) {
                    return this.center.copy(t), this.radius = e, this
                }
                setFromPoints(t, e) {
                    const n = this.center;
                    void 0 !== e ? n.copy(e) : Bn.setFromPoints(t).getCenter(n);
                    let r = 0;
                    for (let i = 0, o = t.length; i < o; i++) r = Math.max(r, n.distanceToSquared(t[i]));
                    return this.radius = Math.sqrt(r), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.center.copy(t.center), this.radius = t.radius, this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), this.radius = -1, this
                }
                containsPoint(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(t) {
                    return t.distanceTo(this.center) - this.radius
                }
                intersectsSphere(t) {
                    const e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e
                }
                intersectsBox(t) {
                    return t.intersectsSphere(this)
                }
                intersectsPlane(t) {
                    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(t, e) {
                    const n = this.center.distanceToSquared(t);
                    return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new bn), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                }
                getBoundingBox(t) {
                    return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new Mn), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
                }
                applyMatrix4(t) {
                    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                }
                translate(t) {
                    return this.center.add(t), this
                }
                equals(t) {
                    return t.center.equals(this.center) && t.radius === this.radius
                }
            }
            const Hn = new bn,
                zn = new bn,
                jn = new bn,
                Gn = new bn,
                Vn = new bn,
                Wn = new bn,
                Xn = new bn;
            class qn {
                constructor(t, e) {
                    this.origin = void 0 !== t ? t : new bn, this.direction = void 0 !== e ? e : new bn(0, 0, -1)
                }
                set(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                }
                at(t, e) {
                    return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new bn), e.copy(this.direction).multiplyScalar(t).add(this.origin)
                }
                lookAt(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(), this
                }
                recast(t) {
                    return this.origin.copy(this.at(t, Hn)), this
                }
                closestPointToPoint(t, e) {
                    void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new bn), e.subVectors(t, this.origin);
                    const n = e.dot(this.direction);
                    return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
                }
                distanceToPoint(t) {
                    return Math.sqrt(this.distanceSqToPoint(t))
                }
                distanceSqToPoint(t) {
                    const e = Hn.subVectors(t, this.origin).dot(this.direction);
                    return e < 0 ? this.origin.distanceToSquared(t) : (Hn.copy(this.direction).multiplyScalar(e).add(this.origin), Hn.distanceToSquared(t))
                }
                distanceSqToSegment(t, e, n, r) {
                    zn.copy(t).add(e).multiplyScalar(.5), jn.copy(e).sub(t).normalize(), Gn.copy(this.origin).sub(zn);
                    const i = .5 * t.distanceTo(e),
                        o = -this.direction.dot(jn),
                        a = Gn.dot(this.direction),
                        s = -Gn.dot(jn),
                        c = Gn.lengthSq(),
                        l = Math.abs(1 - o * o);
                    let u, h, d, p;
                    if (l > 0)
                        if (u = o * s - a, h = o * a - s, p = i * l, u >= 0)
                            if (h >= -p)
                                if (h <= p) {
                                    const t = 1 / l;
                                    u *= t, h *= t, d = u * (u + o * h + 2 * a) + h * (o * u + h + 2 * s) + c
                                } else h = i, u = Math.max(0, -(o * h + a)), d = -u * u + h * (h + 2 * s) + c;
                    else h = -i, u = Math.max(0, -(o * h + a)), d = -u * u + h * (h + 2 * s) + c;
                    else h <= -p ? (u = Math.max(0, -(-o * i + a)), h = u > 0 ? -i : Math.min(Math.max(-i, -s), i), d = -u * u + h * (h + 2 * s) + c) : h <= p ? (u = 0, h = Math.min(Math.max(-i, -s), i), d = h * (h + 2 * s) + c) : (u = Math.max(0, -(o * i + a)), h = u > 0 ? i : Math.min(Math.max(-i, -s), i), d = -u * u + h * (h + 2 * s) + c);
                    else h = o > 0 ? -i : i, u = Math.max(0, -(o * h + a)), d = -u * u + h * (h + 2 * s) + c;
                    return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), r && r.copy(jn).multiplyScalar(h).add(zn), d
                }
                intersectSphere(t, e) {
                    Hn.subVectors(t.center, this.origin);
                    const n = Hn.dot(this.direction),
                        r = Hn.dot(Hn) - n * n,
                        i = t.radius * t.radius;
                    if (r > i) return null;
                    const o = Math.sqrt(i - r),
                        a = n - o,
                        s = n + o;
                    return a < 0 && s < 0 ? null : a < 0 ? this.at(s, e) : this.at(a, e)
                }
                intersectsSphere(t) {
                    return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                }
                distanceToPlane(t) {
                    const e = t.normal.dot(this.direction);
                    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    const n = -(this.origin.dot(t.normal) + t.constant) / e;
                    return n >= 0 ? n : null
                }
                intersectPlane(t, e) {
                    const n = this.distanceToPlane(t);
                    return null === n ? null : this.at(n, e)
                }
                intersectsPlane(t) {
                    const e = t.distanceToPoint(this.origin);
                    if (0 === e) return !0;
                    const n = t.normal.dot(this.direction);
                    return n * e < 0
                }
                intersectBox(t, e) {
                    let n, r, i, o, a, s;
                    const c = 1 / this.direction.x,
                        l = 1 / this.direction.y,
                        u = 1 / this.direction.z,
                        h = this.origin;
                    return c >= 0 ? (n = (t.min.x - h.x) * c, r = (t.max.x - h.x) * c) : (n = (t.max.x - h.x) * c, r = (t.min.x - h.x) * c), l >= 0 ? (i = (t.min.y - h.y) * l, o = (t.max.y - h.y) * l) : (i = (t.max.y - h.y) * l, o = (t.min.y - h.y) * l), n > o || i > r ? null : ((i > n || n !== n) && (n = i), (o < r || r !== r) && (r = o), u >= 0 ? (a = (t.min.z - h.z) * u, s = (t.max.z - h.z) * u) : (a = (t.max.z - h.z) * u, s = (t.min.z - h.z) * u), n > s || a > r ? null : ((a > n || n !== n) && (n = a), (s < r || r !== r) && (r = s), r < 0 ? null : this.at(n >= 0 ? n : r, e)))
                }
                intersectsBox(t) {
                    return null !== this.intersectBox(t, Hn)
                }
                intersectTriangle(t, e, n, r, i) {
                    Vn.subVectors(e, t), Wn.subVectors(n, t), Xn.crossVectors(Vn, Wn);
                    let o, a = this.direction.dot(Xn);
                    if (a > 0) {
                        if (r) return null;
                        o = 1
                    } else {
                        if (!(a < 0)) return null;
                        o = -1, a = -a
                    }
                    Gn.subVectors(this.origin, t);
                    const s = o * this.direction.dot(Wn.crossVectors(Gn, Wn));
                    if (s < 0) return null;
                    const c = o * this.direction.dot(Vn.cross(Gn));
                    if (c < 0) return null;
                    if (s + c > a) return null;
                    const l = -o * Gn.dot(Xn);
                    return l < 0 ? null : this.at(l / a, i)
                }
                applyMatrix4(t) {
                    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                }
                equals(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                }
            }
            class Yn {
                constructor() {
                    Object.defineProperty(this, "isMatrix4", {
                        value: !0
                    }), this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                }
                set(t, e, n, r, i, o, a, s, c, l, u, h, d, p, f, m) {
                    const g = this.elements;
                    return g[0] = t, g[4] = e, g[8] = n, g[12] = r, g[1] = i, g[5] = o, g[9] = a, g[13] = s, g[2] = c, g[6] = l, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                clone() {
                    return (new Yn).fromArray(this.elements)
                }
                copy(t) {
                    const e = this.elements,
                        n = t.elements;
                    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                }
                copyPosition(t) {
                    const e = this.elements,
                        n = t.elements;
                    return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
                }
                extractBasis(t, e, n) {
                    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                }
                makeBasis(t, e, n) {
                    return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
                }
                extractRotation(t) {
                    const e = this.elements,
                        n = t.elements,
                        r = 1 / $n.setFromMatrixColumn(t, 0).length(),
                        i = 1 / $n.setFromMatrixColumn(t, 1).length(),
                        o = 1 / $n.setFromMatrixColumn(t, 2).length();
                    return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * i, e[5] = n[5] * i, e[6] = n[6] * i, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                }
                makeRotationFromEuler(t) {
                    t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    const e = this.elements,
                        n = t.x,
                        r = t.y,
                        i = t.z,
                        o = Math.cos(n),
                        a = Math.sin(n),
                        s = Math.cos(r),
                        c = Math.sin(r),
                        l = Math.cos(i),
                        u = Math.sin(i);
                    if ("XYZ" === t.order) {
                        const t = o * l,
                            n = o * u,
                            r = a * l,
                            i = a * u;
                        e[0] = s * l, e[4] = -s * u, e[8] = c, e[1] = n + r * c, e[5] = t - i * c, e[9] = -a * s, e[2] = i - t * c, e[6] = r + n * c, e[10] = o * s
                    } else if ("YXZ" === t.order) {
                        const t = s * l,
                            n = s * u,
                            r = c * l,
                            i = c * u;
                        e[0] = t + i * a, e[4] = r * a - n, e[8] = o * c, e[1] = o * u, e[5] = o * l, e[9] = -a, e[2] = n * a - r, e[6] = i + t * a, e[10] = o * s
                    } else if ("ZXY" === t.order) {
                        const t = s * l,
                            n = s * u,
                            r = c * l,
                            i = c * u;
                        e[0] = t - i * a, e[4] = -o * u, e[8] = r + n * a, e[1] = n + r * a, e[5] = o * l, e[9] = i - t * a, e[2] = -o * c, e[6] = a, e[10] = o * s
                    } else if ("ZYX" === t.order) {
                        const t = o * l,
                            n = o * u,
                            r = a * l,
                            i = a * u;
                        e[0] = s * l, e[4] = r * c - n, e[8] = t * c + i, e[1] = s * u, e[5] = i * c + t, e[9] = n * c - r, e[2] = -c, e[6] = a * s, e[10] = o * s
                    } else if ("YZX" === t.order) {
                        const t = o * s,
                            n = o * c,
                            r = a * s,
                            i = a * c;
                        e[0] = s * l, e[4] = i - t * u, e[8] = r * u + n, e[1] = u, e[5] = o * l, e[9] = -a * l, e[2] = -c * l, e[6] = n * u + r, e[10] = t - i * u
                    } else if ("XZY" === t.order) {
                        const t = o * s,
                            n = o * c,
                            r = a * s,
                            i = a * c;
                        e[0] = s * l, e[4] = -u, e[8] = c * l, e[1] = t * u + i, e[5] = o * l, e[9] = n * u - r, e[2] = r * u - n, e[6] = a * l, e[10] = i * u + t
                    }
                    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                }
                makeRotationFromQuaternion(t) {
                    return this.compose(Jn, t, Kn)
                }
                lookAt(t, e, n) {
                    const r = this.elements;
                    return er.subVectors(t, e), 0 === er.lengthSq() && (er.z = 1), er.normalize(), Qn.crossVectors(n, er), 0 === Qn.lengthSq() && (1 === Math.abs(n.z) ? er.x += 1e-4 : er.z += 1e-4, er.normalize(), Qn.crossVectors(n, er)), Qn.normalize(), tr.crossVectors(er, Qn), r[0] = Qn.x, r[4] = tr.x, r[8] = er.x, r[1] = Qn.y, r[5] = tr.y, r[9] = er.y, r[2] = Qn.z, r[6] = tr.z, r[10] = er.z, this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this)
                }
                multiplyMatrices(t, e) {
                    const n = t.elements,
                        r = e.elements,
                        i = this.elements,
                        o = n[0],
                        a = n[4],
                        s = n[8],
                        c = n[12],
                        l = n[1],
                        u = n[5],
                        h = n[9],
                        d = n[13],
                        p = n[2],
                        f = n[6],
                        m = n[10],
                        g = n[14],
                        v = n[3],
                        y = n[7],
                        _ = n[11],
                        b = n[15],
                        x = r[0],
                        w = r[4],
                        M = r[8],
                        T = r[12],
                        S = r[1],
                        E = r[5],
                        A = r[9],
                        L = r[13],
                        R = r[2],
                        C = r[6],
                        O = r[10],
                        P = r[14],
                        I = r[3],
                        N = r[7],
                        D = r[11],
                        k = r[15];
                    return i[0] = o * x + a * S + s * R + c * I, i[4] = o * w + a * E + s * C + c * N, i[8] = o * M + a * A + s * O + c * D, i[12] = o * T + a * L + s * P + c * k, i[1] = l * x + u * S + h * R + d * I, i[5] = l * w + u * E + h * C + d * N, i[9] = l * M + u * A + h * O + d * D, i[13] = l * T + u * L + h * P + d * k, i[2] = p * x + f * S + m * R + g * I, i[6] = p * w + f * E + m * C + g * N, i[10] = p * M + f * A + m * O + g * D, i[14] = p * T + f * L + m * P + g * k, i[3] = v * x + y * S + _ * R + b * I, i[7] = v * w + y * E + _ * C + b * N, i[11] = v * M + y * A + _ * O + b * D, i[15] = v * T + y * L + _ * P + b * k, this
                }
                multiplyScalar(t) {
                    const e = this.elements;
                    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                }
                determinant() {
                    const t = this.elements,
                        e = t[0],
                        n = t[4],
                        r = t[8],
                        i = t[12],
                        o = t[1],
                        a = t[5],
                        s = t[9],
                        c = t[13],
                        l = t[2],
                        u = t[6],
                        h = t[10],
                        d = t[14],
                        p = t[3],
                        f = t[7],
                        m = t[11],
                        g = t[15];
                    return p * (+i * s * u - r * c * u - i * a * h + n * c * h + r * a * d - n * s * d) + f * (+e * s * d - e * c * h + i * o * h - r * o * d + r * c * l - i * s * l) + m * (+e * c * u - e * a * d - i * o * u + n * o * d + i * a * l - n * c * l) + g * (-r * a * l - e * s * u + e * a * h + r * o * u - n * o * h + n * s * l)
                }
                transpose() {
                    const t = this.elements;
                    let e;
                    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                }
                setPosition(t, e, n) {
                    const r = this.elements;
                    return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this
                }
                getInverse(t, e) {
                    void 0 !== e && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
                    const n = this.elements,
                        r = t.elements,
                        i = r[0],
                        o = r[1],
                        a = r[2],
                        s = r[3],
                        c = r[4],
                        l = r[5],
                        u = r[6],
                        h = r[7],
                        d = r[8],
                        p = r[9],
                        f = r[10],
                        m = r[11],
                        g = r[12],
                        v = r[13],
                        y = r[14],
                        _ = r[15],
                        b = p * y * h - v * f * h + v * u * m - l * y * m - p * u * _ + l * f * _,
                        x = g * f * h - d * y * h - g * u * m + c * y * m + d * u * _ - c * f * _,
                        w = d * v * h - g * p * h + g * l * m - c * v * m - d * l * _ + c * p * _,
                        M = g * p * u - d * v * u - g * l * f + c * v * f + d * l * y - c * p * y,
                        T = i * b + o * x + a * w + s * M;
                    if (0 === T) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const S = 1 / T;
                    return n[0] = b * S, n[1] = (v * f * s - p * y * s - v * a * m + o * y * m + p * a * _ - o * f * _) * S, n[2] = (l * y * s - v * u * s + v * a * h - o * y * h - l * a * _ + o * u * _) * S, n[3] = (p * u * s - l * f * s - p * a * h + o * f * h + l * a * m - o * u * m) * S, n[4] = x * S, n[5] = (d * y * s - g * f * s + g * a * m - i * y * m - d * a * _ + i * f * _) * S, n[6] = (g * u * s - c * y * s - g * a * h + i * y * h + c * a * _ - i * u * _) * S, n[7] = (c * f * s - d * u * s + d * a * h - i * f * h - c * a * m + i * u * m) * S, n[8] = w * S, n[9] = (g * p * s - d * v * s - g * o * m + i * v * m + d * o * _ - i * p * _) * S, n[10] = (c * v * s - g * l * s + g * o * h - i * v * h - c * o * _ + i * l * _) * S, n[11] = (d * l * s - c * p * s - d * o * h + i * p * h + c * o * m - i * l * m) * S, n[12] = M * S, n[13] = (d * v * a - g * p * a + g * o * f - i * v * f - d * o * y + i * p * y) * S, n[14] = (g * l * a - c * v * a - g * o * u + i * v * u + c * o * y - i * l * y) * S, n[15] = (c * p * a - d * l * a + d * o * u - i * p * u - c * o * f + i * l * f) * S, this
                }
                scale(t) {
                    const e = this.elements,
                        n = t.x,
                        r = t.y,
                        i = t.z;
                    return e[0] *= n, e[4] *= r, e[8] *= i, e[1] *= n, e[5] *= r, e[9] *= i, e[2] *= n, e[6] *= r, e[10] *= i, e[3] *= n, e[7] *= r, e[11] *= i, this
                }
                getMaxScaleOnAxis() {
                    const t = this.elements,
                        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                        n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                        r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, n, r))
                }
                makeTranslation(t, e, n) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
                }
                makeRotationX(t) {
                    const e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
                }
                makeRotationY(t) {
                    const e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
                }
                makeRotationZ(t) {
                    const e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                makeRotationAxis(t, e) {
                    const n = Math.cos(e),
                        r = Math.sin(e),
                        i = 1 - n,
                        o = t.x,
                        a = t.y,
                        s = t.z,
                        c = i * o,
                        l = i * a;
                    return this.set(c * o + n, c * a - r * s, c * s + r * a, 0, c * a + r * s, l * a + n, l * s - r * o, 0, c * s - r * a, l * s + r * o, i * s * s + n, 0, 0, 0, 0, 1), this
                }
                makeScale(t, e, n) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                }
                makeShear(t, e, n) {
                    return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
                }
                compose(t, e, n) {
                    const r = this.elements,
                        i = e._x,
                        o = e._y,
                        a = e._z,
                        s = e._w,
                        c = i + i,
                        l = o + o,
                        u = a + a,
                        h = i * c,
                        d = i * l,
                        p = i * u,
                        f = o * l,
                        m = o * u,
                        g = a * u,
                        v = s * c,
                        y = s * l,
                        _ = s * u,
                        b = n.x,
                        x = n.y,
                        w = n.z;
                    return r[0] = (1 - (f + g)) * b, r[1] = (d + _) * b, r[2] = (p - y) * b, r[3] = 0, r[4] = (d - _) * x, r[5] = (1 - (h + g)) * x, r[6] = (m + v) * x, r[7] = 0, r[8] = (p + y) * w, r[9] = (m - v) * w, r[10] = (1 - (h + f)) * w, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this
                }
                decompose(t, e, n) {
                    const r = this.elements;
                    let i = $n.set(r[0], r[1], r[2]).length();
                    const o = $n.set(r[4], r[5], r[6]).length(),
                        a = $n.set(r[8], r[9], r[10]).length(),
                        s = this.determinant();
                    s < 0 && (i = -i), t.x = r[12], t.y = r[13], t.z = r[14], Zn.copy(this);
                    const c = 1 / i,
                        l = 1 / o,
                        u = 1 / a;
                    return Zn.elements[0] *= c, Zn.elements[1] *= c, Zn.elements[2] *= c, Zn.elements[4] *= l, Zn.elements[5] *= l, Zn.elements[6] *= l, Zn.elements[8] *= u, Zn.elements[9] *= u, Zn.elements[10] *= u, e.setFromRotationMatrix(Zn), n.x = i, n.y = o, n.z = a, this
                }
                makePerspective(t, e, n, r, i, o) {
                    void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    const a = this.elements,
                        s = 2 * i / (e - t),
                        c = 2 * i / (n - r),
                        l = (e + t) / (e - t),
                        u = (n + r) / (n - r),
                        h = -(o + i) / (o - i),
                        d = -2 * o * i / (o - i);
                    return a[0] = s, a[4] = 0, a[8] = l, a[12] = 0, a[1] = 0, a[5] = c, a[9] = u, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = h, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
                }
                makeOrthographic(t, e, n, r, i, o) {
                    const a = this.elements,
                        s = 1 / (e - t),
                        c = 1 / (n - r),
                        l = 1 / (o - i),
                        u = (e + t) * s,
                        h = (n + r) * c,
                        d = (o + i) * l;
                    return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -u, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -h, a[2] = 0, a[6] = 0, a[10] = -2 * l, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
                }
                equals(t) {
                    const e = this.elements,
                        n = t.elements;
                    for (let r = 0; r < 16; r++)
                        if (e[r] !== n[r]) return !1;
                    return !0
                }
                fromArray(t, e = 0) {
                    for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
                    return this
                }
                toArray(t = [], e = 0) {
                    const n = this.elements;
                    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
                }
            }
            const $n = new bn,
                Zn = new Yn,
                Jn = new bn(0, 0, 0),
                Kn = new bn(1, 1, 1),
                Qn = new bn,
                tr = new bn,
                er = new bn;
            class nr {
                constructor(t = 0, e = 0, n = 0, r = nr.DefaultOrder) {
                    Object.defineProperty(this, "isEuler", {
                        value: !0
                    }), this._x = t, this._y = e, this._z = n, this._order = r
                }
                get x() {
                    return this._x
                }
                set x(t) {
                    this._x = t, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(t) {
                    this._y = t, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(t) {
                    this._z = t, this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(t) {
                    this._order = t, this._onChangeCallback()
                }
                set(t, e, n, r) {
                    return this._x = t, this._y = e, this._z = n, this._order = r || this._order, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                }
                copy(t) {
                    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
                }
                setFromRotationMatrix(t, e, n) {
                    const r = ln.clamp,
                        i = t.elements,
                        o = i[0],
                        a = i[4],
                        s = i[8],
                        c = i[1],
                        l = i[5],
                        u = i[9],
                        h = i[2],
                        d = i[6],
                        p = i[10];
                    switch (e = e || this._order, e) {
                        case "XYZ":
                            this._y = Math.asin(r(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(d, l), this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-r(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, o), this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(r(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, o));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-r(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, l));
                            break;
                        case "YZX":
                            this._z = Math.asin(r(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, o)) : (this._x = 0, this._y = Math.atan2(s, p));
                            break;
                        case "XZY":
                            this._z = Math.asin(-r(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-u, p), this._y = 0);
                            break;
                        default:
                            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                    }
                    return this._order = e, !1 !== n && this._onChangeCallback(), this
                }
                setFromQuaternion(t, e, n) {
                    return rr.makeRotationFromQuaternion(t), this.setFromRotationMatrix(rr, e, n)
                }
                setFromVector3(t, e) {
                    return this.set(t.x, t.y, t.z, e || this._order)
                }
                reorder(t) {
                    return ir.setFromEuler(this), this.setFromQuaternion(ir, t)
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                }
                fromArray(t) {
                    return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                }
                toVector3(t) {
                    return t ? t.set(this._x, this._y, this._z) : new bn(this._x, this._y, this._z)
                }
                _onChange(t) {
                    return this._onChangeCallback = t, this
                }
                _onChangeCallback() {}
            }
            nr.DefaultOrder = "XYZ", nr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
            const rr = new Yn,
                ir = new _n;
            class or {
                constructor() {
                    this.mask = 1
                }
                set(t) {
                    this.mask = 1 << t | 0
                }
                enable(t) {
                    this.mask |= 1 << t | 0
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(t) {
                    this.mask ^= 1 << t | 0
                }
                disable(t) {
                    this.mask &= ~(1 << t | 0)
                }
                disableAll() {
                    this.mask = 0
                }
                test(t) {
                    return 0 !== (this.mask & t.mask)
                }
            }
            let ar = 0;
            const sr = new bn,
                cr = new _n,
                lr = new Yn,
                ur = new bn,
                hr = new bn,
                dr = new bn,
                pr = new _n,
                fr = new bn(1, 0, 0),
                mr = new bn(0, 1, 0),
                gr = new bn(0, 0, 1),
                vr = {
                    type: "added"
                },
                yr = {
                    type: "removed"
                };

            function _r() {
                Object.defineProperty(this, "id", {
                    value: ar++
                }), this.uuid = ln.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = _r.DefaultUp.clone();
                const t = new bn,
                    e = new nr,
                    n = new _n,
                    r = new bn(1, 1, 1);

                function i() {
                    n.setFromEuler(e, !1)
                }

                function o() {
                    e.setFromQuaternion(n, void 0, !1)
                }
                e._onChange(i), n._onChange(o), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: r
                    },
                    modelViewMatrix: {
                        value: new Yn
                    },
                    normalMatrix: {
                        value: new hn
                    }
                }), this.matrix = new Yn, this.matrixWorld = new Yn, this.matrixAutoUpdate = _r.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new or, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }
            _r.DefaultUp = new bn(0, 1, 0), _r.DefaultMatrixAutoUpdate = !0, _r.prototype = Object.assign(Object.create(an.prototype), {
                constructor: _r,
                isObject3D: !0,
                onBeforeRender: function() {},
                onAfterRender: function() {},
                applyMatrix4: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function(t) {
                    return this.quaternion.premultiply(t), this
                },
                setRotationFromAxisAngle: function(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                },
                setRotationFromEuler: function(t) {
                    this.quaternion.setFromEuler(t, !0)
                },
                setRotationFromMatrix: function(t) {
                    this.quaternion.setFromRotationMatrix(t)
                },
                setRotationFromQuaternion: function(t) {
                    this.quaternion.copy(t)
                },
                rotateOnAxis: function(t, e) {
                    return cr.setFromAxisAngle(t, e), this.quaternion.multiply(cr), this
                },
                rotateOnWorldAxis: function(t, e) {
                    return cr.setFromAxisAngle(t, e), this.quaternion.premultiply(cr), this
                },
                rotateX: function(t) {
                    return this.rotateOnAxis(fr, t)
                },
                rotateY: function(t) {
                    return this.rotateOnAxis(mr, t)
                },
                rotateZ: function(t) {
                    return this.rotateOnAxis(gr, t)
                },
                translateOnAxis: function(t, e) {
                    return sr.copy(t).applyQuaternion(this.quaternion), this.position.add(sr.multiplyScalar(e)), this
                },
                translateX: function(t) {
                    return this.translateOnAxis(fr, t)
                },
                translateY: function(t) {
                    return this.translateOnAxis(mr, t)
                },
                translateZ: function(t) {
                    return this.translateOnAxis(gr, t)
                },
                localToWorld: function(t) {
                    return t.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function(t) {
                    return t.applyMatrix4(lr.getInverse(this.matrixWorld))
                },
                lookAt: function(t, e, n) {
                    t.isVector3 ? ur.copy(t) : ur.set(t, e, n);
                    const r = this.parent;
                    this.updateWorldMatrix(!0, !1), hr.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? lr.lookAt(hr, ur, this.up) : lr.lookAt(ur, hr, this.up), this.quaternion.setFromRotationMatrix(lr), r && (lr.extractRotation(r.matrixWorld), cr.setFromRotationMatrix(lr), this.quaternion.premultiply(cr.inverse()))
                },
                add: function(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this
                    }
                    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(vr)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                },
                remove: function(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                        return this
                    }
                    const e = this.children.indexOf(t);
                    return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(yr)), this
                },
                clear: function() {
                    for (let t = 0; t < this.children.length; t++) {
                        const e = this.children[t];
                        e.parent = null, e.dispatchEvent(yr)
                    }
                    return this.children.length = 0, this
                },
                attach: function(t) {
                    return this.updateWorldMatrix(!0, !1), lr.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), lr.multiply(t.parent.matrixWorld)), t.applyMatrix4(lr), t.updateWorldMatrix(!1, !1), this.add(t), this
                },
                getObjectById: function(t) {
                    return this.getObjectByProperty("id", t)
                },
                getObjectByName: function(t) {
                    return this.getObjectByProperty("name", t)
                },
                getObjectByProperty: function(t, e) {
                    if (this[t] === e) return this;
                    for (let n = 0, r = this.children.length; n < r; n++) {
                        const r = this.children[n],
                            i = r.getObjectByProperty(t, e);
                        if (void 0 !== i) return i
                    }
                },
                getWorldPosition: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new bn), this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new _n), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(hr, t, dr), t
                },
                getWorldScale: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new bn), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(hr, pr, t), t
                },
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new bn), this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize()
                },
                raycast: function() {},
                traverse: function(t) {
                    t(this);
                    const e = this.children;
                    for (let n = 0, r = e.length; n < r; n++) e[n].traverse(t)
                },
                traverseVisible: function(t) {
                    if (!1 === this.visible) return;
                    t(this);
                    const e = this.children;
                    for (let n = 0, r = e.length; n < r; n++) e[n].traverseVisible(t)
                },
                traverseAncestors: function(t) {
                    const e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                    const e = this.children;
                    for (let n = 0, r = e.length; n < r; n++) e[n].updateMatrixWorld(t)
                },
                updateWorldMatrix: function(t, e) {
                    const n = this.parent;
                    if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                        const t = this.children;
                        for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0)
                    }
                },
                toJSON: function(t) {
                    const e = void 0 === t || "string" === typeof t,
                        n = {};
                    e && (t = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {}
                    }, n.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    const r = {};

                    function i(e, n) {
                        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                    }
                    if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                        r.geometry = i(t.geometries, this.geometry);
                        const e = this.geometry.parameters;
                        if (void 0 !== e && void 0 !== e.shapes) {
                            const n = e.shapes;
                            if (Array.isArray(n))
                                for (let e = 0, r = n.length; e < r; e++) {
                                    const r = n[e];
                                    i(t.shapes, r)
                                } else i(t.shapes, n)
                        }
                    }
                    if (void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            const e = [];
                            for (let n = 0, r = this.material.length; n < r; n++) e.push(i(t.materials, this.material[n]));
                            r.material = e
                        } else r.material = i(t.materials, this.material);
                    if (this.children.length > 0) {
                        r.children = [];
                        for (let e = 0; e < this.children.length; e++) r.children.push(this.children[e].toJSON(t).object)
                    }
                    if (e) {
                        const e = o(t.geometries),
                            r = o(t.materials),
                            i = o(t.textures),
                            a = o(t.images),
                            s = o(t.shapes);
                        e.length > 0 && (n.geometries = e), r.length > 0 && (n.materials = r), i.length > 0 && (n.textures = i), a.length > 0 && (n.images = a), s.length > 0 && (n.shapes = s)
                    }
                    return n.object = r, n;

                    function o(t) {
                        const e = [];
                        for (const n in t) {
                            const r = t[n];
                            delete r.metadata, e.push(r)
                        }
                        return e
                    }
                },
                clone: function(t) {
                    return (new this.constructor).copy(this, t)
                },
                copy: function(t, e) {
                    if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                        for (let n = 0; n < t.children.length; n++) {
                            const e = t.children[n];
                            this.add(e.clone())
                        }
                    return this
                }
            });
            const br = new bn,
                xr = new bn,
                wr = new hn;
            class Mr {
                constructor(t, e) {
                    Object.defineProperty(this, "isPlane", {
                        value: !0
                    }), this.normal = void 0 !== t ? t : new bn(1, 0, 0), this.constant = void 0 !== e ? e : 0
                }
                set(t, e) {
                    return this.normal.copy(t), this.constant = e, this
                }
                setComponents(t, e, n, r) {
                    return this.normal.set(t, e, n), this.constant = r, this
                }
                setFromNormalAndCoplanarPoint(t, e) {
                    return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                }
                setFromCoplanarPoints(t, e, n) {
                    const r = br.subVectors(n, e).cross(xr.subVectors(t, e)).normalize();
                    return this.setFromNormalAndCoplanarPoint(r, t), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.normal.copy(t.normal), this.constant = t.constant, this
                }
                normalize() {
                    const t = 1 / this.normal.length();
                    return this.normal.multiplyScalar(t), this.constant *= t, this
                }
                negate() {
                    return this.constant *= -1, this.normal.negate(), this
                }
                distanceToPoint(t) {
                    return this.normal.dot(t) + this.constant
                }
                distanceToSphere(t) {
                    return this.distanceToPoint(t.center) - t.radius
                }
                projectPoint(t, e) {
                    return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new bn), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                }
                intersectLine(t, e) {
                    void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new bn);
                    const n = t.delta(br),
                        r = this.normal.dot(n);
                    if (0 === r) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
                    const i = -(t.start.dot(this.normal) + this.constant) / r;
                    return i < 0 || i > 1 ? void 0 : e.copy(n).multiplyScalar(i).add(t.start)
                }
                intersectsLine(t) {
                    const e = this.distanceToPoint(t.start),
                        n = this.distanceToPoint(t.end);
                    return e < 0 && n > 0 || n < 0 && e > 0
                }
                intersectsBox(t) {
                    return t.intersectsPlane(this)
                }
                intersectsSphere(t) {
                    return t.intersectsPlane(this)
                }
                coplanarPoint(t) {
                    return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new bn), t.copy(this.normal).multiplyScalar(-this.constant)
                }
                applyMatrix4(t, e) {
                    const n = e || wr.getNormalMatrix(t),
                        r = this.coplanarPoint(br).applyMatrix4(t),
                        i = this.normal.applyMatrix3(n).normalize();
                    return this.constant = -r.dot(i), this
                }
                translate(t) {
                    return this.constant -= t.dot(this.normal), this
                }
                equals(t) {
                    return t.normal.equals(this.normal) && t.constant === this.constant
                }
            }
            const Tr = new bn,
                Sr = new bn,
                Er = new bn,
                Ar = new bn,
                Lr = new bn,
                Rr = new bn,
                Cr = new bn,
                Or = new bn,
                Pr = new bn,
                Ir = new bn;
            class Nr {
                constructor(t, e, n) {
                    this.a = void 0 !== t ? t : new bn, this.b = void 0 !== e ? e : new bn, this.c = void 0 !== n ? n : new bn
                }
                static getNormal(t, e, n, r) {
                    void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new bn), r.subVectors(n, e), Tr.subVectors(t, e), r.cross(Tr);
                    const i = r.lengthSq();
                    return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
                }
                static getBarycoord(t, e, n, r, i) {
                    Tr.subVectors(r, e), Sr.subVectors(n, e), Er.subVectors(t, e);
                    const o = Tr.dot(Tr),
                        a = Tr.dot(Sr),
                        s = Tr.dot(Er),
                        c = Sr.dot(Sr),
                        l = Sr.dot(Er),
                        u = o * c - a * a;
                    if (void 0 === i && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), i = new bn), 0 === u) return i.set(-2, -1, -1);
                    const h = 1 / u,
                        d = (c * s - a * l) * h,
                        p = (o * l - a * s) * h;
                    return i.set(1 - d - p, p, d)
                }
                static containsPoint(t, e, n, r) {
                    return this.getBarycoord(t, e, n, r, Ar), Ar.x >= 0 && Ar.y >= 0 && Ar.x + Ar.y <= 1
                }
                static getUV(t, e, n, r, i, o, a, s) {
                    return this.getBarycoord(t, e, n, r, Ar), s.set(0, 0), s.addScaledVector(i, Ar.x), s.addScaledVector(o, Ar.y), s.addScaledVector(a, Ar.z), s
                }
                static isFrontFacing(t, e, n, r) {
                    return Tr.subVectors(n, e), Sr.subVectors(t, e), Tr.cross(Sr).dot(r) < 0
                }
                set(t, e, n) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                }
                setFromPointsAndIndices(t, e, n, r) {
                    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                }
                getArea() {
                    return Tr.subVectors(this.c, this.b), Sr.subVectors(this.a, this.b), .5 * Tr.cross(Sr).length()
                }
                getMidpoint(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new bn), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(t) {
                    return Nr.getNormal(this.a, this.b, this.c, t)
                }
                getPlane(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new Mr), t.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(t, e) {
                    return Nr.getBarycoord(t, this.a, this.b, this.c, e)
                }
                getUV(t, e, n, r, i) {
                    return Nr.getUV(t, this.a, this.b, this.c, e, n, r, i)
                }
                containsPoint(t) {
                    return Nr.containsPoint(t, this.a, this.b, this.c)
                }
                isFrontFacing(t) {
                    return Nr.isFrontFacing(this.a, this.b, this.c, t)
                }
                intersectsBox(t) {
                    return t.intersectsTriangle(this)
                }
                closestPointToPoint(t, e) {
                    void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new bn);
                    const n = this.a,
                        r = this.b,
                        i = this.c;
                    let o, a;
                    Lr.subVectors(r, n), Rr.subVectors(i, n), Or.subVectors(t, n);
                    const s = Lr.dot(Or),
                        c = Rr.dot(Or);
                    if (s <= 0 && c <= 0) return e.copy(n);
                    Pr.subVectors(t, r);
                    const l = Lr.dot(Pr),
                        u = Rr.dot(Pr);
                    if (l >= 0 && u <= l) return e.copy(r);
                    const h = s * u - l * c;
                    if (h <= 0 && s >= 0 && l <= 0) return o = s / (s - l), e.copy(n).addScaledVector(Lr, o);
                    Ir.subVectors(t, i);
                    const d = Lr.dot(Ir),
                        p = Rr.dot(Ir);
                    if (p >= 0 && d <= p) return e.copy(i);
                    const f = d * c - s * p;
                    if (f <= 0 && c >= 0 && p <= 0) return a = c / (c - p), e.copy(n).addScaledVector(Rr, a);
                    const m = l * p - d * u;
                    if (m <= 0 && u - l >= 0 && d - p >= 0) return Cr.subVectors(i, r), a = (u - l) / (u - l + (d - p)), e.copy(r).addScaledVector(Cr, a);
                    const g = 1 / (m + f + h);
                    return o = f * g, a = h * g, e.copy(n).addScaledVector(Lr, o).addScaledVector(Rr, a)
                }
                equals(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                }
            }
            const Dr = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                kr = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                Fr = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function Br(t, e, n) {
                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
            }

            function Ur(t) {
                return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
            }

            function Hr(t) {
                return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
            }
            class zr {
                constructor(t, e, n) {
                    return Object.defineProperty(this, "isColor", {
                        value: !0
                    }), void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
                }
                set(t) {
                    return t && t.isColor ? this.copy(t) : "number" === typeof t ? this.setHex(t) : "string" === typeof t && this.setStyle(t), this
                }
                setScalar(t) {
                    return this.r = t, this.g = t, this.b = t, this
                }
                setHex(t) {
                    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                }
                setRGB(t, e, n) {
                    return this.r = t, this.g = e, this.b = n, this
                }
                setHSL(t, e, n) {
                    if (t = ln.euclideanModulo(t, 1), e = ln.clamp(e, 0, 1), n = ln.clamp(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                    else {
                        const r = n <= .5 ? n * (1 + e) : n + e - n * e,
                            i = 2 * n - r;
                        this.r = Br(i, r, t + 1 / 3), this.g = Br(i, r, t), this.b = Br(i, r, t - 1 / 3)
                    }
                    return this
                }
                setStyle(t) {
                    function e(e) {
                        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                    }
                    let n;
                    if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                        let t;
                        const r = n[1],
                            i = n[2];
                        switch (r) {
                            case "rgb":
                            case "rgba":
                                if (t = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[5]), this;
                                if (t = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (t = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) {
                                    const n = parseFloat(t[1]) / 360,
                                        r = parseInt(t[2], 10) / 100,
                                        i = parseInt(t[3], 10) / 100;
                                    return e(t[5]), this.setHSL(n, r, i)
                                }
                                break
                        }
                    } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                        const t = n[1],
                            e = t.length;
                        if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                        if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                    }
                    return t && t.length > 0 ? this.setColorName(t) : this
                }
                setColorName(t) {
                    const e = Dr[t];
                    return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b)
                }
                copy(t) {
                    return this.r = t.r, this.g = t.g, this.b = t.b, this
                }
                copyGammaToLinear(t, e) {
                    return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
                }
                copyLinearToGamma(t, e) {
                    void 0 === e && (e = 2);
                    const n = e > 0 ? 1 / e : 1;
                    return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
                }
                convertGammaToLinear(t) {
                    return this.copyGammaToLinear(this, t), this
                }
                convertLinearToGamma(t) {
                    return this.copyLinearToGamma(this, t), this
                }
                copySRGBToLinear(t) {
                    return this.r = Ur(t.r), this.g = Ur(t.g), this.b = Ur(t.b), this
                }
                copyLinearToSRGB(t) {
                    return this.r = Hr(t.r), this.g = Hr(t.g), this.b = Hr(t.b), this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this
                }
                getHex() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                }
                getHexString() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                }
                getHSL(t) {
                    void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                        h: 0,
                        s: 0,
                        l: 0
                    });
                    const e = this.r,
                        n = this.g,
                        r = this.b,
                        i = Math.max(e, n, r),
                        o = Math.min(e, n, r);
                    let a, s;
                    const c = (o + i) / 2;
                    if (o === i) a = 0, s = 0;
                    else {
                        const t = i - o;
                        switch (s = c <= .5 ? t / (i + o) : t / (2 - i - o), i) {
                            case e:
                                a = (n - r) / t + (n < r ? 6 : 0);
                                break;
                            case n:
                                a = (r - e) / t + 2;
                                break;
                            case r:
                                a = (e - n) / t + 4;
                                break
                        }
                        a /= 6
                    }
                    return t.h = a, t.s = s, t.l = c, t
                }
                getStyle() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                }
                offsetHSL(t, e, n) {
                    return this.getHSL(kr), kr.h += t, kr.s += e, kr.l += n, this.setHSL(kr.h, kr.s, kr.l), this
                }
                add(t) {
                    return this.r += t.r, this.g += t.g, this.b += t.b, this
                }
                addColors(t, e) {
                    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                }
                addScalar(t) {
                    return this.r += t, this.g += t, this.b += t, this
                }
                sub(t) {
                    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                }
                multiply(t) {
                    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                }
                multiplyScalar(t) {
                    return this.r *= t, this.g *= t, this.b *= t, this
                }
                lerp(t, e) {
                    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                }
                lerpHSL(t, e) {
                    this.getHSL(kr), t.getHSL(Fr);
                    const n = ln.lerp(kr.h, Fr.h, e),
                        r = ln.lerp(kr.s, Fr.s, e),
                        i = ln.lerp(kr.l, Fr.l, e);
                    return this.setHSL(n, r, i), this
                }
                equals(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b
                }
                fromArray(t, e = 0) {
                    return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                }
                fromBufferAttribute(t, e) {
                    return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                }
                toJSON() {
                    return this.getHex()
                }
            }
            zr.NAMES = Dr, zr.prototype.r = 1, zr.prototype.g = 1, zr.prototype.b = 1;
            class jr {
                constructor(t, e, n, r, i, o) {
                    this.a = t, this.b = e, this.c = n, this.normal = r && r.isVector3 ? r : new bn, this.vertexNormals = Array.isArray(r) ? r : [], this.color = i && i.isColor ? i : new zr, this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = void 0 !== o ? o : 0
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                    for (let e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                    for (let e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                    return this
                }
            }
            let Gr = 0;

            function Vr() {
                Object.defineProperty(this, "id", {
                    value: Gr++
                }), this.uuid = ln.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = v, this.side = d, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = O, this.blendDst = P, this.blendEquation = w, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = z, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = en, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = tn, this.stencilZFail = tn, this.stencilZPass = tn, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
            }

            function Wr(t) {
                Vr.call(this), this.type = "MeshBasicMaterial", this.color = new zr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = X, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t)
            }
            Vr.prototype = Object.assign(Object.create(an.prototype), {
                constructor: Vr,
                isMaterial: !0,
                onBeforeCompile: function() {},
                customProgramCacheKey: function() {
                    return this.onBeforeCompile.toString()
                },
                setValues: function(t) {
                    if (void 0 !== t)
                        for (const e in t) {
                            const n = t[e];
                            if (void 0 === n) {
                                console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                                continue
                            }
                            if ("shading" === e) {
                                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === m;
                                continue
                            }
                            const r = this[e];
                            void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                        }
                },
                toJSON: function(t) {
                    const e = void 0 === t || "string" === typeof t;
                    e && (t = {
                        textures: {},
                        images: {}
                    });
                    const n = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function r(t) {
                        const e = [];
                        for (const n in t) {
                            const r = t[n];
                            delete r.metadata, e.push(r)
                        }
                        return e
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== v && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== d && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                        const e = r(t.textures),
                            i = r(t.images);
                        e.length > 0 && (n.textures = e), i.length > 0 && (n.images = i)
                    }
                    return n
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                    const e = t.clippingPlanes;
                    let n = null;
                    if (null !== e) {
                        const t = e.length;
                        n = new Array(t);
                        for (let r = 0; r !== t; ++r) n[r] = e[r].clone()
                    }
                    return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.defineProperty(Vr.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Wr.prototype = Object.create(Vr.prototype), Wr.prototype.constructor = Wr, Wr.prototype.isMeshBasicMaterial = !0, Wr.prototype.copy = function(t) {
                return Vr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
            };
            const Xr = new bn,
                qr = new un;

            function Yr(t, e, n) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = nn, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function $r(t, e, n) {
                Yr.call(this, new Int8Array(t), e, n)
            }

            function Zr(t, e, n) {
                Yr.call(this, new Uint8Array(t), e, n)
            }

            function Jr(t, e, n) {
                Yr.call(this, new Uint8ClampedArray(t), e, n)
            }

            function Kr(t, e, n) {
                Yr.call(this, new Int16Array(t), e, n)
            }

            function Qr(t, e, n) {
                Yr.call(this, new Uint16Array(t), e, n)
            }

            function ti(t, e, n) {
                Yr.call(this, new Int32Array(t), e, n)
            }

            function ei(t, e, n) {
                Yr.call(this, new Uint32Array(t), e, n)
            }

            function ni(t, e, n) {
                Yr.call(this, new Float32Array(t), e, n)
            }

            function ri(t, e, n) {
                Yr.call(this, new Float64Array(t), e, n)
            }
            Object.defineProperty(Yr.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(Yr.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function() {},
                setUsage: function(t) {
                    return this.usage = t, this
                },
                copy: function(t) {
                    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
                },
                copyAt: function(t, e, n) {
                    t *= this.itemSize, n *= e.itemSize;
                    for (let r = 0, i = this.itemSize; r < i; r++) this.array[t + r] = e.array[n + r];
                    return this
                },
                copyArray: function(t) {
                    return this.array.set(t), this
                },
                copyColorsArray: function(t) {
                    const e = this.array;
                    let n = 0;
                    for (let r = 0, i = t.length; r < i; r++) {
                        let i = t[r];
                        void 0 === i && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), i = new zr), e[n++] = i.r, e[n++] = i.g, e[n++] = i.b
                    }
                    return this
                },
                copyVector2sArray: function(t) {
                    const e = this.array;
                    let n = 0;
                    for (let r = 0, i = t.length; r < i; r++) {
                        let i = t[r];
                        void 0 === i && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), i = new un), e[n++] = i.x, e[n++] = i.y
                    }
                    return this
                },
                copyVector3sArray: function(t) {
                    const e = this.array;
                    let n = 0;
                    for (let r = 0, i = t.length; r < i; r++) {
                        let i = t[r];
                        void 0 === i && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), i = new bn), e[n++] = i.x, e[n++] = i.y, e[n++] = i.z
                    }
                    return this
                },
                copyVector4sArray: function(t) {
                    const e = this.array;
                    let n = 0;
                    for (let r = 0, i = t.length; r < i; r++) {
                        let i = t[r];
                        void 0 === i && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), i = new gn), e[n++] = i.x, e[n++] = i.y, e[n++] = i.z, e[n++] = i.w
                    }
                    return this
                },
                applyMatrix3: function(t) {
                    if (2 === this.itemSize)
                        for (let e = 0, n = this.count; e < n; e++) qr.fromBufferAttribute(this, e), qr.applyMatrix3(t), this.setXY(e, qr.x, qr.y);
                    else if (3 === this.itemSize)
                        for (let e = 0, n = this.count; e < n; e++) Xr.fromBufferAttribute(this, e), Xr.applyMatrix3(t), this.setXYZ(e, Xr.x, Xr.y, Xr.z);
                    return this
                },
                applyMatrix4: function(t) {
                    for (let e = 0, n = this.count; e < n; e++) Xr.x = this.getX(e), Xr.y = this.getY(e), Xr.z = this.getZ(e), Xr.applyMatrix4(t), this.setXYZ(e, Xr.x, Xr.y, Xr.z);
                    return this
                },
                applyNormalMatrix: function(t) {
                    for (let e = 0, n = this.count; e < n; e++) Xr.x = this.getX(e), Xr.y = this.getY(e), Xr.z = this.getZ(e), Xr.applyNormalMatrix(t), this.setXYZ(e, Xr.x, Xr.y, Xr.z);
                    return this
                },
                transformDirection: function(t) {
                    for (let e = 0, n = this.count; e < n; e++) Xr.x = this.getX(e), Xr.y = this.getY(e), Xr.z = this.getZ(e), Xr.transformDirection(t), this.setXYZ(e, Xr.x, Xr.y, Xr.z);
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                getX: function(t) {
                    return this.array[t * this.itemSize]
                },
                setX: function(t, e) {
                    return this.array[t * this.itemSize] = e, this
                },
                getY: function(t) {
                    return this.array[t * this.itemSize + 1]
                },
                setY: function(t, e) {
                    return this.array[t * this.itemSize + 1] = e, this
                },
                getZ: function(t) {
                    return this.array[t * this.itemSize + 2]
                },
                setZ: function(t, e) {
                    return this.array[t * this.itemSize + 2] = e, this
                },
                getW: function(t) {
                    return this.array[t * this.itemSize + 3]
                },
                setW: function(t, e) {
                    return this.array[t * this.itemSize + 3] = e, this
                },
                setXY: function(t, e, n) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
                },
                setXYZ: function(t, e, n, r) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this
                },
                setXYZW: function(t, e, n, r, i) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = i, this
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                },
                clone: function() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                },
                toJSON: function() {
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.prototype.slice.call(this.array),
                        normalized: this.normalized
                    }
                }
            }), $r.prototype = Object.create(Yr.prototype), $r.prototype.constructor = $r, Zr.prototype = Object.create(Yr.prototype), Zr.prototype.constructor = Zr, Jr.prototype = Object.create(Yr.prototype), Jr.prototype.constructor = Jr, Kr.prototype = Object.create(Yr.prototype), Kr.prototype.constructor = Kr, Qr.prototype = Object.create(Yr.prototype), Qr.prototype.constructor = Qr, ti.prototype = Object.create(Yr.prototype), ti.prototype.constructor = ti, ei.prototype = Object.create(Yr.prototype), ei.prototype.constructor = ei, ni.prototype = Object.create(Yr.prototype), ni.prototype.constructor = ni, ri.prototype = Object.create(Yr.prototype), ri.prototype.constructor = ri;
            class ii {
                constructor() {
                    this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
                }
                computeGroups(t) {
                    const e = [];
                    let n, r, i = void 0;
                    const o = t.faces;
                    for (r = 0; r < o.length; r++) {
                        const t = o[r];
                        t.materialIndex !== i && (i = t.materialIndex, void 0 !== n && (n.count = 3 * r - n.start, e.push(n)), n = {
                            start: 3 * r,
                            materialIndex: i
                        })
                    }
                    void 0 !== n && (n.count = 3 * r - n.start, e.push(n)), this.groups = e
                }
                fromGeometry(t) {
                    const e = t.faces,
                        n = t.vertices,
                        r = t.faceVertexUvs,
                        i = r[0] && r[0].length > 0,
                        o = r[1] && r[1].length > 0,
                        a = t.morphTargets,
                        s = a.length;
                    let c;
                    if (s > 0) {
                        c = [];
                        for (let t = 0; t < s; t++) c[t] = {
                            name: a[t].name,
                            data: []
                        };
                        this.morphTargets.position = c
                    }
                    const l = t.morphNormals,
                        u = l.length;
                    let h;
                    if (u > 0) {
                        h = [];
                        for (let t = 0; t < u; t++) h[t] = {
                            name: l[t].name,
                            data: []
                        };
                        this.morphTargets.normal = h
                    }
                    const d = t.skinIndices,
                        p = t.skinWeights,
                        f = d.length === n.length,
                        m = p.length === n.length;
                    n.length > 0 && 0 === e.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                    for (let g = 0; g < e.length; g++) {
                        const t = e[g];
                        this.vertices.push(n[t.a], n[t.b], n[t.c]);
                        const v = t.vertexNormals;
                        if (3 === v.length) this.normals.push(v[0], v[1], v[2]);
                        else {
                            const e = t.normal;
                            this.normals.push(e, e, e)
                        }
                        const y = t.vertexColors;
                        if (3 === y.length) this.colors.push(y[0], y[1], y[2]);
                        else {
                            const e = t.color;
                            this.colors.push(e, e, e)
                        }
                        if (!0 === i) {
                            const t = r[0][g];
                            void 0 !== t ? this.uvs.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", g), this.uvs.push(new un, new un, new un))
                        }
                        if (!0 === o) {
                            const t = r[1][g];
                            void 0 !== t ? this.uvs2.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", g), this.uvs2.push(new un, new un, new un))
                        }
                        for (let e = 0; e < s; e++) {
                            const n = a[e].vertices;
                            c[e].data.push(n[t.a], n[t.b], n[t.c])
                        }
                        for (let e = 0; e < u; e++) {
                            const t = l[e].vertexNormals[g];
                            h[e].data.push(t.a, t.b, t.c)
                        }
                        f && this.skinIndices.push(d[t.a], d[t.b], d[t.c]), m && this.skinWeights.push(p[t.a], p[t.b], p[t.c])
                    }
                    return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                }
            }

            function oi(t) {
                if (0 === t.length) return -1 / 0;
                let e = t[0];
                for (let n = 1, r = t.length; n < r; ++n) t[n] > e && (e = t[n]);
                return e
            }
            let ai = 1;
            const si = new Yn,
                ci = new _r,
                li = new bn,
                ui = new Mn,
                hi = new Mn,
                di = new bn;

            function pi() {
                Object.defineProperty(this, "id", {
                    value: ai += 2
                }), this.uuid = ln.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }
            pi.prototype = Object.assign(Object.create(an.prototype), {
                constructor: pi,
                isBufferGeometry: !0,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(t) {
                    return Array.isArray(t) ? this.index = new(oi(t) > 65535 ? ei : Qr)(t, 1) : this.index = t, this
                },
                getAttribute: function(t) {
                    return this.attributes[t]
                },
                setAttribute: function(t, e) {
                    return this.attributes[t] = e, this
                },
                deleteAttribute: function(t) {
                    return delete this.attributes[t], this
                },
                addGroup: function(t, e, n) {
                    this.groups.push({
                        start: t,
                        count: e,
                        materialIndex: void 0 !== n ? n : 0
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(t, e) {
                    this.drawRange.start = t, this.drawRange.count = e
                },
                applyMatrix4: function(t) {
                    const e = this.attributes.position;
                    void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                    const n = this.attributes.normal;
                    if (void 0 !== n) {
                        const e = (new hn).getNormalMatrix(t);
                        n.applyNormalMatrix(e), n.needsUpdate = !0
                    }
                    const r = this.attributes.tangent;
                    return void 0 !== r && (r.transformDirection(t), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function(t) {
                    return si.makeRotationX(t), this.applyMatrix4(si), this
                },
                rotateY: function(t) {
                    return si.makeRotationY(t), this.applyMatrix4(si), this
                },
                rotateZ: function(t) {
                    return si.makeRotationZ(t), this.applyMatrix4(si), this
                },
                translate: function(t, e, n) {
                    return si.makeTranslation(t, e, n), this.applyMatrix4(si), this
                },
                scale: function(t, e, n) {
                    return si.makeScale(t, e, n), this.applyMatrix4(si), this
                },
                lookAt: function(t) {
                    return ci.lookAt(t), ci.updateMatrix(), this.applyMatrix4(ci.matrix), this
                },
                center: function() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(li).negate(), this.translate(li.x, li.y, li.z), this
                },
                setFromObject: function(t) {
                    const e = t.geometry;
                    if (t.isPoints || t.isLine) {
                        const t = new ni(3 * e.vertices.length, 3),
                            n = new ni(3 * e.colors.length, 3);
                        if (this.setAttribute("position", t.copyVector3sArray(e.vertices)), this.setAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                            const t = new ni(e.lineDistances.length, 1);
                            this.setAttribute("lineDistance", t.copyArray(e.lineDistances))
                        }
                        null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                    } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                    return this
                },
                setFromPoints: function(t) {
                    const e = [];
                    for (let n = 0, r = t.length; n < r; n++) {
                        const r = t[n];
                        e.push(r.x, r.y, r.z || 0)
                    }
                    return this.setAttribute("position", new ni(e, 3)), this
                },
                updateFromObject: function(t) {
                    let e = t.geometry;
                    if (t.isMesh) {
                        let t = e.__directGeometry;
                        if (!0 === e.elementsNeedUpdate && (t = void 0, e.elementsNeedUpdate = !1), void 0 === t) return this.fromGeometry(e);
                        t.verticesNeedUpdate = e.verticesNeedUpdate, t.normalsNeedUpdate = e.normalsNeedUpdate, t.colorsNeedUpdate = e.colorsNeedUpdate, t.uvsNeedUpdate = e.uvsNeedUpdate, t.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = t
                    }
                    if (!0 === e.verticesNeedUpdate) {
                        const t = this.attributes.position;
                        void 0 !== t && (t.copyVector3sArray(e.vertices), t.needsUpdate = !0), e.verticesNeedUpdate = !1
                    }
                    if (!0 === e.normalsNeedUpdate) {
                        const t = this.attributes.normal;
                        void 0 !== t && (t.copyVector3sArray(e.normals), t.needsUpdate = !0), e.normalsNeedUpdate = !1
                    }
                    if (!0 === e.colorsNeedUpdate) {
                        const t = this.attributes.color;
                        void 0 !== t && (t.copyColorsArray(e.colors), t.needsUpdate = !0), e.colorsNeedUpdate = !1
                    }
                    if (e.uvsNeedUpdate) {
                        const t = this.attributes.uv;
                        void 0 !== t && (t.copyVector2sArray(e.uvs), t.needsUpdate = !0), e.uvsNeedUpdate = !1
                    }
                    if (e.lineDistancesNeedUpdate) {
                        const t = this.attributes.lineDistance;
                        void 0 !== t && (t.copyArray(e.lineDistances), t.needsUpdate = !0), e.lineDistancesNeedUpdate = !1
                    }
                    return e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this
                },
                fromGeometry: function(t) {
                    return t.__directGeometry = (new ii).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
                },
                fromDirectGeometry: function(t) {
                    const e = new Float32Array(3 * t.vertices.length);
                    if (this.setAttribute("position", new Yr(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                        const e = new Float32Array(3 * t.normals.length);
                        this.setAttribute("normal", new Yr(e, 3).copyVector3sArray(t.normals))
                    }
                    if (t.colors.length > 0) {
                        const e = new Float32Array(3 * t.colors.length);
                        this.setAttribute("color", new Yr(e, 3).copyColorsArray(t.colors))
                    }
                    if (t.uvs.length > 0) {
                        const e = new Float32Array(2 * t.uvs.length);
                        this.setAttribute("uv", new Yr(e, 2).copyVector2sArray(t.uvs))
                    }
                    if (t.uvs2.length > 0) {
                        const e = new Float32Array(2 * t.uvs2.length);
                        this.setAttribute("uv2", new Yr(e, 2).copyVector2sArray(t.uvs2))
                    }
                    this.groups = t.groups;
                    for (const n in t.morphTargets) {
                        const e = [],
                            r = t.morphTargets[n];
                        for (let t = 0, n = r.length; t < n; t++) {
                            const n = r[t],
                                i = new ni(3 * n.data.length, 3);
                            i.name = n.name, e.push(i.copyVector3sArray(n.data))
                        }
                        this.morphAttributes[n] = e
                    }
                    if (t.skinIndices.length > 0) {
                        const e = new ni(4 * t.skinIndices.length, 4);
                        this.setAttribute("skinIndex", e.copyVector4sArray(t.skinIndices))
                    }
                    if (t.skinWeights.length > 0) {
                        const e = new ni(4 * t.skinWeights.length, 4);
                        this.setAttribute("skinWeight", e.copyVector4sArray(t.skinWeights))
                    }
                    return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new Mn);
                    const t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new bn(-1 / 0, -1 / 0, -1 / 0), new bn(1 / 0, 1 / 0, 1 / 0));
                    if (void 0 !== t) {
                        if (this.boundingBox.setFromBufferAttribute(t), e)
                            for (let n = 0, r = e.length; n < r; n++) {
                                const t = e[n];
                                ui.setFromBufferAttribute(t), this.morphTargetsRelative ? (di.addVectors(this.boundingBox.min, ui.min), this.boundingBox.expandByPoint(di), di.addVectors(this.boundingBox.max, ui.max), this.boundingBox.expandByPoint(di)) : (this.boundingBox.expandByPoint(ui.min), this.boundingBox.expandByPoint(ui.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new Un);
                    const t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new bn, 1 / 0);
                    if (t) {
                        const n = this.boundingSphere.center;
                        if (ui.setFromBufferAttribute(t), e)
                            for (let t = 0, i = e.length; t < i; t++) {
                                const n = e[t];
                                hi.setFromBufferAttribute(n), this.morphTargetsRelative ? (di.addVectors(ui.min, hi.min), ui.expandByPoint(di), di.addVectors(ui.max, hi.max), ui.expandByPoint(di)) : (ui.expandByPoint(hi.min), ui.expandByPoint(hi.max))
                            }
                        ui.getCenter(n);
                        let r = 0;
                        for (let e = 0, i = t.count; e < i; e++) di.fromBufferAttribute(t, e), r = Math.max(r, n.distanceToSquared(di));
                        if (e)
                            for (let i = 0, o = e.length; i < o; i++) {
                                const o = e[i],
                                    a = this.morphTargetsRelative;
                                for (let e = 0, i = o.count; e < i; e++) di.fromBufferAttribute(o, e), a && (li.fromBufferAttribute(t, e), di.add(li)), r = Math.max(r, n.distanceToSquared(di))
                            }
                        this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                },
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    const t = this.index,
                        e = this.getAttribute("position");
                    if (void 0 !== e) {
                        let n = this.getAttribute("normal");
                        if (void 0 === n) n = new Yr(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                        else
                            for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                        const r = new bn,
                            i = new bn,
                            o = new bn,
                            a = new bn,
                            s = new bn,
                            c = new bn,
                            l = new bn,
                            u = new bn;
                        if (t)
                            for (let h = 0, d = t.count; h < d; h += 3) {
                                const d = t.getX(h + 0),
                                    p = t.getX(h + 1),
                                    f = t.getX(h + 2);
                                r.fromBufferAttribute(e, d), i.fromBufferAttribute(e, p), o.fromBufferAttribute(e, f), l.subVectors(o, i), u.subVectors(r, i), l.cross(u), a.fromBufferAttribute(n, d), s.fromBufferAttribute(n, p), c.fromBufferAttribute(n, f), a.add(l), s.add(l), c.add(l), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, s.x, s.y, s.z), n.setXYZ(f, c.x, c.y, c.z)
                            } else
                                for (let t = 0, h = e.count; t < h; t += 3) r.fromBufferAttribute(e, t + 0), i.fromBufferAttribute(e, t + 1), o.fromBufferAttribute(e, t + 2), l.subVectors(o, i), u.subVectors(r, i), l.cross(u), n.setXYZ(t + 0, l.x, l.y, l.z), n.setXYZ(t + 1, l.x, l.y, l.z), n.setXYZ(t + 2, l.x, l.y, l.z);
                        this.normalizeNormals(), n.needsUpdate = !0
                    }
                },
                merge: function(t, e) {
                    if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                    void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    const n = this.attributes;
                    for (const r in n) {
                        if (void 0 === t.attributes[r]) continue;
                        const i = n[r],
                            o = i.array,
                            a = t.attributes[r],
                            s = a.array,
                            c = a.itemSize * e,
                            l = Math.min(s.length, o.length - c);
                        for (let t = 0, e = c; t < l; t++, e++) o[e] = s[t]
                    }
                    return this
                },
                normalizeNormals: function() {
                    const t = this.attributes.normal;
                    for (let e = 0, n = t.count; e < n; e++) di.fromBufferAttribute(t, e), di.normalize(), t.setXYZ(e, di.x, di.y, di.z)
                },
                toNonIndexed: function() {
                    function t(t, e) {
                        const n = t.array,
                            r = t.itemSize,
                            i = t.normalized,
                            o = new n.constructor(e.length * r);
                        let a = 0,
                            s = 0;
                        for (let c = 0, l = e.length; c < l; c++) {
                            a = e[c] * r;
                            for (let t = 0; t < r; t++) o[s++] = n[a++]
                        }
                        return new Yr(o, r, i)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                    const e = new pi,
                        n = this.index.array,
                        r = this.attributes;
                    for (const a in r) {
                        const i = r[a],
                            o = t(i, n);
                        e.setAttribute(a, o)
                    }
                    const i = this.morphAttributes;
                    for (const a in i) {
                        const r = [],
                            o = i[a];
                        for (let e = 0, i = o.length; e < i; e++) {
                            const i = o[e],
                                a = t(i, n);
                            r.push(a)
                        }
                        e.morphAttributes[a] = r
                    }
                    e.morphTargetsRelative = this.morphTargetsRelative;
                    const o = this.groups;
                    for (let a = 0, s = o.length; a < s; a++) {
                        const t = o[a];
                        e.addGroup(t.start, t.count, t.materialIndex)
                    }
                    return e
                },
                toJSON: function() {
                    const t = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                        const e = this.parameters;
                        for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                        return t
                    }
                    t.data = {
                        attributes: {}
                    };
                    const e = this.index;
                    null !== e && (t.data.index = {
                        type: e.array.constructor.name,
                        array: Array.prototype.slice.call(e.array)
                    });
                    const n = this.attributes;
                    for (const s in n) {
                        const e = n[s],
                            r = e.toJSON(t.data);
                        "" !== e.name && (r.name = e.name), t.data.attributes[s] = r
                    }
                    const r = {};
                    let i = !1;
                    for (const s in this.morphAttributes) {
                        const e = this.morphAttributes[s],
                            n = [];
                        for (let r = 0, i = e.length; r < i; r++) {
                            const i = e[r],
                                o = i.toJSON(t.data);
                            "" !== i.name && (o.name = i.name), n.push(o)
                        }
                        n.length > 0 && (r[s] = n, i = !0)
                    }
                    i && (t.data.morphAttributes = r, t.data.morphTargetsRelative = this.morphTargetsRelative);
                    const o = this.groups;
                    o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
                    const a = this.boundingSphere;
                    return null !== a && (t.data.boundingSphere = {
                        center: a.center.toArray(),
                        radius: a.radius
                    }), t
                },
                clone: function() {
                    return (new pi).copy(this)
                },
                copy: function(t) {
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                    const e = {};
                    this.name = t.name;
                    const n = t.index;
                    null !== n && this.setIndex(n.clone(e));
                    const r = t.attributes;
                    for (const c in r) {
                        const t = r[c];
                        this.setAttribute(c, t.clone(e))
                    }
                    const i = t.morphAttributes;
                    for (const c in i) {
                        const t = [],
                            n = i[c];
                        for (let r = 0, i = n.length; r < i; r++) t.push(n[r].clone(e));
                        this.morphAttributes[c] = t
                    }
                    this.morphTargetsRelative = t.morphTargetsRelative;
                    const o = t.groups;
                    for (let c = 0, l = o.length; c < l; c++) {
                        const t = o[c];
                        this.addGroup(t.start, t.count, t.materialIndex)
                    }
                    const a = t.boundingBox;
                    null !== a && (this.boundingBox = a.clone());
                    const s = t.boundingSphere;
                    return null !== s && (this.boundingSphere = s.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            const fi = new Yn,
                mi = new qn,
                gi = new Un,
                vi = new bn,
                yi = new bn,
                _i = new bn,
                bi = new bn,
                xi = new bn,
                wi = new bn,
                Mi = new bn,
                Ti = new bn,
                Si = new bn,
                Ei = new un,
                Ai = new un,
                Li = new un,
                Ri = new bn,
                Ci = new bn;

            function Oi(t, e) {
                _r.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new pi, this.material = void 0 !== e ? e : new Wr, this.updateMorphTargets()
            }

            function Pi(t, e, n, r, i, o, a, s) {
                let c;
                if (c = e.side === p ? r.intersectTriangle(a, o, i, !0, s) : r.intersectTriangle(i, o, a, e.side !== f, s), null === c) return null;
                Ci.copy(s), Ci.applyMatrix4(t.matrixWorld);
                const l = n.ray.origin.distanceTo(Ci);
                return l < n.near || l > n.far ? null : {
                    distance: l,
                    point: Ci.clone(),
                    object: t
                }
            }

            function Ii(t, e, n, r, i, o, a, s, c, l, u, h) {
                vi.fromBufferAttribute(i, l), yi.fromBufferAttribute(i, u), _i.fromBufferAttribute(i, h);
                const d = t.morphTargetInfluences;
                if (e.morphTargets && o && d) {
                    Mi.set(0, 0, 0), Ti.set(0, 0, 0), Si.set(0, 0, 0);
                    for (let t = 0, e = o.length; t < e; t++) {
                        const e = d[t],
                            n = o[t];
                        0 !== e && (bi.fromBufferAttribute(n, l), xi.fromBufferAttribute(n, u), wi.fromBufferAttribute(n, h), a ? (Mi.addScaledVector(bi, e), Ti.addScaledVector(xi, e), Si.addScaledVector(wi, e)) : (Mi.addScaledVector(bi.sub(vi), e), Ti.addScaledVector(xi.sub(yi), e), Si.addScaledVector(wi.sub(_i), e)))
                    }
                    vi.add(Mi), yi.add(Ti), _i.add(Si)
                }
                t.isSkinnedMesh && (t.boneTransform(l, vi), t.boneTransform(u, yi), t.boneTransform(h, _i));
                const p = Pi(t, e, n, r, vi, yi, _i, Ri);
                if (p) {
                    s && (Ei.fromBufferAttribute(s, l), Ai.fromBufferAttribute(s, u), Li.fromBufferAttribute(s, h), p.uv = Nr.getUV(Ri, vi, yi, _i, Ei, Ai, Li, new un)), c && (Ei.fromBufferAttribute(c, l), Ai.fromBufferAttribute(c, u), Li.fromBufferAttribute(c, h), p.uv2 = Nr.getUV(Ri, vi, yi, _i, Ei, Ai, Li, new un));
                    const t = new jr(l, u, h);
                    Nr.getNormal(vi, yi, _i, t.normal), p.face = t
                }
                return p
            }
            Oi.prototype = Object.assign(Object.create(_r.prototype), {
                constructor: Oi,
                isMesh: !0,
                copy: function(t) {
                    return _r.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
                },
                updateMorphTargets: function() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            n = Object.keys(e);
                        if (n.length > 0) {
                            const t = e[n[0]];
                            if (void 0 !== t) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                },
                raycast: function(t, e) {
                    const n = this.geometry,
                        r = this.material,
                        i = this.matrixWorld;
                    if (void 0 === r) return;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), gi.copy(n.boundingSphere), gi.applyMatrix4(i), !1 === t.ray.intersectsSphere(gi)) return;
                    if (fi.getInverse(i), mi.copy(t.ray).applyMatrix4(fi), null !== n.boundingBox && !1 === mi.intersectsBox(n.boundingBox)) return;
                    let o;
                    if (n.isBufferGeometry) {
                        const i = n.index,
                            a = n.attributes.position,
                            s = n.morphAttributes.position,
                            c = n.morphTargetsRelative,
                            l = n.attributes.uv,
                            u = n.attributes.uv2,
                            h = n.groups,
                            d = n.drawRange;
                        if (null !== i)
                            if (Array.isArray(r))
                                for (let n = 0, p = h.length; n < p; n++) {
                                    const p = h[n],
                                        f = r[p.materialIndex],
                                        m = Math.max(p.start, d.start),
                                        g = Math.min(p.start + p.count, d.start + d.count);
                                    for (let n = m, r = g; n < r; n += 3) {
                                        const r = i.getX(n),
                                            h = i.getX(n + 1),
                                            d = i.getX(n + 2);
                                        o = Ii(this, f, t, mi, a, s, c, l, u, r, h, d), o && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = p.materialIndex, e.push(o))
                                    }
                                } else {
                                    const n = Math.max(0, d.start),
                                        h = Math.min(i.count, d.start + d.count);
                                    for (let d = n, p = h; d < p; d += 3) {
                                        const n = i.getX(d),
                                            h = i.getX(d + 1),
                                            p = i.getX(d + 2);
                                        o = Ii(this, r, t, mi, a, s, c, l, u, n, h, p), o && (o.faceIndex = Math.floor(d / 3), e.push(o))
                                    }
                                } else if (void 0 !== a)
                                    if (Array.isArray(r))
                                        for (let n = 0, p = h.length; n < p; n++) {
                                            const i = h[n],
                                                p = r[i.materialIndex],
                                                f = Math.max(i.start, d.start),
                                                m = Math.min(i.start + i.count, d.start + d.count);
                                            for (let n = f, r = m; n < r; n += 3) {
                                                const r = n,
                                                    h = n + 1,
                                                    d = n + 2;
                                                o = Ii(this, p, t, mi, a, s, c, l, u, r, h, d), o && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = i.materialIndex, e.push(o))
                                            }
                                        } else {
                                            const n = Math.max(0, d.start),
                                                i = Math.min(a.count, d.start + d.count);
                                            for (let h = n, d = i; h < d; h += 3) {
                                                const n = h,
                                                    i = h + 1,
                                                    d = h + 2;
                                                o = Ii(this, r, t, mi, a, s, c, l, u, n, i, d), o && (o.faceIndex = Math.floor(h / 3), e.push(o))
                                            }
                                        }
                    } else if (n.isGeometry) {
                        const i = Array.isArray(r),
                            a = n.vertices,
                            s = n.faces;
                        let c;
                        const l = n.faceVertexUvs[0];
                        l.length > 0 && (c = l);
                        for (let n = 0, u = s.length; n < u; n++) {
                            const l = s[n],
                                u = i ? r[l.materialIndex] : r;
                            if (void 0 === u) continue;
                            const h = a[l.a],
                                d = a[l.b],
                                p = a[l.c];
                            if (o = Pi(this, u, t, mi, h, d, p, Ri), o) {
                                if (c && c[n]) {
                                    const t = c[n];
                                    Ei.copy(t[0]), Ai.copy(t[1]), Li.copy(t[2]), o.uv = Nr.getUV(Ri, h, d, p, Ei, Ai, Li, new un)
                                }
                                o.face = l, o.faceIndex = n, e.push(o)
                            }
                        }
                    }
                }
            });
            class Ni extends pi {
                constructor(t = 1, e = 1, n = 1, r = 1, i = 1, o = 1) {
                    super(), this.type = "BoxBufferGeometry", this.parameters = {
                        width: t,
                        height: e,
                        depth: n,
                        widthSegments: r,
                        heightSegments: i,
                        depthSegments: o
                    };
                    const a = this;
                    r = Math.floor(r), i = Math.floor(i), o = Math.floor(o);
                    const s = [],
                        c = [],
                        l = [],
                        u = [];
                    let h = 0,
                        d = 0;

                    function p(t, e, n, r, i, o, p, f, m, g, v) {
                        const y = o / m,
                            _ = p / g,
                            b = o / 2,
                            x = p / 2,
                            w = f / 2,
                            M = m + 1,
                            T = g + 1;
                        let S = 0,
                            E = 0;
                        const A = new bn;
                        for (let a = 0; a < T; a++) {
                            const o = a * _ - x;
                            for (let s = 0; s < M; s++) {
                                const h = s * y - b;
                                A[t] = h * r, A[e] = o * i, A[n] = w, c.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = f > 0 ? 1 : -1, l.push(A.x, A.y, A.z), u.push(s / m), u.push(1 - a / g), S += 1
                            }
                        }
                        for (let a = 0; a < g; a++)
                            for (let t = 0; t < m; t++) {
                                const e = h + t + M * a,
                                    n = h + t + M * (a + 1),
                                    r = h + (t + 1) + M * (a + 1),
                                    i = h + (t + 1) + M * a;
                                s.push(e, n, i), s.push(n, r, i), E += 6
                            }
                        a.addGroup(d, E, v), d += E, h += S
                    }
                    p("z", "y", "x", -1, -1, n, e, t, o, i, 0), p("z", "y", "x", 1, -1, n, e, -t, o, i, 1), p("x", "z", "y", 1, 1, t, n, e, r, o, 2), p("x", "z", "y", 1, -1, t, n, -e, r, o, 3), p("x", "y", "z", 1, -1, t, e, n, r, i, 4), p("x", "y", "z", -1, -1, t, e, -n, r, i, 5), this.setIndex(s), this.setAttribute("position", new ni(c, 3)), this.setAttribute("normal", new ni(l, 3)), this.setAttribute("uv", new ni(u, 2))
                }
            }

            function Di(t) {
                const e = {};
                for (const n in t) {
                    e[n] = {};
                    for (const r in t[n]) {
                        const i = t[n][r];
                        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? e[n][r] = i.clone() : Array.isArray(i) ? e[n][r] = i.slice() : e[n][r] = i
                    }
                }
                return e
            }

            function ki(t) {
                const e = {};
                for (let n = 0; n < t.length; n++) {
                    const r = Di(t[n]);
                    for (const t in r) e[t] = r[t]
                }
                return e
            }
            const Fi = {
                clone: Di,
                merge: ki
            };
            var Bi = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                Ui = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

            function Hi(t) {
                Vr.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = Bi, this.fragmentShader = Ui, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
            }

            function zi() {
                _r.call(this), this.type = "Camera", this.matrixWorldInverse = new Yn, this.projectionMatrix = new Yn, this.projectionMatrixInverse = new Yn
            }

            function ji(t, e, n, r) {
                zi.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }
            Hi.prototype = Object.create(Vr.prototype), Hi.prototype.constructor = Hi, Hi.prototype.isShaderMaterial = !0, Hi.prototype.copy = function(t) {
                return Vr.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Di(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
            }, Hi.prototype.toJSON = function(t) {
                const e = Vr.prototype.toJSON.call(this, t);
                e.glslVersion = this.glslVersion, e.uniforms = {};
                for (const r in this.uniforms) {
                    const n = this.uniforms[r],
                        i = n.value;
                    i && i.isTexture ? e.uniforms[r] = {
                        type: "t",
                        value: i.toJSON(t).uuid
                    } : i && i.isColor ? e.uniforms[r] = {
                        type: "c",
                        value: i.getHex()
                    } : i && i.isVector2 ? e.uniforms[r] = {
                        type: "v2",
                        value: i.toArray()
                    } : i && i.isVector3 ? e.uniforms[r] = {
                        type: "v3",
                        value: i.toArray()
                    } : i && i.isVector4 ? e.uniforms[r] = {
                        type: "v4",
                        value: i.toArray()
                    } : i && i.isMatrix3 ? e.uniforms[r] = {
                        type: "m3",
                        value: i.toArray()
                    } : i && i.isMatrix4 ? e.uniforms[r] = {
                        type: "m4",
                        value: i.toArray()
                    } : e.uniforms[r] = {
                        value: i
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                const n = {};
                for (const r in this.extensions) !0 === this.extensions[r] && (n[r] = !0);
                return Object.keys(n).length > 0 && (e.extensions = n), e
            }, zi.prototype = Object.assign(Object.create(_r.prototype), {
                constructor: zi,
                isCamera: !0,
                copy: function(t, e) {
                    return _r.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                },
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new bn), this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(-e[8], -e[9], -e[10]).normalize()
                },
                updateMatrixWorld: function(t) {
                    _r.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                updateWorldMatrix: function(t, e) {
                    _r.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), ji.prototype = Object.assign(Object.create(zi.prototype), {
                constructor: ji,
                isPerspectiveCamera: !0,
                copy: function(t, e) {
                    return zi.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                },
                setFocalLength: function(t) {
                    const e = .5 * this.getFilmHeight() / t;
                    this.fov = 2 * ln.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    const t = Math.tan(.5 * ln.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / t
                },
                getEffectiveFOV: function() {
                    return 2 * ln.RAD2DEG * Math.atan(Math.tan(.5 * ln.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(t, e, n, r, i, o) {
                    this.aspect = t / e, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    const t = this.near;
                    let e = t * Math.tan(.5 * ln.DEG2RAD * this.fov) / this.zoom,
                        n = 2 * e,
                        r = this.aspect * n,
                        i = -.5 * r;
                    const o = this.view;
                    if (null !== this.view && this.view.enabled) {
                        const t = o.fullWidth,
                            a = o.fullHeight;
                        i += o.offsetX * r / t, e -= o.offsetY * n / a, r *= o.width / t, n *= o.height / a
                    }
                    const a = this.filmOffset;
                    0 !== a && (i += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, e, e - n, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    const e = _r.prototype.toJSON.call(this, t);
                    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                }
            });
            const Gi = 90,
                Vi = 1;

            function Wi(t, e, n) {
                if (_r.call(this), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                this.renderTarget = n;
                const r = new ji(Gi, Vi, t, e);
                r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new bn(1, 0, 0)), this.add(r);
                const i = new ji(Gi, Vi, t, e);
                i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new bn(-1, 0, 0)), this.add(i);
                const o = new ji(Gi, Vi, t, e);
                o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new bn(0, 1, 0)), this.add(o);
                const a = new ji(Gi, Vi, t, e);
                a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new bn(0, -1, 0)), this.add(a);
                const s = new ji(Gi, Vi, t, e);
                s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new bn(0, 0, 1)), this.add(s);
                const c = new ji(Gi, Vi, t, e);
                c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new bn(0, 0, -1)), this.add(c), this.update = function(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    const l = t.xr.enabled,
                        u = t.getRenderTarget();
                    t.xr.enabled = !1;
                    const h = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, r), t.setRenderTarget(n, 1), t.render(e, i), t.setRenderTarget(n, 2), t.render(e, o), t.setRenderTarget(n, 3), t.render(e, a), t.setRenderTarget(n, 4), t.render(e, s), n.texture.generateMipmaps = h, t.setRenderTarget(n, 5), t.render(e, c), t.setRenderTarget(u), t.xr.enabled = l
                }
            }

            function Xi(t, e, n, r, i, o, a, s, c, l) {
                t = void 0 !== t ? t : [], e = void 0 !== e ? e : nt, a = void 0 !== a ? a : Ct, mn.call(this, t, e, n, r, i, o, a, s, c, l), this.flipY = !1, this._needsFlipEnvMap = !0
            }

            function qi(t, e, n) {
                Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), vn.call(this, t, t, e), e = e || {}, this.texture = new Xi(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture._needsFlipEnvMap = !1
            }

            function Yi(t, e, n, r, i, o, a, s, c, l, u, h) {
                mn.call(this, null, o, a, s, c, l, r, i, u, h), this.image = {
                    data: t || null,
                    width: e || 1,
                    height: n || 1
                }, this.magFilter = void 0 !== c ? c : ht, this.minFilter = void 0 !== l ? l : ht, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
            }
            Wi.prototype = Object.create(_r.prototype), Wi.prototype.constructor = Wi, Xi.prototype = Object.create(mn.prototype), Xi.prototype.constructor = Xi, Xi.prototype.isCubeTexture = !0, Object.defineProperty(Xi.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(t) {
                    this.image = t
                }
            }), qi.prototype = Object.create(vn.prototype), qi.prototype.constructor = qi, qi.prototype.isWebGLCubeRenderTarget = !0, qi.prototype.fromEquirectangularTexture = function(t, e) {
                this.texture.type = e.type, this.texture.format = Ot, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                const n = {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: "\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t",
                        fragmentShader: "\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t"
                    },
                    r = new Ni(5, 5, 5),
                    i = new Hi({
                        name: "CubemapFromEquirect",
                        uniforms: Di(n.uniforms),
                        vertexShader: n.vertexShader,
                        fragmentShader: n.fragmentShader,
                        side: p,
                        blending: g
                    });
                i.uniforms.tEquirect.value = e;
                const o = new Oi(r, i),
                    a = e.minFilter;
                e.minFilter === gt && (e.minFilter = ft);
                const s = new Wi(1, 10, this);
                return s.update(t, o), e.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
            }, qi.prototype.clear = function(t, e, n, r) {
                const i = t.getRenderTarget();
                for (let o = 0; o < 6; o++) t.setRenderTarget(this, o), t.clear(e, n, r);
                t.setRenderTarget(i)
            }, Yi.prototype = Object.create(mn.prototype), Yi.prototype.constructor = Yi, Yi.prototype.isDataTexture = !0;
            const $i = new Un,
                Zi = new bn;
            class Ji {
                constructor(t, e, n, r, i, o) {
                    this.planes = [void 0 !== t ? t : new Mr, void 0 !== e ? e : new Mr, void 0 !== n ? n : new Mr, void 0 !== r ? r : new Mr, void 0 !== i ? i : new Mr, void 0 !== o ? o : new Mr]
                }
                set(t, e, n, r, i, o) {
                    const a = this.planes;
                    return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(r), a[4].copy(i), a[5].copy(o), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    const e = this.planes;
                    for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                    return this
                }
                setFromProjectionMatrix(t) {
                    const e = this.planes,
                        n = t.elements,
                        r = n[0],
                        i = n[1],
                        o = n[2],
                        a = n[3],
                        s = n[4],
                        c = n[5],
                        l = n[6],
                        u = n[7],
                        h = n[8],
                        d = n[9],
                        p = n[10],
                        f = n[11],
                        m = n[12],
                        g = n[13],
                        v = n[14],
                        y = n[15];
                    return e[0].setComponents(a - r, u - s, f - h, y - m).normalize(), e[1].setComponents(a + r, u + s, f + h, y + m).normalize(), e[2].setComponents(a + i, u + c, f + d, y + g).normalize(), e[3].setComponents(a - i, u - c, f - d, y - g).normalize(), e[4].setComponents(a - o, u - l, f - p, y - v).normalize(), e[5].setComponents(a + o, u + l, f + p, y + v).normalize(), this
                }
                intersectsObject(t) {
                    const e = t.geometry;
                    return null === e.boundingSphere && e.computeBoundingSphere(), $i.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere($i)
                }
                intersectsSprite(t) {
                    return $i.center.set(0, 0, 0), $i.radius = .7071067811865476, $i.applyMatrix4(t.matrixWorld), this.intersectsSphere($i)
                }
                intersectsSphere(t) {
                    const e = this.planes,
                        n = t.center,
                        r = -t.radius;
                    for (let i = 0; i < 6; i++) {
                        const t = e[i].distanceToPoint(n);
                        if (t < r) return !1
                    }
                    return !0
                }
                intersectsBox(t) {
                    const e = this.planes;
                    for (let n = 0; n < 6; n++) {
                        const r = e[n];
                        if (Zi.x = r.normal.x > 0 ? t.max.x : t.min.x, Zi.y = r.normal.y > 0 ? t.max.y : t.min.y, Zi.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(Zi) < 0) return !1
                    }
                    return !0
                }
                containsPoint(t) {
                    const e = this.planes;
                    for (let n = 0; n < 6; n++)
                        if (e[n].distanceToPoint(t) < 0) return !1;
                    return !0
                }
            }

            function Ki() {
                let t = null,
                    e = !1,
                    n = null,
                    r = null;

                function i(e, o) {
                    n(e, o), r = t.requestAnimationFrame(i)
                }
                return {
                    start: function() {
                        !0 !== e && null !== n && (r = t.requestAnimationFrame(i), e = !0)
                    },
                    stop: function() {
                        t.cancelAnimationFrame(r), e = !1
                    },
                    setAnimationLoop: function(t) {
                        n = t
                    },
                    setContext: function(e) {
                        t = e
                    }
                }
            }

            function Qi(t, e) {
                const n = e.isWebGL2,
                    r = new WeakMap;

                function i(e, n) {
                    const r = e.array,
                        i = e.usage,
                        o = t.createBuffer();
                    t.bindBuffer(n, o), t.bufferData(n, r, i), e.onUploadCallback();
                    let a = 5126;
                    return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : r instanceof Uint8Array && (a = 5121), {
                        buffer: o,
                        type: a,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: e.version
                    }
                }

                function o(e, r, i) {
                    const o = r.array,
                        a = r.updateRange;
                    t.bindBuffer(i, e), -1 === a.count ? t.bufferSubData(i, 0, o) : (n ? t.bufferSubData(i, a.offset * o.BYTES_PER_ELEMENT, o, a.offset, a.count) : t.bufferSubData(i, a.offset * o.BYTES_PER_ELEMENT, o.subarray(a.offset, a.offset + a.count)), a.count = -1)
                }

                function a(t) {
                    return t.isInterleavedBufferAttribute && (t = t.data), r.get(t)
                }

                function s(e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const n = r.get(e);
                    n && (t.deleteBuffer(n.buffer), r.delete(e))
                }

                function c(t, e) {
                    if (t.isGLBufferAttribute) {
                        var n = r.get(t);
                        return void((!n || n.version < t.version) && r.set(t, {
                            buffer: t.buffer,
                            type: t.type,
                            bytesPerElement: t.elementSize,
                            version: t.version
                        }))
                    }
                    t.isInterleavedBufferAttribute && (t = t.data);
                    const a = r.get(t);
                    void 0 === a ? r.set(t, i(t, e)) : a.version < t.version && (o(a.buffer, t, e), a.version = t.version)
                }
                return {
                    get: a,
                    remove: s,
                    update: c
                }
            }
            class to extends pi {
                constructor(t, e, n, r) {
                    super(), this.type = "PlaneBufferGeometry", this.parameters = {
                        width: t,
                        height: e,
                        widthSegments: n,
                        heightSegments: r
                    }, t = t || 1, e = e || 1;
                    const i = t / 2,
                        o = e / 2,
                        a = Math.floor(n) || 1,
                        s = Math.floor(r) || 1,
                        c = a + 1,
                        l = s + 1,
                        u = t / a,
                        h = e / s,
                        d = [],
                        p = [],
                        f = [],
                        m = [];
                    for (let g = 0; g < l; g++) {
                        const t = g * h - o;
                        for (let e = 0; e < c; e++) {
                            const n = e * u - i;
                            p.push(n, -t, 0), f.push(0, 0, 1), m.push(e / a), m.push(1 - g / s)
                        }
                    }
                    for (let g = 0; g < s; g++)
                        for (let t = 0; t < a; t++) {
                            const e = t + c * g,
                                n = t + c * (g + 1),
                                r = t + 1 + c * (g + 1),
                                i = t + 1 + c * g;
                            d.push(e, n, i), d.push(n, r, i)
                        }
                    this.setIndex(d), this.setAttribute("position", new ni(p, 3)), this.setAttribute("normal", new ni(f, 3)), this.setAttribute("uv", new ni(m, 2))
                }
            }
            var eo = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                no = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                ro = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                io = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                oo = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                ao = "vec3 transformed = vec3( position );",
                so = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                co = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
                lo = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                uo = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                ho = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                po = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                fo = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                mo = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                go = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                vo = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                yo = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                _o = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                bo = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                xo = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                wo = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                Mo = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                To = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                So = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                Eo = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                Ao = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                Lo = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                Ro = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                Co = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                Oo = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                Po = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                Io = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
                No = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                Do = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                ko = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                Fo = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                Bo = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
                Uo = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                Ho = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                zo = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                jo = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                Go = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                Vo = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                Wo = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                Xo = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                qo = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
                Yo = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                $o = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                Zo = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
                Jo = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                Ko = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                Qo = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                ta = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                ea = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                na = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                ra = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                ia = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                oa = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                aa = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                sa = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                ca = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
                la = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                ua = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                ha = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                da = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
                pa = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
                fa = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                ma = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
                ga = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                va = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                ya = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                _a = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                ba = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                xa = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                wa = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                Ma = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                Ta = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                Sa = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                Ea = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                Aa = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                La = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                Ra = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                Ca = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                Oa = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                Pa = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                Ia = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                Na = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                Da = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                ka = "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
                Fa = "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
                Ba = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                Ua = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                Ha = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                za = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                ja = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                Ga = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                Va = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                Wa = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                Xa = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                qa = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                Ya = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                $a = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                Za = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                Ja = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                Ka = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                Qa = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                ts = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                es = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                ns = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                rs = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                is = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                os = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                as = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                ss = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                cs = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                ls = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                us = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                hs = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                ds = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                ps = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                fs = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                ms = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                gs = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                vs = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                ys = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                _s = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                bs = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                xs = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                ws = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
            const Ms = {
                    alphamap_fragment: eo,
                    alphamap_pars_fragment: no,
                    alphatest_fragment: ro,
                    aomap_fragment: io,
                    aomap_pars_fragment: oo,
                    begin_vertex: ao,
                    beginnormal_vertex: so,
                    bsdfs: co,
                    bumpmap_pars_fragment: lo,
                    clipping_planes_fragment: uo,
                    clipping_planes_pars_fragment: ho,
                    clipping_planes_pars_vertex: po,
                    clipping_planes_vertex: fo,
                    color_fragment: mo,
                    color_pars_fragment: go,
                    color_pars_vertex: vo,
                    color_vertex: yo,
                    common: _o,
                    cube_uv_reflection_fragment: bo,
                    defaultnormal_vertex: xo,
                    displacementmap_pars_vertex: wo,
                    displacementmap_vertex: Mo,
                    emissivemap_fragment: To,
                    emissivemap_pars_fragment: So,
                    encodings_fragment: Eo,
                    encodings_pars_fragment: Ao,
                    envmap_fragment: Lo,
                    envmap_common_pars_fragment: Ro,
                    envmap_pars_fragment: Co,
                    envmap_pars_vertex: Oo,
                    envmap_physical_pars_fragment: jo,
                    envmap_vertex: Po,
                    fog_vertex: Io,
                    fog_pars_vertex: No,
                    fog_fragment: Do,
                    fog_pars_fragment: ko,
                    gradientmap_pars_fragment: Fo,
                    lightmap_fragment: Bo,
                    lightmap_pars_fragment: Uo,
                    lights_lambert_vertex: Ho,
                    lights_pars_begin: zo,
                    lights_toon_fragment: Go,
                    lights_toon_pars_fragment: Vo,
                    lights_phong_fragment: Wo,
                    lights_phong_pars_fragment: Xo,
                    lights_physical_fragment: qo,
                    lights_physical_pars_fragment: Yo,
                    lights_fragment_begin: $o,
                    lights_fragment_maps: Zo,
                    lights_fragment_end: Jo,
                    logdepthbuf_fragment: Ko,
                    logdepthbuf_pars_fragment: Qo,
                    logdepthbuf_pars_vertex: ta,
                    logdepthbuf_vertex: ea,
                    map_fragment: na,
                    map_pars_fragment: ra,
                    map_particle_fragment: ia,
                    map_particle_pars_fragment: oa,
                    metalnessmap_fragment: aa,
                    metalnessmap_pars_fragment: sa,
                    morphnormal_vertex: ca,
                    morphtarget_pars_vertex: la,
                    morphtarget_vertex: ua,
                    normal_fragment_begin: ha,
                    normal_fragment_maps: da,
                    normalmap_pars_fragment: pa,
                    clearcoat_normal_fragment_begin: fa,
                    clearcoat_normal_fragment_maps: ma,
                    clearcoat_pars_fragment: ga,
                    packing: va,
                    premultiplied_alpha_fragment: ya,
                    project_vertex: _a,
                    dithering_fragment: ba,
                    dithering_pars_fragment: xa,
                    roughnessmap_fragment: wa,
                    roughnessmap_pars_fragment: Ma,
                    shadowmap_pars_fragment: Ta,
                    shadowmap_pars_vertex: Sa,
                    shadowmap_vertex: Ea,
                    shadowmask_pars_fragment: Aa,
                    skinbase_vertex: La,
                    skinning_pars_vertex: Ra,
                    skinning_vertex: Ca,
                    skinnormal_vertex: Oa,
                    specularmap_fragment: Pa,
                    specularmap_pars_fragment: Ia,
                    tonemapping_fragment: Na,
                    tonemapping_pars_fragment: Da,
                    transmissionmap_fragment: ka,
                    transmissionmap_pars_fragment: Fa,
                    uv_pars_fragment: Ba,
                    uv_pars_vertex: Ua,
                    uv_vertex: Ha,
                    uv2_pars_fragment: za,
                    uv2_pars_vertex: ja,
                    uv2_vertex: Ga,
                    worldpos_vertex: Va,
                    background_frag: Wa,
                    background_vert: Xa,
                    cube_frag: qa,
                    cube_vert: Ya,
                    depth_frag: $a,
                    depth_vert: Za,
                    distanceRGBA_frag: Ja,
                    distanceRGBA_vert: Ka,
                    equirect_frag: Qa,
                    equirect_vert: ts,
                    linedashed_frag: es,
                    linedashed_vert: ns,
                    meshbasic_frag: rs,
                    meshbasic_vert: is,
                    meshlambert_frag: os,
                    meshlambert_vert: as,
                    meshmatcap_frag: ss,
                    meshmatcap_vert: cs,
                    meshtoon_frag: ls,
                    meshtoon_vert: us,
                    meshphong_frag: hs,
                    meshphong_vert: ds,
                    meshphysical_frag: ps,
                    meshphysical_vert: fs,
                    normal_frag: ms,
                    normal_vert: gs,
                    points_frag: vs,
                    points_vert: ys,
                    shadow_frag: _s,
                    shadow_vert: bs,
                    sprite_frag: xs,
                    sprite_vert: ws
                },
                Ts = {
                    common: {
                        diffuse: {
                            value: new zr(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new hn
                        },
                        uv2Transform: {
                            value: new hn
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        },
                        maxMipLevel: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new un(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new zr(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new zr(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        uvTransform: {
                            value: new hn
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new zr(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new un(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        uvTransform: {
                            value: new hn
                        }
                    }
                },
                Ss = {
                    basic: {
                        uniforms: ki([Ts.common, Ts.specularmap, Ts.envmap, Ts.aomap, Ts.lightmap, Ts.fog]),
                        vertexShader: Ms.meshbasic_vert,
                        fragmentShader: Ms.meshbasic_frag
                    },
                    lambert: {
                        uniforms: ki([Ts.common, Ts.specularmap, Ts.envmap, Ts.aomap, Ts.lightmap, Ts.emissivemap, Ts.fog, Ts.lights, {
                            emissive: {
                                value: new zr(0)
                            }
                        }]),
                        vertexShader: Ms.meshlambert_vert,
                        fragmentShader: Ms.meshlambert_frag
                    },
                    phong: {
                        uniforms: ki([Ts.common, Ts.specularmap, Ts.envmap, Ts.aomap, Ts.lightmap, Ts.emissivemap, Ts.bumpmap, Ts.normalmap, Ts.displacementmap, Ts.fog, Ts.lights, {
                            emissive: {
                                value: new zr(0)
                            },
                            specular: {
                                value: new zr(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: Ms.meshphong_vert,
                        fragmentShader: Ms.meshphong_frag
                    },
                    standard: {
                        uniforms: ki([Ts.common, Ts.envmap, Ts.aomap, Ts.lightmap, Ts.emissivemap, Ts.bumpmap, Ts.normalmap, Ts.displacementmap, Ts.roughnessmap, Ts.metalnessmap, Ts.fog, Ts.lights, {
                            emissive: {
                                value: new zr(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Ms.meshphysical_vert,
                        fragmentShader: Ms.meshphysical_frag
                    },
                    toon: {
                        uniforms: ki([Ts.common, Ts.aomap, Ts.lightmap, Ts.emissivemap, Ts.bumpmap, Ts.normalmap, Ts.displacementmap, Ts.gradientmap, Ts.fog, Ts.lights, {
                            emissive: {
                                value: new zr(0)
                            }
                        }]),
                        vertexShader: Ms.meshtoon_vert,
                        fragmentShader: Ms.meshtoon_frag
                    },
                    matcap: {
                        uniforms: ki([Ts.common, Ts.bumpmap, Ts.normalmap, Ts.displacementmap, Ts.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: Ms.meshmatcap_vert,
                        fragmentShader: Ms.meshmatcap_frag
                    },
                    points: {
                        uniforms: ki([Ts.points, Ts.fog]),
                        vertexShader: Ms.points_vert,
                        fragmentShader: Ms.points_frag
                    },
                    dashed: {
                        uniforms: ki([Ts.common, Ts.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: Ms.linedashed_vert,
                        fragmentShader: Ms.linedashed_frag
                    },
                    depth: {
                        uniforms: ki([Ts.common, Ts.displacementmap]),
                        vertexShader: Ms.depth_vert,
                        fragmentShader: Ms.depth_frag
                    },
                    normal: {
                        uniforms: ki([Ts.common, Ts.bumpmap, Ts.normalmap, Ts.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Ms.normal_vert,
                        fragmentShader: Ms.normal_frag
                    },
                    sprite: {
                        uniforms: ki([Ts.sprite, Ts.fog]),
                        vertexShader: Ms.sprite_vert,
                        fragmentShader: Ms.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new hn
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: Ms.background_vert,
                        fragmentShader: Ms.background_frag
                    },
                    cube: {
                        uniforms: ki([Ts.envmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Ms.cube_vert,
                        fragmentShader: Ms.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: Ms.equirect_vert,
                        fragmentShader: Ms.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: ki([Ts.common, Ts.displacementmap, {
                            referencePosition: {
                                value: new bn
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: Ms.distanceRGBA_vert,
                        fragmentShader: Ms.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: ki([Ts.lights, Ts.fog, {
                            color: {
                                value: new zr(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Ms.shadow_vert,
                        fragmentShader: Ms.shadow_frag
                    }
                };

            function Es(t, e, n, r, i) {
                const o = new zr(0);
                let a, s, c = 0,
                    l = null,
                    u = 0,
                    h = null;

                function f(n, i, f, g) {
                    let v = !0 === i.isScene ? i.background : null;
                    v && v.isTexture && (v = e.get(v));
                    const y = t.xr,
                        _ = y.getSession && y.getSession();
                    _ && "additive" === _.environmentBlendMode && (v = null), null === v ? m(o, c) : v && v.isColor && (m(v, 1), g = !0), (t.autoClear || g) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), v && (v.isCubeTexture || v.isWebGLCubeRenderTarget || v.mapping === at) ? (void 0 === s && (s = new Oi(new Ni(1, 1, 1), new Hi({
                        name: "BackgroundCubeMaterial",
                        uniforms: Di(Ss.cube.uniforms),
                        vertexShader: Ss.cube.vertexShader,
                        fragmentShader: Ss.cube.fragmentShader,
                        side: p,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), s.geometry.deleteAttribute("normal"), s.geometry.deleteAttribute("uv"), s.onBeforeRender = function(t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(s.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }), r.update(s)), v.isWebGLCubeRenderTarget && (v = v.texture), s.material.uniforms.envMap.value = v, s.material.uniforms.flipEnvMap.value = v.isCubeTexture && v._needsFlipEnvMap ? -1 : 1, l === v && u === v.version && h === t.toneMapping || (s.material.needsUpdate = !0, l = v, u = v.version, h = t.toneMapping), n.unshift(s, s.geometry, s.material, 0, 0, null)) : v && v.isTexture && (void 0 === a && (a = new Oi(new to(2, 2), new Hi({
                        name: "BackgroundMaterial",
                        uniforms: Di(Ss.background.uniforms),
                        vertexShader: Ss.background.vertexShader,
                        fragmentShader: Ss.background.fragmentShader,
                        side: d,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), a.geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }), r.update(a)), a.material.uniforms.t2D.value = v, !0 === v.matrixAutoUpdate && v.updateMatrix(), a.material.uniforms.uvTransform.value.copy(v.matrix), l === v && u === v.version && h === t.toneMapping || (a.material.needsUpdate = !0, l = v, u = v.version, h = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null))
                }

                function m(t, e) {
                    n.buffers.color.setClear(t.r, t.g, t.b, e, i)
                }
                return {
                    getClearColor: function() {
                        return o
                    },
                    setClearColor: function(t, e) {
                        o.set(t), c = void 0 !== e ? e : 1, m(o, c)
                    },
                    getClearAlpha: function() {
                        return c
                    },
                    setClearAlpha: function(t) {
                        c = t, m(o, c)
                    },
                    render: f
                }
            }

            function As(t, e, n, r) {
                const i = t.getParameter(34921),
                    o = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                    a = r.isWebGL2 || null !== o,
                    s = {},
                    c = m(null);
                let l = c;

                function u(e, r, i, o, s) {
                    let c = !1;
                    if (a) {
                        const t = f(o, i, r);
                        l !== t && (l = t, d(l.object)), c = g(o, s), c && v(o, s)
                    } else {
                        const t = !0 === r.wireframe;
                        l.geometry === o.id && l.program === i.id && l.wireframe === t || (l.geometry = o.id, l.program = i.id, l.wireframe = t, c = !0)
                    }!0 === e.isInstancedMesh && (c = !0), null !== s && n.update(s, 34963), c && (M(e, r, i, o), null !== s && t.bindBuffer(34963, n.get(s).buffer))
                }

                function h() {
                    return r.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()
                }

                function d(e) {
                    return r.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e)
                }

                function p(e) {
                    return r.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e)
                }

                function f(t, e, n) {
                    const r = !0 === n.wireframe;
                    let i = s[t.id];
                    void 0 === i && (i = {}, s[t.id] = i);
                    let o = i[e.id];
                    void 0 === o && (o = {}, i[e.id] = o);
                    let a = o[r];
                    return void 0 === a && (a = m(h()), o[r] = a), a
                }

                function m(t) {
                    const e = [],
                        n = [],
                        r = [];
                    for (let o = 0; o < i; o++) e[o] = 0, n[o] = 0, r[o] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: e,
                        enabledAttributes: n,
                        attributeDivisors: r,
                        object: t,
                        attributes: {},
                        index: null
                    }
                }

                function g(t, e) {
                    const n = l.attributes,
                        r = t.attributes;
                    if (Object.keys(n).length !== Object.keys(r).length) return !0;
                    for (const i in r) {
                        const t = n[i],
                            e = r[i];
                        if (void 0 === t) return !0;
                        if (t.attribute !== e) return !0;
                        if (t.data !== e.data) return !0
                    }
                    return l.index !== e
                }

                function v(t, e) {
                    const n = {},
                        r = t.attributes;
                    for (const i in r) {
                        const t = r[i],
                            e = {};
                        e.attribute = t, t.data && (e.data = t.data), n[i] = e
                    }
                    l.attributes = n, l.index = e
                }

                function y() {
                    const t = l.newAttributes;
                    for (let e = 0, n = t.length; e < n; e++) t[e] = 0
                }

                function _(t) {
                    b(t, 0)
                }

                function b(n, i) {
                    const o = l.newAttributes,
                        a = l.enabledAttributes,
                        s = l.attributeDivisors;
                    if (o[n] = 1, 0 === a[n] && (t.enableVertexAttribArray(n), a[n] = 1), s[n] !== i) {
                        const o = r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays");
                        o[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), s[n] = i
                    }
                }

                function x() {
                    const e = l.newAttributes,
                        n = l.enabledAttributes;
                    for (let r = 0, i = n.length; r < i; r++) n[r] !== e[r] && (t.disableVertexAttribArray(r), n[r] = 0)
                }

                function w(e, n, i, o, a, s) {
                    !0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? t.vertexAttribPointer(e, n, i, o, a, s) : t.vertexAttribIPointer(e, n, i, a, s)
                }

                function M(i, o, a, s) {
                    if (!1 === r.isWebGL2 && (i.isInstancedMesh || s.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                    y();
                    const c = s.attributes,
                        l = a.getAttributes(),
                        u = o.defaultAttributeValues;
                    for (const e in l) {
                        const r = l[e];
                        if (r >= 0) {
                            const o = c[e];
                            if (void 0 !== o) {
                                const e = o.normalized,
                                    i = o.itemSize,
                                    a = n.get(o);
                                if (void 0 === a) continue;
                                const c = a.buffer,
                                    l = a.type,
                                    u = a.bytesPerElement;
                                if (o.isInterleavedBufferAttribute) {
                                    const n = o.data,
                                        a = n.stride,
                                        h = o.offset;
                                    n && n.isInstancedInterleavedBuffer ? (b(r, n.meshPerAttribute), void 0 === s._maxInstanceCount && (s._maxInstanceCount = n.meshPerAttribute * n.count)) : _(r), t.bindBuffer(34962, c), w(r, i, l, e, a * u, h * u)
                                } else o.isInstancedBufferAttribute ? (b(r, o.meshPerAttribute), void 0 === s._maxInstanceCount && (s._maxInstanceCount = o.meshPerAttribute * o.count)) : _(r), t.bindBuffer(34962, c), w(r, i, l, e, 0, 0)
                            } else if ("instanceMatrix" === e) {
                                const e = n.get(i.instanceMatrix);
                                if (void 0 === e) continue;
                                const o = e.buffer,
                                    a = e.type;
                                b(r + 0, 1), b(r + 1, 1), b(r + 2, 1), b(r + 3, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(r + 0, 4, a, !1, 64, 0), t.vertexAttribPointer(r + 1, 4, a, !1, 64, 16), t.vertexAttribPointer(r + 2, 4, a, !1, 64, 32), t.vertexAttribPointer(r + 3, 4, a, !1, 64, 48)
                            } else if ("instanceColor" === e) {
                                const e = n.get(i.instanceColor);
                                if (void 0 === e) continue;
                                const o = e.buffer,
                                    a = e.type;
                                b(r, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(r, 3, a, !1, 12, 0)
                            } else if (void 0 !== u) {
                                const n = u[e];
                                if (void 0 !== n) switch (n.length) {
                                    case 2:
                                        t.vertexAttrib2fv(r, n);
                                        break;
                                    case 3:
                                        t.vertexAttrib3fv(r, n);
                                        break;
                                    case 4:
                                        t.vertexAttrib4fv(r, n);
                                        break;
                                    default:
                                        t.vertexAttrib1fv(r, n)
                                }
                            }
                        }
                    }
                    x()
                }

                function T() {
                    A();
                    for (const t in s) {
                        const e = s[t];
                        for (const t in e) {
                            const n = e[t];
                            for (const t in n) p(n[t].object), delete n[t];
                            delete e[t]
                        }
                        delete s[t]
                    }
                }

                function S(t) {
                    if (void 0 === s[t.id]) return;
                    const e = s[t.id];
                    for (const n in e) {
                        const t = e[n];
                        for (const e in t) p(t[e].object), delete t[e];
                        delete e[n]
                    }
                    delete s[t.id]
                }

                function E(t) {
                    for (const e in s) {
                        const n = s[e];
                        if (void 0 === n[t.id]) continue;
                        const r = n[t.id];
                        for (const t in r) p(r[t].object), delete r[t];
                        delete n[t.id]
                    }
                }

                function A() {
                    L(), l !== c && (l = c, d(l.object))
                }

                function L() {
                    c.geometry = null, c.program = null, c.wireframe = !1
                }
                return {
                    setup: u,
                    reset: A,
                    resetDefaultState: L,
                    dispose: T,
                    releaseStatesOfGeometry: S,
                    releaseStatesOfProgram: E,
                    initAttributes: y,
                    enableAttribute: _,
                    disableUnusedAttributes: x
                }
            }

            function Ls(t, e, n, r) {
                const i = r.isWebGL2;
                let o;

                function a(t) {
                    o = t
                }

                function s(e, r) {
                    t.drawArrays(o, e, r), n.update(r, o, 1)
                }

                function c(r, a, s) {
                    if (0 === s) return;
                    let c, l;
                    if (i) c = t, l = "drawArraysInstanced";
                    else if (c = e.get("ANGLE_instanced_arrays"), l = "drawArraysInstancedANGLE", null === c) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    c[l](o, r, a, s), n.update(a, o, s)
                }
                this.setMode = a, this.render = s, this.renderInstances = c
            }

            function Rs(t, e, n) {
                let r;

                function i() {
                    if (void 0 !== r) return r;
                    const n = e.get("EXT_texture_filter_anisotropic");
                    return r = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, r
                }

                function o(e) {
                    if ("highp" === e) {
                        if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        e = "mediump"
                    }
                    return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                const a = "undefined" !== typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" !== typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
                let s = void 0 !== n.precision ? n.precision : "highp";
                const c = o(s);
                c !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", c, "instead."), s = c);
                const l = !0 === n.logarithmicDepthBuffer,
                    u = t.getParameter(34930),
                    h = t.getParameter(35660),
                    d = t.getParameter(3379),
                    p = t.getParameter(34076),
                    f = t.getParameter(34921),
                    m = t.getParameter(36347),
                    g = t.getParameter(36348),
                    v = t.getParameter(36349),
                    y = h > 0,
                    _ = a || !!e.get("OES_texture_float"),
                    b = y && _,
                    x = a ? t.getParameter(36183) : 0;
                return {
                    isWebGL2: a,
                    getMaxAnisotropy: i,
                    getMaxPrecision: o,
                    precision: s,
                    logarithmicDepthBuffer: l,
                    maxTextures: u,
                    maxVertexTextures: h,
                    maxTextureSize: d,
                    maxCubemapSize: p,
                    maxAttributes: f,
                    maxVertexUniforms: m,
                    maxVaryings: g,
                    maxFragmentUniforms: v,
                    vertexTextures: y,
                    floatFragmentTextures: _,
                    floatVertexTextures: b,
                    maxSamples: x
                }
            }

            function Cs(t) {
                const e = this;
                let n = null,
                    r = 0,
                    i = !1,
                    o = !1;
                const a = new Mr,
                    s = new hn,
                    c = {
                        value: null,
                        needsUpdate: !1
                    };

                function l() {
                    c.value !== n && (c.value = n, c.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0
                }

                function u(t, n, r, i) {
                    const o = null !== t ? t.length : 0;
                    let l = null;
                    if (0 !== o) {
                        if (l = c.value, !0 !== i || null === l) {
                            const e = r + 4 * o,
                                i = n.matrixWorldInverse;
                            s.getNormalMatrix(i), (null === l || l.length < e) && (l = new Float32Array(e));
                            for (let n = 0, c = r; n !== o; ++n, c += 4) a.copy(t[n]).applyMatrix4(i, s), a.normal.toArray(l, c), l[c + 3] = a.constant
                        }
                        c.value = l, c.needsUpdate = !0
                    }
                    return e.numPlanes = o, e.numIntersection = 0, l
                }
                this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, o) {
                    const a = 0 !== t.length || e || 0 !== r || i;
                    return i = e, n = u(t, o, 0), r = t.length, a
                }, this.beginShadows = function() {
                    o = !0, u(null)
                }, this.endShadows = function() {
                    o = !1, l()
                }, this.setState = function(e, a, s) {
                    const h = e.clippingPlanes,
                        d = e.clipIntersection,
                        p = e.clipShadows,
                        f = t.get(e);
                    if (!i || null === h || 0 === h.length || o && !p) o ? u(null) : l();
                    else {
                        const t = o ? 0 : r,
                            e = 4 * t;
                        let i = f.clippingState || null;
                        c.value = i, i = u(h, a, e, s);
                        for (let r = 0; r !== e; ++r) i[r] = n[r];
                        f.clippingState = i, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                    }
                }
            }

            function Os(t) {
                let e = new WeakMap;

                function n(t, e) {
                    return e === it ? t.mapping = nt : e === ot && (t.mapping = rt), t
                }

                function r(r) {
                    if (r && r.isTexture) {
                        const o = r.mapping;
                        if (o === it || o === ot) {
                            if (e.has(r)) {
                                const t = e.get(r).texture;
                                return n(t, r.mapping)
                            } {
                                const o = r.image;
                                if (o && o.height > 0) {
                                    const a = t.getRenderList(),
                                        s = t.getRenderTarget(),
                                        c = t.getRenderState(),
                                        l = new qi(o.height / 2);
                                    return l.fromEquirectangularTexture(t, r), e.set(r, l), t.setRenderTarget(s), t.setRenderList(a), t.setRenderState(c), r.addEventListener("dispose", i), n(l.texture, r.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return r
                }

                function i(t) {
                    const n = t.target;
                    n.removeEventListener("dispose", i);
                    const r = e.get(n);
                    void 0 !== r && (e.delete(n), r.dispose())
                }

                function o() {
                    e = new WeakMap
                }
                return {
                    get: r,
                    dispose: o
                }
            }

            function Ps(t) {
                const e = {};
                return {
                    has: function(n) {
                        if (void 0 !== e[n]) return null !== e[n];
                        let r;
                        switch (n) {
                            case "WEBGL_depth_texture":
                                r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                r = t.getExtension(n)
                        }
                        return e[n] = r, null !== r
                    },
                    get: function(t) {
                        return this.has(t) || console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e[t]
                    }
                }
            }

            function Is(t, e, n, r) {
                const i = new WeakMap,
                    o = new WeakMap;

                function a(t) {
                    const s = t.target,
                        c = i.get(s);
                    null !== c.index && e.remove(c.index);
                    for (const n in c.attributes) e.remove(c.attributes[n]);
                    s.removeEventListener("dispose", a), i.delete(s);
                    const l = o.get(c);
                    l && (e.remove(l), o.delete(c)), r.releaseStatesOfGeometry(c), !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount, n.memory.geometries--
                }

                function s(t, e) {
                    let r = i.get(e);
                    return r || (e.addEventListener("dispose", a), e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new pi).setFromObject(t)), r = e._bufferGeometry), i.set(e, r), n.memory.geometries++, r)
                }

                function c(t) {
                    const n = t.attributes;
                    for (const i in n) e.update(n[i], 34962);
                    const r = t.morphAttributes;
                    for (const i in r) {
                        const t = r[i];
                        for (let n = 0, r = t.length; n < r; n++) e.update(t[n], 34962)
                    }
                }

                function l(t) {
                    const n = [],
                        r = t.index,
                        i = t.attributes.position;
                    let a = 0;
                    if (null !== r) {
                        const t = r.array;
                        a = r.version;
                        for (let e = 0, r = t.length; e < r; e += 3) {
                            const r = t[e + 0],
                                i = t[e + 1],
                                o = t[e + 2];
                            n.push(r, i, i, o, o, r)
                        }
                    } else {
                        const t = i.array;
                        a = i.version;
                        for (let e = 0, r = t.length / 3 - 1; e < r; e += 3) {
                            const t = e + 0,
                                r = e + 1,
                                i = e + 2;
                            n.push(t, r, r, i, i, t)
                        }
                    }
                    const s = new(oi(n) > 65535 ? ei : Qr)(n, 1);
                    s.version = a;
                    const c = o.get(t);
                    c && e.remove(c), o.set(t, s)
                }

                function u(t) {
                    const e = o.get(t);
                    if (e) {
                        const n = t.index;
                        null !== n && e.version < n.version && l(t)
                    } else l(t);
                    return o.get(t)
                }
                return {
                    get: s,
                    update: c,
                    getWireframeAttribute: u
                }
            }

            function Ns(t, e, n, r) {
                const i = r.isWebGL2;
                let o, a, s;

                function c(t) {
                    o = t
                }

                function l(t) {
                    a = t.type, s = t.bytesPerElement
                }

                function u(e, r) {
                    t.drawElements(o, r, a, e * s), n.update(r, o, 1)
                }

                function h(r, c, l) {
                    if (0 === l) return;
                    let u, h;
                    if (i) u = t, h = "drawElementsInstanced";
                    else if (u = e.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    u[h](o, c, a, r * s, l), n.update(c, o, l)
                }
                this.setMode = c, this.setIndex = l, this.render = u, this.renderInstances = h
            }

            function Ds(t) {
                const e = {
                        geometries: 0,
                        textures: 0
                    },
                    n = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0
                    };

                function r(t, e, r) {
                    switch (n.calls++, e) {
                        case 4:
                            n.triangles += r * (t / 3);
                            break;
                        case 1:
                            n.lines += r * (t / 2);
                            break;
                        case 3:
                            n.lines += r * (t - 1);
                            break;
                        case 2:
                            n.lines += r * t;
                            break;
                        case 0:
                            n.points += r * t;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", e);
                            break
                    }
                }

                function i() {
                    n.frame++, n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0
                }
                return {
                    memory: e,
                    render: n,
                    programs: null,
                    autoReset: !0,
                    reset: i,
                    update: r
                }
            }

            function ks(t, e) {
                return t[0] - e[0]
            }

            function Fs(t, e) {
                return Math.abs(e[1]) - Math.abs(t[1])
            }

            function Bs(t) {
                const e = {},
                    n = new Float32Array(8),
                    r = [];
                for (let o = 0; o < 8; o++) r[o] = [o, 0];

                function i(i, o, a, s) {
                    const c = i.morphTargetInfluences,
                        l = void 0 === c ? 0 : c.length;
                    let u = e[o.id];
                    if (void 0 === u) {
                        u = [];
                        for (let t = 0; t < l; t++) u[t] = [t, 0];
                        e[o.id] = u
                    }
                    for (let t = 0; t < l; t++) {
                        const e = u[t];
                        e[0] = t, e[1] = c[t]
                    }
                    u.sort(Fs);
                    for (let t = 0; t < 8; t++) t < l && u[t][1] ? (r[t][0] = u[t][0], r[t][1] = u[t][1]) : (r[t][0] = Number.MAX_SAFE_INTEGER, r[t][1] = 0);
                    r.sort(ks);
                    const h = a.morphTargets && o.morphAttributes.position,
                        d = a.morphNormals && o.morphAttributes.normal;
                    let p = 0;
                    for (let t = 0; t < 8; t++) {
                        const e = r[t],
                            i = e[0],
                            a = e[1];
                        i !== Number.MAX_SAFE_INTEGER && a ? (h && o.getAttribute("morphTarget" + t) !== h[i] && o.setAttribute("morphTarget" + t, h[i]), d && o.getAttribute("morphNormal" + t) !== d[i] && o.setAttribute("morphNormal" + t, d[i]), n[t] = a, p += a) : (h && void 0 !== o.getAttribute("morphTarget" + t) && o.deleteAttribute("morphTarget" + t), d && void 0 !== o.getAttribute("morphNormal" + t) && o.deleteAttribute("morphNormal" + t), n[t] = 0)
                    }
                    const f = o.morphTargetsRelative ? 1 : 1 - p;
                    s.getUniforms().setValue(t, "morphTargetBaseInfluence", f), s.getUniforms().setValue(t, "morphTargetInfluences", n)
                }
                return {
                    update: i
                }
            }

            function Us(t, e, n, r) {
                let i = new WeakMap;

                function o(t) {
                    const o = r.render.frame,
                        a = t.geometry,
                        s = e.get(t, a);
                    return i.get(s) !== o && (a.isGeometry && s.updateFromObject(t), e.update(s), i.set(s, o)), t.isInstancedMesh && (n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), s
                }

                function a() {
                    i = new WeakMap
                }
                return {
                    update: o,
                    dispose: a
                }
            }

            function Hs(t, e, n, r) {
                mn.call(this, null), this.image = {
                    data: t || null,
                    width: e || 1,
                    height: n || 1,
                    depth: r || 1
                }, this.magFilter = ht, this.minFilter = ht, this.wrapR = lt, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
            }

            function zs(t, e, n, r) {
                mn.call(this, null), this.image = {
                    data: t || null,
                    width: e || 1,
                    height: n || 1,
                    depth: r || 1
                }, this.magFilter = ht, this.minFilter = ht, this.wrapR = lt, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
            }
            Ss.physical = {
                uniforms: ki([Ss.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatNormalScale: {
                        value: new un(1, 1)
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    sheen: {
                        value: new zr(0)
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    }
                }]),
                vertexShader: Ms.meshphysical_vert,
                fragmentShader: Ms.meshphysical_frag
            }, Hs.prototype = Object.create(mn.prototype), Hs.prototype.constructor = Hs, Hs.prototype.isDataTexture2DArray = !0, zs.prototype = Object.create(mn.prototype), zs.prototype.constructor = zs, zs.prototype.isDataTexture3D = !0;
            const js = new mn,
                Gs = new Hs,
                Vs = new zs,
                Ws = new Xi,
                Xs = [],
                qs = [],
                Ys = new Float32Array(16),
                $s = new Float32Array(9),
                Zs = new Float32Array(4);

            function Js(t, e, n) {
                const r = t[0];
                if (r <= 0 || r > 0) return t;
                const i = e * n;
                let o = Xs[i];
                if (void 0 === o && (o = new Float32Array(i), Xs[i] = o), 0 !== e) {
                    r.toArray(o, 0);
                    for (let r = 1, i = 0; r !== e; ++r) i += n, t[r].toArray(o, i)
                }
                return o
            }

            function Ks(t, e) {
                if (t.length !== e.length) return !1;
                for (let n = 0, r = t.length; n < r; n++)
                    if (t[n] !== e[n]) return !1;
                return !0
            }

            function Qs(t, e) {
                for (let n = 0, r = e.length; n < r; n++) t[n] = e[n]
            }

            function tc(t, e) {
                let n = qs[e];
                void 0 === n && (n = new Int32Array(e), qs[e] = n);
                for (let r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
                return n
            }

            function ec(t, e) {
                const n = this.cache;
                n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
            }

            function nc(t, e) {
                const n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                else {
                    if (Ks(n, e)) return;
                    t.uniform2fv(this.addr, e), Qs(n, e)
                }
            }

            function rc(t, e) {
                const n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                else {
                    if (Ks(n, e)) return;
                    t.uniform3fv(this.addr, e), Qs(n, e)
                }
            }

            function ic(t, e) {
                const n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                else {
                    if (Ks(n, e)) return;
                    t.uniform4fv(this.addr, e), Qs(n, e)
                }
            }

            function oc(t, e) {
                const n = this.cache,
                    r = e.elements;
                if (void 0 === r) {
                    if (Ks(n, e)) return;
                    t.uniformMatrix2fv(this.addr, !1, e), Qs(n, e)
                } else {
                    if (Ks(n, r)) return;
                    Zs.set(r), t.uniformMatrix2fv(this.addr, !1, Zs), Qs(n, r)
                }
            }

            function ac(t, e) {
                const n = this.cache,
                    r = e.elements;
                if (void 0 === r) {
                    if (Ks(n, e)) return;
                    t.uniformMatrix3fv(this.addr, !1, e), Qs(n, e)
                } else {
                    if (Ks(n, r)) return;
                    $s.set(r), t.uniformMatrix3fv(this.addr, !1, $s), Qs(n, r)
                }
            }

            function sc(t, e) {
                const n = this.cache,
                    r = e.elements;
                if (void 0 === r) {
                    if (Ks(n, e)) return;
                    t.uniformMatrix4fv(this.addr, !1, e), Qs(n, e)
                } else {
                    if (Ks(n, r)) return;
                    Ys.set(r), t.uniformMatrix4fv(this.addr, !1, Ys), Qs(n, r)
                }
            }

            function cc(t, e, n) {
                const r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(e || js, i)
            }

            function lc(t, e, n) {
                const r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(e || Gs, i)
            }

            function uc(t, e, n) {
                const r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(e || Vs, i)
            }

            function hc(t, e, n) {
                const r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(e || Ws, i)
            }

            function dc(t, e) {
                const n = this.cache;
                n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
            }

            function pc(t, e) {
                const n = this.cache;
                Ks(n, e) || (t.uniform2iv(this.addr, e), Qs(n, e))
            }

            function fc(t, e) {
                const n = this.cache;
                Ks(n, e) || (t.uniform3iv(this.addr, e), Qs(n, e))
            }

            function mc(t, e) {
                const n = this.cache;
                Ks(n, e) || (t.uniform4iv(this.addr, e), Qs(n, e))
            }

            function gc(t, e) {
                const n = this.cache;
                n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
            }

            function vc(t) {
                switch (t) {
                    case 5126:
                        return ec;
                    case 35664:
                        return nc;
                    case 35665:
                        return rc;
                    case 35666:
                        return ic;
                    case 35674:
                        return oc;
                    case 35675:
                        return ac;
                    case 35676:
                        return sc;
                    case 5124:
                    case 35670:
                        return dc;
                    case 35667:
                    case 35671:
                        return pc;
                    case 35668:
                    case 35672:
                        return fc;
                    case 35669:
                    case 35673:
                        return mc;
                    case 5125:
                        return gc;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return cc;
                    case 35679:
                    case 36299:
                    case 36307:
                        return uc;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return hc;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return lc
                }
            }

            function yc(t, e) {
                t.uniform1fv(this.addr, e)
            }

            function _c(t, e) {
                t.uniform1iv(this.addr, e)
            }

            function bc(t, e) {
                t.uniform2iv(this.addr, e)
            }

            function xc(t, e) {
                t.uniform3iv(this.addr, e)
            }

            function wc(t, e) {
                t.uniform4iv(this.addr, e)
            }

            function Mc(t, e) {
                const n = Js(e, this.size, 2);
                t.uniform2fv(this.addr, n)
            }

            function Tc(t, e) {
                const n = Js(e, this.size, 3);
                t.uniform3fv(this.addr, n)
            }

            function Sc(t, e) {
                const n = Js(e, this.size, 4);
                t.uniform4fv(this.addr, n)
            }

            function Ec(t, e) {
                const n = Js(e, this.size, 4);
                t.uniformMatrix2fv(this.addr, !1, n)
            }

            function Ac(t, e) {
                const n = Js(e, this.size, 9);
                t.uniformMatrix3fv(this.addr, !1, n)
            }

            function Lc(t, e) {
                const n = Js(e, this.size, 16);
                t.uniformMatrix4fv(this.addr, !1, n)
            }

            function Rc(t, e, n) {
                const r = e.length,
                    i = tc(n, r);
                t.uniform1iv(this.addr, i);
                for (let o = 0; o !== r; ++o) n.safeSetTexture2D(e[o] || js, i[o])
            }

            function Cc(t, e, n) {
                const r = e.length,
                    i = tc(n, r);
                t.uniform1iv(this.addr, i);
                for (let o = 0; o !== r; ++o) n.safeSetTextureCube(e[o] || Ws, i[o])
            }

            function Oc(t) {
                switch (t) {
                    case 5126:
                        return yc;
                    case 35664:
                        return Mc;
                    case 35665:
                        return Tc;
                    case 35666:
                        return Sc;
                    case 35674:
                        return Ec;
                    case 35675:
                        return Ac;
                    case 35676:
                        return Lc;
                    case 5124:
                    case 35670:
                        return _c;
                    case 35667:
                    case 35671:
                        return bc;
                    case 35668:
                    case 35672:
                        return xc;
                    case 35669:
                    case 35673:
                        return wc;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return Rc;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Cc
                }
            }

            function Pc(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.setValue = vc(e.type)
            }

            function Ic(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = Oc(e.type)
            }

            function Nc(t) {
                this.id = t, this.seq = [], this.map = {}
            }
            Ic.prototype.updateCache = function(t) {
                const e = this.cache;
                t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Qs(e, t)
            }, Nc.prototype.setValue = function(t, e, n) {
                const r = this.seq;
                for (let i = 0, o = r.length; i !== o; ++i) {
                    const o = r[i];
                    o.setValue(t, e[o.id], n)
                }
            };
            const Dc = /([\w\d_]+)(\])?(\[|\.)?/g;

            function kc(t, e) {
                t.seq.push(e), t.map[e.id] = e
            }

            function Fc(t, e, n) {
                const r = t.name,
                    i = r.length;
                Dc.lastIndex = 0;
                while (1) {
                    const o = Dc.exec(r),
                        a = Dc.lastIndex;
                    let s = o[1];
                    const c = "]" === o[2],
                        l = o[3];
                    if (c && (s |= 0), void 0 === l || "[" === l && a + 2 === i) {
                        kc(n, void 0 === l ? new Pc(s, t, e) : new Ic(s, t, e));
                        break
                    } {
                        const t = n.map;
                        let e = t[s];
                        void 0 === e && (e = new Nc(s), kc(n, e)), n = e
                    }
                }
            }

            function Bc(t, e) {
                this.seq = [], this.map = {};
                const n = t.getProgramParameter(e, 35718);
                for (let r = 0; r < n; ++r) {
                    const n = t.getActiveUniform(e, r),
                        i = t.getUniformLocation(e, n.name);
                    Fc(n, i, this)
                }
            }

            function Uc(t, e, n) {
                const r = t.createShader(e);
                return t.shaderSource(r, n), t.compileShader(r), r
            }
            Bc.prototype.setValue = function(t, e, n, r) {
                const i = this.map[e];
                void 0 !== i && i.setValue(t, n, r)
            }, Bc.prototype.setOptional = function(t, e, n) {
                const r = e[n];
                void 0 !== r && this.setValue(t, n, r)
            }, Bc.upload = function(t, e, n, r) {
                for (let i = 0, o = e.length; i !== o; ++i) {
                    const o = e[i],
                        a = n[o.id];
                    !1 !== a.needsUpdate && o.setValue(t, a.value, r)
                }
            }, Bc.seqWithValue = function(t, e) {
                const n = [];
                for (let r = 0, i = t.length; r !== i; ++r) {
                    const i = t[r];
                    i.id in e && n.push(i)
                }
                return n
            };
            let Hc = 0;

            function zc(t) {
                const e = t.split("\n");
                for (let n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
                return e.join("\n")
            }

            function jc(t) {
                switch (t) {
                    case je:
                        return ["Linear", "( value )"];
                    case Ge:
                        return ["sRGB", "( value )"];
                    case We:
                        return ["RGBE", "( value )"];
                    case qe:
                        return ["RGBM", "( value, 7.0 )"];
                    case Ye:
                        return ["RGBM", "( value, 16.0 )"];
                    case $e:
                        return ["RGBD", "( value, 256.0 )"];
                    case Ve:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    case Xe:
                        return ["LogLuv", "( value )"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
                }
            }

            function Gc(t, e, n) {
                const r = t.getShaderParameter(e, 35713),
                    i = t.getShaderInfoLog(e).trim();
                if (r && "" === i) return "";
                const o = t.getShaderSource(e);
                return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + i + zc(o)
            }

            function Vc(t, e) {
                const n = jc(e);
                return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
            }

            function Wc(t, e) {
                const n = jc(e);
                return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
            }

            function Xc(t, e) {
                let n;
                switch (e) {
                    case Z:
                        n = "Linear";
                        break;
                    case J:
                        n = "Reinhard";
                        break;
                    case K:
                        n = "OptimizedCineon";
                        break;
                    case Q:
                        n = "ACESFilmic";
                        break;
                    case tt:
                        n = "Custom";
                        break;
                    default:
                        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
                }
                return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
            }

            function qc(t) {
                const e = [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
                return e.filter(Zc).join("\n")
            }

            function Yc(t) {
                const e = [];
                for (const n in t) {
                    const r = t[n];
                    !1 !== r && e.push("#define " + n + " " + r)
                }
                return e.join("\n")
            }

            function $c(t, e) {
                const n = {},
                    r = t.getProgramParameter(e, 35721);
                for (let i = 0; i < r; i++) {
                    const r = t.getActiveAttrib(e, i),
                        o = r.name;
                    n[o] = t.getAttribLocation(e, o)
                }
                return n
            }

            function Zc(t) {
                return "" !== t
            }

            function Jc(t, e) {
                return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
            }

            function Kc(t, e) {
                return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
            }
            const Qc = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function tl(t) {
                return t.replace(Qc, el)
            }

            function el(t, e) {
                const n = Ms[e];
                if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
                return tl(n)
            }
            const nl = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                rl = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

            function il(t) {
                return t.replace(rl, al).replace(nl, ol)
            }

            function ol(t, e, n, r) {
                return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), al(t, e, n, r)
            }

            function al(t, e, n, r) {
                let i = "";
                for (let o = parseInt(e); o < parseInt(n); o++) i += r.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
                return i
            }

            function sl(t) {
                let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
                return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
            }

            function cl(t) {
                let e = "SHADOWMAP_TYPE_BASIC";
                return t.shadowMapType === l ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === u ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === h && (e = "SHADOWMAP_TYPE_VSM"), e
            }

            function ll(t) {
                let e = "ENVMAP_TYPE_CUBE";
                if (t.envMap) switch (t.envMapMode) {
                    case nt:
                    case rt:
                        e = "ENVMAP_TYPE_CUBE";
                        break;
                    case at:
                    case st:
                        e = "ENVMAP_TYPE_CUBE_UV";
                        break
                }
                return e
            }

            function ul(t) {
                let e = "ENVMAP_MODE_REFLECTION";
                if (t.envMap) switch (t.envMapMode) {
                    case rt:
                    case st:
                        e = "ENVMAP_MODE_REFRACTION";
                        break
                }
                return e
            }

            function hl(t) {
                let e = "ENVMAP_BLENDING_NONE";
                if (t.envMap) switch (t.combine) {
                    case X:
                        e = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case q:
                        e = "ENVMAP_BLENDING_MIX";
                        break;
                    case Y:
                        e = "ENVMAP_BLENDING_ADD";
                        break
                }
                return e
            }

            function dl(t, e, n, r) {
                const i = t.getContext(),
                    o = n.defines;
                let a = n.vertexShader,
                    s = n.fragmentShader;
                const c = cl(n),
                    l = ll(n),
                    u = ul(n),
                    h = hl(n),
                    d = t.gammaFactor > 0 ? t.gammaFactor : 1,
                    p = n.isWebGL2 ? "" : qc(n),
                    f = Yc(o),
                    m = i.createProgram();
                let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                n.isRawShaderMaterial ? (g = [f].filter(Zc).join("\n"), g.length > 0 && (g += "\n"), v = [p, f].filter(Zc).join("\n"), v.length > 0 && (v += "\n")) : (g = [sl(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Zc).join("\n"), v = [p, sl(n), "#define SHADER_NAME " + n.shaderName, f, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + l : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== $ ? "#define TONE_MAPPING" : "", n.toneMapping !== $ ? Ms["tonemapping_pars_fragment"] : "", n.toneMapping !== $ ? Xc("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", Ms["encodings_pars_fragment"], n.map ? Vc("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Vc("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Vc("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Vc("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? Vc("lightMapTexelToLinear", n.lightMapEncoding) : "", Wc("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Zc).join("\n")), a = tl(a), a = Jc(a, n), a = Kc(a, n), s = tl(s), s = Jc(s, n), s = Kc(s, n), a = il(a), s = il(s), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", n.glslVersion === on ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === on ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
                const _ = y + g + a,
                    b = y + v + s,
                    x = Uc(i, 35633, _),
                    w = Uc(i, 35632, b);
                if (i.attachShader(m, x), i.attachShader(m, w), void 0 !== n.index0AttributeName ? i.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(m, 0, "position"), i.linkProgram(m), t.debug.checkShaderErrors) {
                    const t = i.getProgramInfoLog(m).trim(),
                        e = i.getShaderInfoLog(x).trim(),
                        n = i.getShaderInfoLog(w).trim();
                    let r = !0,
                        o = !0;
                    if (!1 === i.getProgramParameter(m, 35714)) {
                        r = !1;
                        const e = Gc(i, x, "vertex"),
                            n = Gc(i, w, "fragment");
                        console.error("THREE.WebGLProgram: shader error: ", i.getError(), "35715", i.getProgramParameter(m, 35715), "gl.getProgramInfoLog", t, e, n)
                    } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (o = !1);
                    o && (this.diagnostics = {
                        runnable: r,
                        programLog: t,
                        vertexShader: {
                            log: e,
                            prefix: g
                        },
                        fragmentShader: {
                            log: n,
                            prefix: v
                        }
                    })
                }
                let M, T;
                return i.deleteShader(x), i.deleteShader(w), this.getUniforms = function() {
                    return void 0 === M && (M = new Bc(i, m)), M
                }, this.getAttributes = function() {
                    return void 0 === T && (T = $c(i, m)), T
                }, this.destroy = function() {
                    r.releaseStatesOfProgram(this), i.deleteProgram(m), this.program = void 0
                }, this.name = n.shaderName, this.id = Hc++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = x, this.fragmentShader = w, this
            }

            function pl(t, e, n, r, i, o) {
                const a = [],
                    s = r.isWebGL2,
                    c = r.logarithmicDepthBuffer,
                    l = r.floatVertexTextures,
                    u = r.maxVertexUniforms,
                    h = r.vertexTextures;
                let d = r.precision;
                const m = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    },
                    g = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];

                function v(t) {
                    const e = t.skeleton,
                        n = e.bones;
                    if (l) return 1024; {
                        const t = u,
                            e = Math.floor((t - 20) / 4),
                            r = Math.min(e, n.length);
                        return r < n.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + n.length + " bones. This GPU supports " + r + "."), 0) : r
                    }
                }

                function y(t) {
                    let e;
                    return t ? t.isTexture ? e = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = je, e
                }

                function _(i, a, u, g, _) {
                    const b = g.fog,
                        x = i.isMeshStandardMaterial ? g.environment : null,
                        w = e.get(i.envMap || x),
                        M = m[i.type],
                        T = _.isSkinnedMesh ? v(_) : 0;
                    let S, E;
                    if (null !== i.precision && (d = r.getMaxPrecision(i.precision), d !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", d, "instead.")), M) {
                        const t = Ss[M];
                        S = t.vertexShader, E = t.fragmentShader
                    } else S = i.vertexShader, E = i.fragmentShader;
                    const A = t.getRenderTarget(),
                        L = {
                            isWebGL2: s,
                            shaderID: M,
                            shaderName: i.type,
                            vertexShader: S,
                            fragmentShader: E,
                            defines: i.defines,
                            isRawShaderMaterial: !0 === i.isRawShaderMaterial,
                            glslVersion: i.glslVersion,
                            precision: d,
                            instancing: !0 === _.isInstancedMesh,
                            instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor,
                            supportsVertexTextures: h,
                            outputEncoding: null !== A ? y(A.texture) : t.outputEncoding,
                            map: !!i.map,
                            mapEncoding: y(i.map),
                            matcap: !!i.matcap,
                            matcapEncoding: y(i.matcap),
                            envMap: !!w,
                            envMapMode: w && w.mapping,
                            envMapEncoding: y(w),
                            envMapCubeUV: !!w && (w.mapping === at || w.mapping === st),
                            lightMap: !!i.lightMap,
                            lightMapEncoding: y(i.lightMap),
                            aoMap: !!i.aoMap,
                            emissiveMap: !!i.emissiveMap,
                            emissiveMapEncoding: y(i.emissiveMap),
                            bumpMap: !!i.bumpMap,
                            normalMap: !!i.normalMap,
                            objectSpaceNormalMap: i.normalMapType === Qe,
                            tangentSpaceNormalMap: i.normalMapType === Ke,
                            clearcoatMap: !!i.clearcoatMap,
                            clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
                            clearcoatNormalMap: !!i.clearcoatNormalMap,
                            displacementMap: !!i.displacementMap,
                            roughnessMap: !!i.roughnessMap,
                            metalnessMap: !!i.metalnessMap,
                            specularMap: !!i.specularMap,
                            alphaMap: !!i.alphaMap,
                            gradientMap: !!i.gradientMap,
                            sheen: !!i.sheen,
                            transmissionMap: !!i.transmissionMap,
                            combine: i.combine,
                            vertexTangents: i.normalMap && i.vertexTangents,
                            vertexColors: i.vertexColors,
                            vertexUvs: !!i.map || !!i.bumpMap || !!i.normalMap || !!i.specularMap || !!i.alphaMap || !!i.emissiveMap || !!i.roughnessMap || !!i.metalnessMap || !!i.clearcoatMap || !!i.clearcoatRoughnessMap || !!i.clearcoatNormalMap || !!i.displacementMap || !!i.transmissionMap,
                            uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || i.transmissionMap) && !!i.displacementMap,
                            fog: !!b,
                            useFog: i.fog,
                            fogExp2: b && b.isFogExp2,
                            flatShading: i.flatShading,
                            sizeAttenuation: i.sizeAttenuation,
                            logarithmicDepthBuffer: c,
                            skinning: i.skinning && T > 0,
                            maxBones: T,
                            useVertexTexture: l,
                            morphTargets: i.morphTargets,
                            morphNormals: i.morphNormals,
                            maxMorphTargets: t.maxMorphTargets,
                            maxMorphNormals: t.maxMorphNormals,
                            numDirLights: a.directional.length,
                            numPointLights: a.point.length,
                            numSpotLights: a.spot.length,
                            numRectAreaLights: a.rectArea.length,
                            numHemiLights: a.hemi.length,
                            numDirLightShadows: a.directionalShadowMap.length,
                            numPointLightShadows: a.pointShadowMap.length,
                            numSpotLightShadows: a.spotShadowMap.length,
                            numClippingPlanes: o.numPlanes,
                            numClipIntersection: o.numIntersection,
                            dithering: i.dithering,
                            shadowMapEnabled: t.shadowMap.enabled && u.length > 0,
                            shadowMapType: t.shadowMap.type,
                            toneMapping: i.toneMapped ? t.toneMapping : $,
                            physicallyCorrectLights: t.physicallyCorrectLights,
                            premultipliedAlpha: i.premultipliedAlpha,
                            alphaTest: i.alphaTest,
                            doubleSided: i.side === f,
                            flipSided: i.side === p,
                            depthPacking: void 0 !== i.depthPacking && i.depthPacking,
                            index0AttributeName: i.index0AttributeName,
                            extensionDerivatives: i.extensions && i.extensions.derivatives,
                            extensionFragDepth: i.extensions && i.extensions.fragDepth,
                            extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
                            extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD,
                            rendererExtensionFragDepth: s || n.has("EXT_frag_depth"),
                            rendererExtensionDrawBuffers: s || n.has("WEBGL_draw_buffers"),
                            rendererExtensionShaderTextureLod: s || n.has("EXT_shader_texture_lod"),
                            customProgramCacheKey: i.customProgramCacheKey()
                        };
                    return L
                }

                function b(e) {
                    const n = [];
                    if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                        for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                    if (!1 === e.isRawShaderMaterial) {
                        for (let t = 0; t < g.length; t++) n.push(e[g[t]]);
                        n.push(t.outputEncoding), n.push(t.gammaFactor)
                    }
                    return n.push(e.customProgramCacheKey), n.join()
                }

                function x(t) {
                    const e = m[t.type];
                    let n;
                    if (e) {
                        const t = Ss[e];
                        n = Fi.clone(t.uniforms)
                    } else n = t.uniforms;
                    return n
                }

                function w(e, n) {
                    let r;
                    for (let t = 0, i = a.length; t < i; t++) {
                        const e = a[t];
                        if (e.cacheKey === n) {
                            r = e, ++r.usedTimes;
                            break
                        }
                    }
                    return void 0 === r && (r = new dl(t, n, e, i), a.push(r)), r
                }

                function M(t) {
                    if (0 === --t.usedTimes) {
                        const e = a.indexOf(t);
                        a[e] = a[a.length - 1], a.pop(), t.destroy()
                    }
                }
                return {
                    getParameters: _,
                    getProgramCacheKey: b,
                    getUniforms: x,
                    acquireProgram: w,
                    releaseProgram: M,
                    programs: a
                }
            }

            function fl() {
                let t = new WeakMap;

                function e(e) {
                    let n = t.get(e);
                    return void 0 === n && (n = {}, t.set(e, n)), n
                }

                function n(e) {
                    t.delete(e)
                }

                function r(e, n, r) {
                    t.get(e)[n] = r
                }

                function i() {
                    t = new WeakMap
                }
                return {
                    get: e,
                    remove: n,
                    update: r,
                    dispose: i
                }
            }

            function ml(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
            }

            function gl(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
            }

            function vl(t) {
                const e = [];
                let n = 0;
                const r = [],
                    i = [],
                    o = {
                        id: -1
                    };

                function a() {
                    n = 0, r.length = 0, i.length = 0
                }

                function s(r, i, a, s, c, l) {
                    let u = e[n];
                    const h = t.get(a);
                    return void 0 === u ? (u = {
                        id: r.id,
                        object: r,
                        geometry: i,
                        material: a,
                        program: h.program || o,
                        groupOrder: s,
                        renderOrder: r.renderOrder,
                        z: c,
                        group: l
                    }, e[n] = u) : (u.id = r.id, u.object = r, u.geometry = i, u.material = a, u.program = h.program || o, u.groupOrder = s, u.renderOrder = r.renderOrder, u.z = c, u.group = l), n++, u
                }

                function c(t, e, n, o, a, c) {
                    const l = s(t, e, n, o, a, c);
                    (!0 === n.transparent ? i : r).push(l)
                }

                function l(t, e, n, o, a, c) {
                    const l = s(t, e, n, o, a, c);
                    (!0 === n.transparent ? i : r).unshift(l)
                }

                function u(t, e) {
                    r.length > 1 && r.sort(t || ml), i.length > 1 && i.sort(e || gl)
                }

                function h() {
                    for (let t = n, r = e.length; t < r; t++) {
                        const n = e[t];
                        if (null === n.id) break;
                        n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
                    }
                }
                return {
                    opaque: r,
                    transparent: i,
                    init: a,
                    push: c,
                    unshift: l,
                    finish: h,
                    sort: u
                }
            }

            function yl(t) {
                let e = new WeakMap;

                function n(n, r) {
                    const i = e.get(n);
                    let o;
                    return void 0 === i ? (o = new vl(t), e.set(n, new WeakMap), e.get(n).set(r, o)) : (o = i.get(r), void 0 === o && (o = new vl(t), i.set(r, o))), o
                }

                function r() {
                    e = new WeakMap
                }
                return {
                    get: n,
                    dispose: r
                }
            }

            function _l() {
                const t = {};
                return {
                    get: function(e) {
                        if (void 0 !== t[e.id]) return t[e.id];
                        let n;
                        switch (e.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new bn,
                                    color: new zr
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new bn,
                                    direction: new bn,
                                    color: new zr,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new bn,
                                    color: new zr,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new bn,
                                    skyColor: new zr,
                                    groundColor: new zr
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new zr,
                                    position: new bn,
                                    halfWidth: new bn,
                                    halfHeight: new bn
                                };
                                break
                        }
                        return t[e.id] = n, n
                    }
                }
            }

            function bl() {
                const t = {};
                return {
                    get: function(e) {
                        if (void 0 !== t[e.id]) return t[e.id];
                        let n;
                        switch (e.type) {
                            case "DirectionalLight":
                                n = {
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new un
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new un
                                };
                                break;
                            case "PointLight":
                                n = {
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new un,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                };
                                break
                        }
                        return t[e.id] = n, n
                    }
                }
            }
            let xl = 0;

            function wl(t, e) {
                return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
            }

            function Ml(t, e) {
                const n = new _l,
                    r = bl(),
                    i = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    };
                for (let l = 0; l < 9; l++) i.probe.push(new bn);
                const o = new bn,
                    a = new Yn,
                    s = new Yn;

                function c(c, l, u) {
                    let h = 0,
                        d = 0,
                        p = 0;
                    for (let t = 0; t < 9; t++) i.probe[t].set(0, 0, 0);
                    let f = 0,
                        m = 0,
                        g = 0,
                        v = 0,
                        y = 0,
                        _ = 0,
                        b = 0,
                        x = 0;
                    const w = u.matrixWorldInverse;
                    c.sort(wl);
                    for (let t = 0, e = c.length; t < e; t++) {
                        const e = c[t],
                            l = e.color,
                            u = e.intensity,
                            M = e.distance,
                            T = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                        if (e.isAmbientLight) h += l.r * u, d += l.g * u, p += l.b * u;
                        else if (e.isLightProbe)
                            for (let t = 0; t < 9; t++) i.probe[t].addScaledVector(e.sh.coefficients[t], u);
                        else if (e.isDirectionalLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity), t.direction.setFromMatrixPosition(e.matrixWorld), o.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(w), e.castShadow) {
                                const t = e.shadow,
                                    n = r.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, i.directionalShadow[f] = n, i.directionalShadowMap[f] = T, i.directionalShadowMatrix[f] = e.shadow.matrix, _++
                            }
                            i.directional[f] = t, f++
                        } else if (e.isSpotLight) {
                            const t = n.get(e);
                            if (t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(w), t.color.copy(l).multiplyScalar(u), t.distance = M, t.direction.setFromMatrixPosition(e.matrixWorld), o.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(w), t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) {
                                const t = e.shadow,
                                    n = r.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, i.spotShadow[g] = n, i.spotShadowMap[g] = T, i.spotShadowMatrix[g] = e.shadow.matrix, x++
                            }
                            i.spot[g] = t, g++
                        } else if (e.isRectAreaLight) {
                            const t = n.get(e);
                            t.color.copy(l).multiplyScalar(u), t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(w), s.identity(), a.copy(e.matrixWorld), a.premultiply(w), s.extractRotation(a), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), t.halfWidth.applyMatrix4(s), t.halfHeight.applyMatrix4(s), i.rectArea[v] = t, v++
                        } else if (e.isPointLight) {
                            const t = n.get(e);
                            if (t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(w), t.color.copy(e.color).multiplyScalar(e.intensity), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                                const t = e.shadow,
                                    n = r.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, i.pointShadow[m] = n, i.pointShadowMap[m] = T, i.pointShadowMatrix[m] = e.shadow.matrix, b++
                            }
                            i.point[m] = t, m++
                        } else if (e.isHemisphereLight) {
                            const t = n.get(e);
                            t.direction.setFromMatrixPosition(e.matrixWorld), t.direction.transformDirection(w), t.direction.normalize(), t.skyColor.copy(e.color).multiplyScalar(u), t.groundColor.copy(e.groundColor).multiplyScalar(u), i.hemi[y] = t, y++
                        }
                    }
                    v > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = Ts.LTC_FLOAT_1, i.rectAreaLTC2 = Ts.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = Ts.LTC_HALF_1, i.rectAreaLTC2 = Ts.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = h, i.ambient[1] = d, i.ambient[2] = p;
                    const M = i.hash;
                    M.directionalLength === f && M.pointLength === m && M.spotLength === g && M.rectAreaLength === v && M.hemiLength === y && M.numDirectionalShadows === _ && M.numPointShadows === b && M.numSpotShadows === x || (i.directional.length = f, i.spot.length = g, i.rectArea.length = v, i.point.length = m, i.hemi.length = y, i.directionalShadow.length = _, i.directionalShadowMap.length = _, i.pointShadow.length = b, i.pointShadowMap.length = b, i.spotShadow.length = x, i.spotShadowMap.length = x, i.directionalShadowMatrix.length = _, i.pointShadowMatrix.length = b, i.spotShadowMatrix.length = x, M.directionalLength = f, M.pointLength = m, M.spotLength = g, M.rectAreaLength = v, M.hemiLength = y, M.numDirectionalShadows = _, M.numPointShadows = b, M.numSpotShadows = x, i.version = xl++)
                }
                return {
                    setup: c,
                    state: i
                }
            }

            function Tl(t, e) {
                const n = new Ml(t, e),
                    r = [],
                    i = [];

                function o() {
                    r.length = 0, i.length = 0
                }

                function a(t) {
                    r.push(t)
                }

                function s(t) {
                    i.push(t)
                }

                function c(t) {
                    n.setup(r, i, t)
                }
                const l = {
                    lightsArray: r,
                    shadowsArray: i,
                    lights: n
                };
                return {
                    init: o,
                    state: l,
                    setupLights: c,
                    pushLight: a,
                    pushShadow: s
                }
            }

            function Sl(t, e) {
                let n = new WeakMap;

                function r(r, i) {
                    let o;
                    return !1 === n.has(r) ? (o = new Tl(t, e), n.set(r, new WeakMap), n.get(r).set(i, o)) : !1 === n.get(r).has(i) ? (o = new Tl(t, e), n.get(r).set(i, o)) : o = n.get(r).get(i), o
                }

                function i() {
                    n = new WeakMap
                }
                return {
                    get: r,
                    dispose: i
                }
            }

            function El(t) {
                Vr.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Ze, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
            }

            function Al(t) {
                Vr.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new bn, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
            }
            El.prototype = Object.create(Vr.prototype), El.prototype.constructor = El, El.prototype.isMeshDepthMaterial = !0, El.prototype.copy = function(t) {
                return Vr.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
            }, Al.prototype = Object.create(Vr.prototype), Al.prototype.constructor = Al, Al.prototype.isMeshDistanceMaterial = !0, Al.prototype.copy = function(t) {
                return Vr.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
            };
            var Ll = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
                Rl = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

            function Cl(t, e, n) {
                let r = new Ji;
                const i = new un,
                    o = new un,
                    a = new gn,
                    s = [],
                    c = [],
                    u = {},
                    m = {
                        0: p,
                        1: d,
                        2: f
                    },
                    v = new Hi({
                        defines: {
                            SAMPLE_RATE: 2 / 8,
                            HALF_SAMPLE_RATE: 1 / 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new un
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: Rl,
                        fragmentShader: Ll
                    }),
                    y = v.clone();
                y.defines.HORIZONAL_PASS = 1;
                const _ = new pi;
                _.setAttribute("position", new Yr(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                const b = new Oi(_, v),
                    x = this;

                function w(n, r) {
                    const i = e.update(b);
                    v.uniforms.shadow_pass.value = n.map.texture, v.uniforms.resolution.value = n.mapSize, v.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(r, null, i, v, b, null), y.uniforms.shadow_pass.value = n.mapPass.texture, y.uniforms.resolution.value = n.mapSize, y.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(r, null, i, y, b, null)
                }

                function M(t, e, n) {
                    const r = t << 0 | e << 1 | n << 2;
                    let i = s[r];
                    return void 0 === i && (i = new El({
                        depthPacking: Je,
                        morphTargets: t,
                        skinning: e
                    }), s[r] = i), i
                }

                function T(t, e, n) {
                    const r = t << 0 | e << 1 | n << 2;
                    let i = c[r];
                    return void 0 === i && (i = new Al({
                        morphTargets: t,
                        skinning: e
                    }), c[r] = i), i
                }

                function S(e, n, r, i, o, a, s) {
                    let c = null,
                        l = M,
                        d = e.customDepthMaterial;
                    if (!0 === i.isPointLight && (l = T, d = e.customDistanceMaterial), void 0 === d) {
                        let t = !1;
                        !0 === r.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
                        let i = !1;
                        !0 === e.isSkinnedMesh && (!0 === r.skinning ? i = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e));
                        const o = !0 === e.isInstancedMesh;
                        c = l(t, i, o)
                    } else c = d;
                    if (t.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length) {
                        const t = c.uuid,
                            e = r.uuid;
                        let n = u[t];
                        void 0 === n && (n = {}, u[t] = n);
                        let i = n[e];
                        void 0 === i && (i = c.clone(), n[e] = i), c = i
                    }
                    return c.visible = r.visible, c.wireframe = r.wireframe, c.side = s === h ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : m[r.side], c.clipShadows = r.clipShadows, c.clippingPlanes = r.clippingPlanes, c.clipIntersection = r.clipIntersection, c.wireframeLinewidth = r.wireframeLinewidth, c.linewidth = r.linewidth, !0 === i.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(i.matrixWorld), c.nearDistance = o, c.farDistance = a), c
                }

                function E(n, i, o, a, s) {
                    if (!1 === n.visible) return;
                    const c = n.layers.test(i.layers);
                    if (c && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && s === h) && (!n.frustumCulled || r.intersectsObject(n))) {
                        n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                        const r = e.update(n),
                            i = n.material;
                        if (Array.isArray(i)) {
                            const e = r.groups;
                            for (let c = 0, l = e.length; c < l; c++) {
                                const l = e[c],
                                    u = i[l.materialIndex];
                                if (u && u.visible) {
                                    const e = S(n, r, u, a, o.near, o.far, s);
                                    t.renderBufferDirect(o, null, r, e, n, l)
                                }
                            }
                        } else if (i.visible) {
                            const e = S(n, r, i, a, o.near, o.far, s);
                            t.renderBufferDirect(o, null, r, e, n, null)
                        }
                    }
                    const l = n.children;
                    for (let t = 0, e = l.length; t < e; t++) E(l[t], i, o, a, s)
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = l, this.render = function(e, s, c) {
                    if (!1 === x.enabled) return;
                    if (!1 === x.autoUpdate && !1 === x.needsUpdate) return;
                    if (0 === e.length) return;
                    const l = t.getRenderTarget(),
                        u = t.getActiveCubeFace(),
                        d = t.getActiveMipmapLevel(),
                        p = t.state;
                    p.setBlending(g), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1);
                    for (let f = 0, m = e.length; f < m; f++) {
                        const l = e[f],
                            u = l.shadow;
                        if (void 0 === u) {
                            console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
                            continue
                        }
                        if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
                        i.copy(u.mapSize);
                        const d = u.getFrameExtents();
                        if (i.multiply(d), o.copy(u.mapSize), (i.x > n || i.y > n) && (i.x > n && (o.x = Math.floor(n / d.x), i.x = o.x * d.x, u.mapSize.x = o.x), i.y > n && (o.y = Math.floor(n / d.y), i.y = o.y * d.y, u.mapSize.y = o.y)), null === u.map && !u.isPointLightShadow && this.type === h) {
                            const t = {
                                minFilter: ft,
                                magFilter: ft,
                                format: Ot
                            };
                            u.map = new vn(i.x, i.y, t), u.map.texture.name = l.name + ".shadowMap", u.mapPass = new vn(i.x, i.y, t), u.camera.updateProjectionMatrix()
                        }
                        if (null === u.map) {
                            const t = {
                                minFilter: ht,
                                magFilter: ht,
                                format: Ot
                            };
                            u.map = new vn(i.x, i.y, t), u.map.texture.name = l.name + ".shadowMap", u.camera.updateProjectionMatrix()
                        }
                        t.setRenderTarget(u.map), t.clear();
                        const m = u.getViewportCount();
                        for (let t = 0; t < m; t++) {
                            const e = u.getViewport(t);
                            a.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w), p.viewport(a), u.updateMatrices(l, t), r = u.getFrustum(), E(s, c, u.camera, l, this.type)
                        }
                        u.isPointLightShadow || this.type !== h || w(u, c), u.needsUpdate = !1
                    }
                    x.needsUpdate = !1, t.setRenderTarget(l, u, d)
                }
            }

            function Ol(t, e, n) {
                const r = n.isWebGL2;

                function i() {
                    let e = !1;
                    const n = new gn;
                    let r = null;
                    const i = new gn(0, 0, 0, 0);
                    return {
                        setMask: function(n) {
                            r === n || e || (t.colorMask(n, n, n, n), r = n)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e, r, o, a, s) {
                            !0 === s && (e *= a, r *= a, o *= a), n.set(e, r, o, a), !1 === i.equals(n) && (t.clearColor(e, r, o, a), i.copy(n))
                        },
                        reset: function() {
                            e = !1, r = null, i.set(-1, 0, 0, 0)
                        }
                    }
                }

                function o() {
                    let e = !1,
                        n = null,
                        r = null,
                        i = null;
                    return {
                        setTest: function(t) {
                            t ? vt(2929) : yt(2929)
                        },
                        setMask: function(r) {
                            n === r || e || (t.depthMask(r), n = r)
                        },
                        setFunc: function(e) {
                            if (r !== e) {
                                if (e) switch (e) {
                                    case B:
                                        t.depthFunc(512);
                                        break;
                                    case U:
                                        t.depthFunc(519);
                                        break;
                                    case H:
                                        t.depthFunc(513);
                                        break;
                                    case z:
                                        t.depthFunc(515);
                                        break;
                                    case j:
                                        t.depthFunc(514);
                                        break;
                                    case G:
                                        t.depthFunc(518);
                                        break;
                                    case V:
                                        t.depthFunc(516);
                                        break;
                                    case W:
                                        t.depthFunc(517);
                                        break;
                                    default:
                                        t.depthFunc(515)
                                } else t.depthFunc(515);
                                r = e
                            }
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            i !== e && (t.clearDepth(e), i = e)
                        },
                        reset: function() {
                            e = !1, n = null, r = null, i = null
                        }
                    }
                }

                function l() {
                    let e = !1,
                        n = null,
                        r = null,
                        i = null,
                        o = null,
                        a = null,
                        s = null,
                        c = null,
                        l = null;
                    return {
                        setTest: function(t) {
                            e || (t ? vt(2960) : yt(2960))
                        },
                        setMask: function(r) {
                            n === r || e || (t.stencilMask(r), n = r)
                        },
                        setFunc: function(e, n, a) {
                            r === e && i === n && o === a || (t.stencilFunc(e, n, a), r = e, i = n, o = a)
                        },
                        setOp: function(e, n, r) {
                            a === e && s === n && c === r || (t.stencilOp(e, n, r), a = e, s = n, c = r)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            l !== e && (t.clearStencil(e), l = e)
                        },
                        reset: function() {
                            e = !1, n = null, r = null, i = null, o = null, a = null, s = null, c = null, l = null
                        }
                    }
                }
                const u = new i,
                    h = new o,
                    d = new l;
                let m = {},
                    X = null,
                    q = null,
                    Y = null,
                    $ = null,
                    Z = null,
                    J = null,
                    K = null,
                    Q = null,
                    tt = null,
                    et = !1,
                    nt = null,
                    rt = null,
                    it = null,
                    ot = null,
                    at = null;
                const st = t.getParameter(35661);
                let ct = !1,
                    lt = 0;
                const ut = t.getParameter(7938); - 1 !== ut.indexOf("WebGL") ? (lt = parseFloat(/^WebGL\ ([0-9])/.exec(ut)[1]), ct = lt >= 1) : -1 !== ut.indexOf("OpenGL ES") && (lt = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(ut)[1]), ct = lt >= 2);
                let ht = null,
                    dt = {};
                const pt = new gn,
                    ft = new gn;

                function mt(e, n, r) {
                    const i = new Uint8Array(4),
                        o = t.createTexture();
                    t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                    for (let a = 0; a < r; a++) t.texImage2D(n + a, 0, 6408, 1, 1, 0, 6408, 5121, i);
                    return o
                }
                const gt = {};

                function vt(e) {
                    !0 !== m[e] && (t.enable(e), m[e] = !0)
                }

                function yt(e) {
                    !1 !== m[e] && (t.disable(e), m[e] = !1)
                }

                function _t(e) {
                    return X !== e && (t.useProgram(e), X = e, !0)
                }
                gt[3553] = mt(3553, 3553, 1), gt[34067] = mt(34067, 34069, 6), u.setClear(0, 0, 0, 1), h.setClear(1), d.setClear(0), vt(2929), h.setFunc(z), Tt(!1), St(s), vt(2884), wt(g);
                const bt = {
                    [w]: 32774,
                    [M]: 32778,
                    [T]: 32779
                };
                if (r) bt[S] = 32775, bt[E] = 32776;
                else {
                    const t = e.get("EXT_blend_minmax");
                    null !== t && (bt[S] = t.MIN_EXT, bt[E] = t.MAX_EXT)
                }
                const xt = {
                    [A]: 0,
                    [L]: 1,
                    [R]: 768,
                    [O]: 770,
                    [F]: 776,
                    [D]: 774,
                    [I]: 772,
                    [C]: 769,
                    [P]: 771,
                    [k]: 775,
                    [N]: 773
                };

                function wt(e, n, r, i, o, a, s, c) {
                    if (e !== g) {
                        if (q || (vt(3042), q = !0), e === x) o = o || n, a = a || r, s = s || i, n === $ && o === K || (t.blendEquationSeparate(bt[n], bt[o]), $ = n, K = o), r === Z && i === J && a === Q && s === tt || (t.blendFuncSeparate(xt[r], xt[i], xt[a], xt[s]), Z = r, J = i, Q = a, tt = s), Y = e, et = null;
                        else if (e !== Y || c !== et) {
                            if ($ === w && K === w || (t.blendEquation(32774), $ = w, K = w), c) switch (e) {
                                case v:
                                    t.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case y:
                                    t.blendFunc(1, 1);
                                    break;
                                case _:
                                    t.blendFuncSeparate(0, 0, 769, 771);
                                    break;
                                case b:
                                    t.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e);
                                    break
                            } else switch (e) {
                                case v:
                                    t.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case y:
                                    t.blendFunc(770, 1);
                                    break;
                                case _:
                                    t.blendFunc(0, 769);
                                    break;
                                case b:
                                    t.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e);
                                    break
                            }
                            Z = null, J = null, Q = null, tt = null, Y = e, et = c
                        }
                    } else q && (yt(3042), q = !1)
                }

                function Mt(t, e) {
                    t.side === f ? yt(2884) : vt(2884);
                    let n = t.side === p;
                    e && (n = !n), Tt(n), t.blending === v && !1 === t.transparent ? wt(g) : wt(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), h.setFunc(t.depthFunc), h.setTest(t.depthTest), h.setMask(t.depthWrite), u.setMask(t.colorWrite);
                    const r = t.stencilWrite;
                    d.setTest(r), r && (d.setMask(t.stencilWriteMask), d.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), d.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), At(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                }

                function Tt(e) {
                    nt !== e && (e ? t.frontFace(2304) : t.frontFace(2305), nt = e)
                }

                function St(e) {
                    e !== a ? (vt(2884), e !== rt && (e === s ? t.cullFace(1029) : e === c ? t.cullFace(1028) : t.cullFace(1032))) : yt(2884), rt = e
                }

                function Et(e) {
                    e !== it && (ct && t.lineWidth(e), it = e)
                }

                function At(e, n, r) {
                    e ? (vt(32823), ot === n && at === r || (t.polygonOffset(n, r), ot = n, at = r)) : yt(32823)
                }

                function Lt(t) {
                    t ? vt(3089) : yt(3089)
                }

                function Rt(e) {
                    void 0 === e && (e = 33984 + st - 1), ht !== e && (t.activeTexture(e), ht = e)
                }

                function Ct(e, n) {
                    null === ht && Rt();
                    let r = dt[ht];
                    void 0 === r && (r = {
                        type: void 0,
                        texture: void 0
                    }, dt[ht] = r), r.type === e && r.texture === n || (t.bindTexture(e, n || gt[e]), r.type = e, r.texture = n)
                }

                function Ot() {
                    const e = dt[ht];
                    void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                }

                function Pt() {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                }

                function It() {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                }

                function Nt() {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                }

                function Dt(e) {
                    !1 === pt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), pt.copy(e))
                }

                function kt(e) {
                    !1 === ft.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), ft.copy(e))
                }

                function Ft() {
                    m = {}, ht = null, dt = {}, X = null, Y = null, nt = null, rt = null, u.reset(), h.reset(), d.reset()
                }
                return {
                    buffers: {
                        color: u,
                        depth: h,
                        stencil: d
                    },
                    enable: vt,
                    disable: yt,
                    useProgram: _t,
                    setBlending: wt,
                    setMaterial: Mt,
                    setFlipSided: Tt,
                    setCullFace: St,
                    setLineWidth: Et,
                    setPolygonOffset: At,
                    setScissorTest: Lt,
                    activeTexture: Rt,
                    bindTexture: Ct,
                    unbindTexture: Ot,
                    compressedTexImage2D: Pt,
                    texImage2D: It,
                    texImage3D: Nt,
                    scissor: Dt,
                    viewport: kt,
                    reset: Ft
                }
            }

            function Pl(t, e, n, r, i, o, a) {
                const s = i.isWebGL2,
                    c = i.maxTextures,
                    l = i.maxCubemapSize,
                    u = i.maxTextureSize,
                    h = i.maxSamples,
                    d = new WeakMap;
                let p, f = !1;
                try {
                    f = "undefined" !== typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (Q) {}

                function m(t, e) {
                    return f ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                }

                function g(t, e, n, r) {
                    let i = 1;
                    if ((t.width > r || t.height > r) && (i = r / Math.max(t.width, t.height)), i < 1 || !0 === e) {
                        if ("undefined" !== typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && t instanceof ImageBitmap) {
                            const r = e ? ln.floorPowerOfTwo : Math.floor,
                                o = r(i * t.width),
                                a = r(i * t.height);
                            void 0 === p && (p = m(o, a));
                            const s = n ? m(o, a) : p;
                            s.width = o, s.height = a;
                            const c = s.getContext("2d");
                            return c.drawImage(t, 0, 0, o, a), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + a + ")."), s
                        }
                        return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                    }
                    return t
                }

                function v(t) {
                    return ln.isPowerOfTwo(t.width) && ln.isPowerOfTwo(t.height)
                }

                function y(t) {
                    return !s && (t.wrapS !== lt || t.wrapT !== lt || t.minFilter !== ht && t.minFilter !== ft)
                }

                function _(t, e) {
                    return t.generateMipmaps && e && t.minFilter !== ht && t.minFilter !== ft
                }

                function b(e, n, i, o) {
                    t.generateMipmap(e);
                    const a = r.get(n);
                    a.__maxMipLevel = Math.log(Math.max(i, o)) * Math.LOG2E
                }

                function x(n, r, i) {
                    if (!1 === s) return r;
                    if (null !== n) {
                        if (void 0 !== t[n]) return t[n];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                    }
                    let o = r;
                    return 6403 === r && (5126 === i && (o = 33326), 5131 === i && (o = 33325), 5121 === i && (o = 33321)), 6407 === r && (5126 === i && (o = 34837), 5131 === i && (o = 34843), 5121 === i && (o = 32849)), 6408 === r && (5126 === i && (o = 34836), 5131 === i && (o = 34842), 5121 === i && (o = 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o
                }

                function w(t) {
                    return t === ht || t === dt || t === pt ? 9728 : 9729
                }

                function M(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", M), S(e), e.isVideoTexture && d.delete(e), a.memory.textures--
                }

                function T(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", T), E(e), a.memory.textures--
                }

                function S(e) {
                    const n = r.get(e);
                    void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture), r.remove(e))
                }

                function E(e) {
                    const n = r.get(e),
                        i = r.get(e.texture);
                    if (e) {
                        if (void 0 !== i.__webglTexture && t.deleteTexture(i.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                            for (let e = 0; e < 6; e++) t.deleteFramebuffer(n.__webglFramebuffer[e]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[e]);
                        else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && t.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer);
                        r.remove(e.texture), r.remove(e)
                    }
                }
                let A = 0;

                function L() {
                    A = 0
                }

                function R() {
                    const t = A;
                    return t >= c && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + c), A += 1, t
                }

                function C(t, e) {
                    const i = r.get(t);
                    if (t.isVideoTexture && Y(t), t.version > 0 && i.__version !== t.version) {
                        const n = t.image;
                        if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (!1 !== n.complete) return void B(i, t, e);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    n.activeTexture(33984 + e), n.bindTexture(3553, i.__webglTexture)
                }

                function O(t, e) {
                    const i = r.get(t);
                    t.version > 0 && i.__version !== t.version ? B(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, i.__webglTexture))
                }

                function P(t, e) {
                    const i = r.get(t);
                    t.version > 0 && i.__version !== t.version ? B(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, i.__webglTexture))
                }

                function I(t, e) {
                    const i = r.get(t);
                    t.version > 0 && i.__version !== t.version ? U(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(34067, i.__webglTexture))
                }
                const N = {
                        [ct]: 10497,
                        [lt]: 33071,
                        [ut]: 33648
                    },
                    D = {
                        [ht]: 9728,
                        [dt]: 9984,
                        [pt]: 9986,
                        [ft]: 9729,
                        [mt]: 9985,
                        [gt]: 9987
                    };

                function k(n, o, a) {
                    a ? (t.texParameteri(n, 10242, N[o.wrapS]), t.texParameteri(n, 10243, N[o.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, N[o.wrapR]), t.texParameteri(n, 10240, D[o.magFilter]), t.texParameteri(n, 10241, D[o.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), o.wrapS === lt && o.wrapT === lt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, w(o.magFilter)), t.texParameteri(n, 10241, w(o.minFilter)), o.minFilter !== ht && o.minFilter !== ft && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
                    const c = e.get("EXT_texture_filter_anisotropic");
                    if (c) {
                        if (o.type === Mt && null === e.get("OES_texture_float_linear")) return;
                        if (o.type === Tt && null === (s || e.get("OES_texture_half_float_linear"))) return;
                        (o.anisotropy > 1 || r.get(o).__currentAnisotropy) && (t.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, i.getMaxAnisotropy())), r.get(o).__currentAnisotropy = o.anisotropy)
                    }
                }

                function F(e, n) {
                    void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", M), e.__webglTexture = t.createTexture(), a.memory.textures++)
                }

                function B(e, r, i) {
                    let a = 3553;
                    r.isDataTexture2DArray && (a = 35866), r.isDataTexture3D && (a = 32879), F(e, r), n.activeTexture(33984 + i), n.bindTexture(a, e.__webglTexture), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment);
                    const c = y(r) && !1 === v(r.image),
                        l = g(r.image, c, !1, u),
                        h = v(l) || s,
                        d = o.convert(r.format);
                    let p, f = o.convert(r.type),
                        m = x(r.internalFormat, d, f);
                    k(a, r, h);
                    const w = r.mipmaps;
                    if (r.isDepthTexture) m = 6402, s ? m = r.type === Mt ? 36012 : r.type === wt ? 33190 : r.type === Lt ? 35056 : 33189 : r.type === Mt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === Nt && 6402 === m && r.type !== bt && r.type !== wt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = bt, f = o.convert(r.type)), r.format === Dt && 6402 === m && (m = 34041, r.type !== Lt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = Lt, f = o.convert(r.type))), n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, null);
                    else if (r.isDataTexture)
                        if (w.length > 0 && h) {
                            for (let t = 0, e = w.length; t < e; t++) p = w[t], n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                            r.generateMipmaps = !1, e.__maxMipLevel = w.length - 1
                        } else n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, l.data), e.__maxMipLevel = 0;
                    else if (r.isCompressedTexture) {
                        for (let t = 0, e = w.length; t < e; t++) p = w[t], r.format !== Ot && r.format !== Ct ? null !== d ? n.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                        e.__maxMipLevel = w.length - 1
                    } else if (r.isDataTexture2DArray) n.texImage3D(35866, 0, m, l.width, l.height, l.depth, 0, d, f, l.data), e.__maxMipLevel = 0;
                    else if (r.isDataTexture3D) n.texImage3D(32879, 0, m, l.width, l.height, l.depth, 0, d, f, l.data), e.__maxMipLevel = 0;
                    else if (w.length > 0 && h) {
                        for (let t = 0, e = w.length; t < e; t++) p = w[t], n.texImage2D(3553, t, m, d, f, p);
                        r.generateMipmaps = !1, e.__maxMipLevel = w.length - 1
                    } else n.texImage2D(3553, 0, m, d, f, l), e.__maxMipLevel = 0;
                    _(r, h) && b(a, r, l.width, l.height), e.__version = r.version, r.onUpdate && r.onUpdate(r)
                }

                function U(e, r, i) {
                    if (6 !== r.image.length) return;
                    F(e, r), n.activeTexture(33984 + i), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, r.flipY);
                    const a = r && (r.isCompressedTexture || r.image[0].isCompressedTexture),
                        c = r.image[0] && r.image[0].isDataTexture,
                        u = [];
                    for (let t = 0; t < 6; t++) u[t] = a || c ? c ? r.image[t].image : r.image[t] : g(r.image[t], !1, !0, l);
                    const h = u[0],
                        d = v(h) || s,
                        p = o.convert(r.format),
                        f = o.convert(r.type),
                        m = x(r.internalFormat, p, f);
                    let y;
                    if (k(34067, r, d), a) {
                        for (let t = 0; t < 6; t++) {
                            y = u[t].mipmaps;
                            for (let e = 0; e < y.length; e++) {
                                const i = y[e];
                                r.format !== Ot && r.format !== Ct ? null !== p ? n.compressedTexImage2D(34069 + t, e, m, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, m, i.width, i.height, 0, p, f, i.data)
                            }
                        }
                        e.__maxMipLevel = y.length - 1
                    } else {
                        y = r.mipmaps;
                        for (let t = 0; t < 6; t++)
                            if (c) {
                                n.texImage2D(34069 + t, 0, m, u[t].width, u[t].height, 0, p, f, u[t].data);
                                for (let e = 0; e < y.length; e++) {
                                    const r = y[e],
                                        i = r.image[t].image;
                                    n.texImage2D(34069 + t, e + 1, m, i.width, i.height, 0, p, f, i.data)
                                }
                            } else {
                                n.texImage2D(34069 + t, 0, m, p, f, u[t]);
                                for (let e = 0; e < y.length; e++) {
                                    const r = y[e];
                                    n.texImage2D(34069 + t, e + 1, m, p, f, r.image[t])
                                }
                            }
                        e.__maxMipLevel = y.length
                    }
                    _(r, d) && b(34067, r, h.width, h.height), e.__version = r.version, r.onUpdate && r.onUpdate(r)
                }

                function H(e, i, a, s) {
                    const c = o.convert(i.texture.format),
                        l = o.convert(i.texture.type),
                        u = x(i.texture.internalFormat, c, l);
                    n.texImage2D(s, 0, u, i.width, i.height, 0, c, l, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, s, r.get(i.texture).__webglTexture, 0), t.bindFramebuffer(36160, null)
                }

                function z(e, n, r) {
                    if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                        let i = 33189;
                        if (r) {
                            const e = n.depthTexture;
                            e && e.isDepthTexture && (e.type === Mt ? i = 36012 : e.type === wt && (i = 33190));
                            const r = q(n);
                            t.renderbufferStorageMultisample(36161, r, i, n.width, n.height)
                        } else t.renderbufferStorage(36161, i, n.width, n.height);
                        t.framebufferRenderbuffer(36160, 36096, 36161, e)
                    } else if (n.depthBuffer && n.stencilBuffer) {
                        if (r) {
                            const e = q(n);
                            t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
                        } else t.renderbufferStorage(36161, 34041, n.width, n.height);
                        t.framebufferRenderbuffer(36160, 33306, 36161, e)
                    } else {
                        const e = o.convert(n.texture.format),
                            i = o.convert(n.texture.type),
                            a = x(n.texture.internalFormat, e, i);
                        if (r) {
                            const e = q(n);
                            t.renderbufferStorageMultisample(36161, e, a, n.width, n.height)
                        } else t.renderbufferStorage(36161, a, n.width, n.height)
                    }
                    t.bindRenderbuffer(36161, null)
                }

                function j(e, n) {
                    const i = n && n.isWebGLCubeRenderTarget;
                    if (i) throw new Error("Depth Texture with cube render targets is not supported");
                    if (t.bindFramebuffer(36160, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    r.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), C(n.depthTexture, 0);
                    const o = r.get(n.depthTexture).__webglTexture;
                    if (n.depthTexture.format === Nt) t.framebufferTexture2D(36160, 36096, 3553, o, 0);
                    else {
                        if (n.depthTexture.format !== Dt) throw new Error("Unknown depthTexture format");
                        t.framebufferTexture2D(36160, 33306, 3553, o, 0)
                    }
                }

                function G(e) {
                    const n = r.get(e),
                        i = !0 === e.isWebGLCubeRenderTarget;
                    if (e.depthTexture) {
                        if (i) throw new Error("target.depthTexture not supported in Cube render targets");
                        j(n.__webglFramebuffer, e)
                    } else if (i) {
                        n.__webglDepthbuffer = [];
                        for (let r = 0; r < 6; r++) t.bindFramebuffer(36160, n.__webglFramebuffer[r]), n.__webglDepthbuffer[r] = t.createRenderbuffer(), z(n.__webglDepthbuffer[r], e, !1)
                    } else t.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), z(n.__webglDepthbuffer, e, !1);
                    t.bindFramebuffer(36160, null)
                }

                function V(e) {
                    const i = r.get(e),
                        c = r.get(e.texture);
                    e.addEventListener("dispose", T), c.__webglTexture = t.createTexture(), a.memory.textures++;
                    const l = !0 === e.isWebGLCubeRenderTarget,
                        u = !0 === e.isWebGLMultisampleRenderTarget,
                        h = v(e) || s;
                    if (!s || e.texture.format !== Ct || e.texture.type !== Mt && e.texture.type !== Tt || (e.texture.format = Ot, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), l) {
                        i.__webglFramebuffer = [];
                        for (let e = 0; e < 6; e++) i.__webglFramebuffer[e] = t.createFramebuffer()
                    } else if (i.__webglFramebuffer = t.createFramebuffer(), u)
                        if (s) {
                            i.__webglMultisampledFramebuffer = t.createFramebuffer(), i.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, i.__webglColorRenderbuffer);
                            const n = o.convert(e.texture.format),
                                r = o.convert(e.texture.type),
                                a = x(e.texture.internalFormat, n, r),
                                s = q(e);
                            t.renderbufferStorageMultisample(36161, s, a, e.width, e.height), t.bindFramebuffer(36160, i.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, i.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (i.__webglDepthRenderbuffer = t.createRenderbuffer(), z(i.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                    if (l) {
                        n.bindTexture(34067, c.__webglTexture), k(34067, e.texture, h);
                        for (let t = 0; t < 6; t++) H(i.__webglFramebuffer[t], e, 36064, 34069 + t);
                        _(e.texture, h) && b(34067, e.texture, e.width, e.height), n.bindTexture(34067, null)
                    } else n.bindTexture(3553, c.__webglTexture), k(3553, e.texture, h), H(i.__webglFramebuffer, e, 36064, 3553), _(e.texture, h) && b(3553, e.texture, e.width, e.height), n.bindTexture(3553, null);
                    e.depthBuffer && G(e)
                }

                function W(t) {
                    const e = t.texture,
                        i = v(t) || s;
                    if (_(e, i)) {
                        const i = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                            o = r.get(e).__webglTexture;
                        n.bindTexture(i, o), b(i, e, t.width, t.height), n.bindTexture(i, null)
                    }
                }

                function X(e) {
                    if (e.isWebGLMultisampleRenderTarget)
                        if (s) {
                            const n = r.get(e);
                            t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, n.__webglFramebuffer);
                            const i = e.width,
                                o = e.height;
                            let a = 16384;
                            e.depthBuffer && (a |= 256), e.stencilBuffer && (a |= 1024), t.blitFramebuffer(0, 0, i, o, 0, 0, i, o, a, 9728), t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                }

                function q(t) {
                    return s && t.isWebGLMultisampleRenderTarget ? Math.min(h, t.samples) : 0
                }

                function Y(t) {
                    const e = a.render.frame;
                    d.get(t) !== e && (d.set(t, e), t.update())
                }
                let $ = !1,
                    Z = !1;

                function J(t, e) {
                    t && t.isWebGLRenderTarget && (!1 === $ && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), $ = !0), t = t.texture), C(t, e)
                }

                function K(t, e) {
                    t && t.isWebGLCubeRenderTarget && (!1 === Z && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), Z = !0), t = t.texture), I(t, e)
                }
                this.allocateTextureUnit = R, this.resetTextureUnits = L, this.setTexture2D = C, this.setTexture2DArray = O, this.setTexture3D = P, this.setTextureCube = I, this.setupRenderTarget = V, this.updateRenderTargetMipmap = W, this.updateMultisampleRenderTarget = X, this.safeSetTexture2D = J, this.safeSetTextureCube = K
            }

            function Il(t, e, n) {
                const r = n.isWebGL2;

                function i(t) {
                    let n;
                    if (t === vt) return 5121;
                    if (t === St) return 32819;
                    if (t === Et) return 32820;
                    if (t === At) return 33635;
                    if (t === yt) return 5120;
                    if (t === _t) return 5122;
                    if (t === bt) return 5123;
                    if (t === xt) return 5124;
                    if (t === wt) return 5125;
                    if (t === Mt) return 5126;
                    if (t === Tt) return r ? 5131 : (n = e.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
                    if (t === Rt) return 6406;
                    if (t === Ct) return 6407;
                    if (t === Ot) return 6408;
                    if (t === Pt) return 6409;
                    if (t === It) return 6410;
                    if (t === Nt) return 6402;
                    if (t === Dt) return 34041;
                    if (t === kt) return 6403;
                    if (t === Ft) return 36244;
                    if (t === Bt) return 33319;
                    if (t === Ut) return 33320;
                    if (t === Ht) return 36248;
                    if (t === zt) return 36249;
                    if (t === jt || t === Gt || t === Vt || t === Wt) {
                        if (n = e.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
                        if (t === jt) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (t === Gt) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (t === Vt) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (t === Wt) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (t === Xt || t === qt || t === Yt || t === $t) {
                        if (n = e.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
                        if (t === Xt) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (t === qt) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (t === Yt) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (t === $t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (t === Zt) return n = e.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if ((t === Jt || t === Kt) && (n = e.get("WEBGL_compressed_texture_etc"), null !== n)) {
                        if (t === Jt) return n.COMPRESSED_RGB8_ETC2;
                        if (t === Kt) return n.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    return t === Qt || t === te || t === ee || t === ne || t === re || t === ie || t === oe || t === ae || t === se || t === ce || t === le || t === ue || t === he || t === de || t === fe || t === me || t === ge || t === ve || t === ye || t === _e || t === be || t === xe || t === we || t === Me || t === Te || t === Se || t === Ee || t === Ae ? (n = e.get("WEBGL_compressed_texture_astc"), null !== n ? t : null) : t === pe ? (n = e.get("EXT_texture_compression_bptc"), null !== n ? t : null) : t === Lt ? r ? 34042 : (n = e.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                }
                return {
                    convert: i
                }
            }

            function Nl(t) {
                ji.call(this), this.cameras = t || []
            }

            function Dl() {
                _r.call(this), this.type = "Group"
            }

            function kl() {
                this._targetRay = null, this._grip = null, this._hand = null
            }

            function Fl(t, e) {
                const n = this;
                let r = null,
                    i = 1,
                    o = null,
                    a = "local-floor",
                    s = null;
                const c = [],
                    l = new Map,
                    u = new ji;
                u.layers.enable(1), u.viewport = new gn;
                const h = new ji;
                h.layers.enable(2), h.viewport = new gn;
                const d = [u, h],
                    p = new Nl;
                p.layers.enable(1), p.layers.enable(2);
                let f = null,
                    m = null;

                function g(t) {
                    const e = l.get(t.inputSource);
                    e && e.dispatchEvent({
                        type: t.type,
                        data: t.inputSource
                    })
                }

                function v() {
                    l.forEach((function(t, e) {
                        t.disconnect(e)
                    })), l.clear(), t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), E.stop(), n.isPresenting = !1, n.dispatchEvent({
                        type: "sessionend"
                    })
                }

                function y(t) {
                    o = t, E.setContext(r), E.start(), n.isPresenting = !0, n.dispatchEvent({
                        type: "sessionstart"
                    })
                }

                function _(t) {
                    const e = r.inputSources;
                    for (let n = 0; n < c.length; n++) l.set(e[n], c[n]);
                    for (let n = 0; n < t.removed.length; n++) {
                        const e = t.removed[n],
                            r = l.get(e);
                        r && (r.dispatchEvent({
                            type: "disconnected",
                            data: e
                        }), l.delete(e))
                    }
                    for (let n = 0; n < t.added.length; n++) {
                        const e = t.added[n],
                            r = l.get(e);
                        r && r.dispatchEvent({
                            type: "connected",
                            data: e
                        })
                    }
                }
                this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
                    let e = c[t];
                    return void 0 === e && (e = new kl, c[t] = e), e.getTargetRaySpace()
                }, this.getControllerGrip = function(t) {
                    let e = c[t];
                    return void 0 === e && (e = new kl, c[t] = e), e.getGripSpace()
                }, this.getHand = function(t) {
                    let e = c[t];
                    return void 0 === e && (e = new kl, c[t] = e), e.getHandSpace()
                }, this.setFramebufferScaleFactor = function(t) {
                    i = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }, this.setReferenceSpaceType = function(t) {
                    a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }, this.getReferenceSpace = function() {
                    return o
                }, this.getSession = function() {
                    return r
                }, this.setSession = function(t) {
                    if (r = t, null !== r) {
                        r.addEventListener("select", g), r.addEventListener("selectstart", g), r.addEventListener("selectend", g), r.addEventListener("squeeze", g), r.addEventListener("squeezestart", g), r.addEventListener("squeezeend", g), r.addEventListener("end", v);
                        const t = e.getContextAttributes();
                        !0 !== t.xrCompatible && e.makeXRCompatible();
                        const n = {
                                antialias: t.antialias,
                                alpha: t.alpha,
                                depth: t.depth,
                                stencil: t.stencil,
                                framebufferScaleFactor: i
                            },
                            o = new XRWebGLLayer(r, e, n);
                        r.updateRenderState({
                            baseLayer: o
                        }), r.requestReferenceSpace(a).then(y), r.addEventListener("inputsourceschange", _)
                    }
                };
                const b = new bn,
                    x = new bn;

                function w(t, e, n) {
                    b.setFromMatrixPosition(e.matrixWorld), x.setFromMatrixPosition(n.matrixWorld);
                    const r = b.distanceTo(x),
                        i = e.projectionMatrix.elements,
                        o = n.projectionMatrix.elements,
                        a = i[14] / (i[10] - 1),
                        s = i[14] / (i[10] + 1),
                        c = (i[9] + 1) / i[5],
                        l = (i[9] - 1) / i[5],
                        u = (i[8] - 1) / i[0],
                        h = (o[8] + 1) / o[0],
                        d = a * u,
                        p = a * h,
                        f = r / (-u + h),
                        m = f * -u;
                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);
                    const g = a + f,
                        v = s + f,
                        y = d - m,
                        _ = p + (r - m),
                        w = c * s / v * g,
                        M = l * s / v * g;
                    t.projectionMatrix.makePerspective(y, _, w, M, g, v)
                }

                function M(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
                }
                this.getCamera = function(t) {
                    p.near = h.near = u.near = t.near, p.far = h.far = u.far = t.far, f === p.near && m === p.far || (r.updateRenderState({
                        depthNear: p.near,
                        depthFar: p.far
                    }), f = p.near, m = p.far);
                    const e = t.parent,
                        n = p.cameras;
                    M(p, e);
                    for (let r = 0; r < n.length; r++) M(n[r], e);
                    t.matrixWorld.copy(p.matrixWorld);
                    const i = t.children;
                    for (let r = 0, o = i.length; r < o; r++) i[r].updateMatrixWorld(!0);
                    return 2 === n.length ? w(p, u, h) : p.projectionMatrix.copy(u.projectionMatrix), p
                };
                let T = null;

                function S(e, n) {
                    if (s = n.getViewerPose(o), null !== s) {
                        const e = s.views,
                            n = r.renderState.baseLayer;
                        t.setFramebuffer(n.framebuffer);
                        let i = !1;
                        e.length !== p.cameras.length && (p.cameras.length = 0, i = !0);
                        for (let t = 0; t < e.length; t++) {
                            const r = e[t],
                                o = n.getViewport(r),
                                a = d[t];
                            a.matrix.fromArray(r.transform.matrix), a.projectionMatrix.fromArray(r.projectionMatrix), a.viewport.set(o.x, o.y, o.width, o.height), 0 === t && p.matrix.copy(a.matrix), !0 === i && p.cameras.push(a)
                        }
                    }
                    const i = r.inputSources;
                    for (let t = 0; t < c.length; t++) {
                        const e = c[t],
                            r = i[t];
                        e.update(r, n, o)
                    }
                    T && T(e, n)
                }
                const E = new Ki;
                E.setAnimationLoop(S), this.setAnimationLoop = function(t) {
                    T = t
                }, this.dispose = function() {}
            }

            function Bl(t) {
                function e(t, e) {
                    t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                }

                function n(t, e, n, p) {
                    e.isMeshBasicMaterial ? r(t, e) : e.isMeshLambertMaterial ? (r(t, e), c(t, e)) : e.isMeshToonMaterial ? (r(t, e), u(t, e)) : e.isMeshPhongMaterial ? (r(t, e), l(t, e)) : e.isMeshStandardMaterial ? (r(t, e), e.isMeshPhysicalMaterial ? d(t, e) : h(t, e)) : e.isMeshMatcapMaterial ? (r(t, e), f(t, e)) : e.isMeshDepthMaterial ? (r(t, e), m(t, e)) : e.isMeshDistanceMaterial ? (r(t, e), g(t, e)) : e.isMeshNormalMaterial ? (r(t, e), v(t, e)) : e.isLineBasicMaterial ? (i(t, e), e.isLineDashedMaterial && o(t, e)) : e.isPointsMaterial ? a(t, e, n, p) : e.isSpriteMaterial ? s(t, e) : e.isShadowMaterial ? (t.color.value.copy(e.color), t.opacity.value = e.opacity) : e.isShaderMaterial && (e.uniformsNeedUpdate = !1)
                }

                function r(e, n) {
                    e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap);
                    const r = t.get(n).envMap;
                    if (r) {
                        e.envMap.value = r, e.flipEnvMap.value = r.isCubeTexture && r._needsFlipEnvMap ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio;
                        const i = t.get(r).__maxMipLevel;
                        void 0 !== i && (e.maxMipLevel.value = i)
                    }
                    let i, o;
                    n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? i = n.map : n.specularMap ? i = n.specularMap : n.displacementMap ? i = n.displacementMap : n.normalMap ? i = n.normalMap : n.bumpMap ? i = n.bumpMap : n.roughnessMap ? i = n.roughnessMap : n.metalnessMap ? i = n.metalnessMap : n.alphaMap ? i = n.alphaMap : n.emissiveMap ? i = n.emissiveMap : n.clearcoatMap ? i = n.clearcoatMap : n.clearcoatNormalMap ? i = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (i = n.clearcoatRoughnessMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix)), n.aoMap ? o = n.aoMap : n.lightMap && (o = n.lightMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), e.uv2Transform.value.copy(o.matrix))
                }

                function i(t, e) {
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                }

                function o(t, e) {
                    t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                }

                function a(t, e, n, r) {
                    let i;
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * r, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? i = e.map : e.alphaMap && (i = e.alphaMap), void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
                }

                function s(t, e) {
                    let n;
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                }

                function c(t, e) {
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                }

                function l(t, e) {
                    t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === p && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === p && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }

                function u(t, e) {
                    e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === p && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === p && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }

                function h(e, n) {
                    e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, n.side === p && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), n.side === p && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias);
                    const r = t.get(n).envMap;
                    r && (e.envMapIntensity.value = n.envMapIntensity)
                }

                function d(t, e) {
                    h(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen), e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === p && t.clearcoatNormalScale.value.negate()), t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap)
                }

                function f(t, e) {
                    e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === p && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === p && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }

                function m(t, e) {
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }

                function g(t, e) {
                    e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                }

                function v(t, e) {
                    e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === p && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === p && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }
                return {
                    refreshFogUniforms: e,
                    refreshMaterialUniforms: n
                }
            }

            function Ul(t) {
                t = t || {};
                const e = void 0 !== t.canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    n = void 0 !== t.context ? t.context : null,
                    r = void 0 !== t.alpha && t.alpha,
                    i = void 0 === t.depth || t.depth,
                    o = void 0 === t.stencil || t.stencil,
                    a = void 0 !== t.antialias && t.antialias,
                    s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                    c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                    l = void 0 !== t.powerPreference ? t.powerPreference : "default",
                    u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
                let h = null,
                    d = null;
                this.domElement = e, this.debug = {
                    checkShaderErrors: !0
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = je, this.physicallyCorrectLights = !1, this.toneMapping = $, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                const p = this;
                let f = !1,
                    m = null,
                    g = 0,
                    v = 0,
                    y = null,
                    _ = null,
                    b = -1,
                    x = null,
                    w = null;
                const M = new gn,
                    T = new gn;
                let S = null,
                    E = e.width,
                    A = e.height,
                    L = 1,
                    R = null,
                    C = null;
                const O = new gn(0, 0, E, A),
                    P = new gn(0, 0, E, A);
                let I = !1;
                const N = new Ji;
                let D = !1,
                    k = !1;
                const F = new Yn,
                    B = new bn,
                    U = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function H() {
                    return null === y ? L : 1
                }
                let z, j, G, V, W, X, q, Y, Z, J, K, Q, tt, et, nt, rt, it, ot, at, st, ct, lt = n;

                function ut(t, n) {
                    for (let r = 0; r < t.length; r++) {
                        const i = t[r],
                            o = e.getContext(i, n);
                        if (null !== o) return o
                    }
                    return null
                }
                try {
                    const t = {
                        alpha: r,
                        depth: i,
                        stencil: o,
                        antialias: a,
                        premultipliedAlpha: s,
                        preserveDrawingBuffer: c,
                        powerPreference: l,
                        failIfMajorPerformanceCaveat: u
                    };
                    if (e.addEventListener("webglcontextlost", ft, !1), e.addEventListener("webglcontextrestored", mt, !1), null === lt) {
                        const e = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === p.isWebGL1Renderer && e.shift(), lt = ut(e, t), null === lt) throw ut(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    void 0 === lt.getShaderPrecisionFormat && (lt.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (Nt) {
                    throw console.error("THREE.WebGLRenderer: " + Nt.message), Nt
                }

                function ht() {
                    z = new Ps(lt), j = new Rs(lt, z, t), !1 === j.isWebGL2 && (z.get("WEBGL_depth_texture"), z.get("OES_texture_float"), z.get("OES_texture_half_float"), z.get("OES_texture_half_float_linear"), z.get("OES_standard_derivatives"), z.get("OES_element_index_uint"), z.get("OES_vertex_array_object"), z.get("ANGLE_instanced_arrays")), z.get("OES_texture_float_linear"), st = new Il(lt, z, j), G = new Ol(lt, z, j), G.scissor(T.copy(P).multiplyScalar(L).floor()), G.viewport(M.copy(O).multiplyScalar(L).floor()), V = new Ds(lt), W = new fl, X = new Pl(lt, z, G, W, j, st, V), q = new Os(p), Y = new Qi(lt, j), ct = new As(lt, z, Y, j), Z = new Is(lt, Y, V, ct), J = new Us(lt, Z, Y, V), it = new Bs(lt), nt = new Cs(W), K = new pl(p, q, z, j, ct, nt), Q = new Bl(W), tt = new yl(W), et = new Sl(z, j), rt = new Es(p, q, G, J, s), ot = new Ls(lt, z, V, j), at = new Ns(lt, z, V, j), V.programs = K.programs, p.capabilities = j, p.extensions = z, p.properties = W, p.renderLists = tt, p.state = G, p.info = V
                }
                ht();
                const dt = new Fl(p, lt);
                this.xr = dt;
                const pt = new Cl(p, J, j.maxTextureSize);

                function ft(t) {
                    t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), f = !0
                }

                function mt() {
                    console.log("THREE.WebGLRenderer: Context Restored."), f = !1, ht()
                }

                function gt(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", gt), yt(e)
                }

                function yt(t) {
                    _t(t), W.remove(t)
                }

                function _t(t) {
                    const e = W.get(t).program;
                    void 0 !== e && K.releaseProgram(e)
                }

                function bt(t, e) {
                    t.render((function(t) {
                        p.renderBufferImmediate(t, e)
                    }))
                }
                this.shadowMap = pt, this.getContext = function() {
                    return lt
                }, this.getContextAttributes = function() {
                    return lt.getContextAttributes()
                }, this.forceContextLoss = function() {
                    const t = z.get("WEBGL_lose_context");
                    t && t.loseContext()
                }, this.forceContextRestore = function() {
                    const t = z.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }, this.getPixelRatio = function() {
                    return L
                }, this.setPixelRatio = function(t) {
                    void 0 !== t && (L = t, this.setSize(E, A, !1))
                }, this.getSize = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new un), t.set(E, A)
                }, this.setSize = function(t, n, r) {
                    dt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (E = t, A = n, e.width = Math.floor(t * L), e.height = Math.floor(n * L), !1 !== r && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                }, this.getDrawingBufferSize = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new un), t.set(E * L, A * L).floor()
                }, this.setDrawingBufferSize = function(t, n, r) {
                    E = t, A = n, L = r, e.width = Math.floor(t * r), e.height = Math.floor(n * r), this.setViewport(0, 0, t, n)
                }, this.getCurrentViewport = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new gn), t.copy(M)
                }, this.getViewport = function(t) {
                    return t.copy(O)
                }, this.setViewport = function(t, e, n, r) {
                    t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, r), G.viewport(M.copy(O).multiplyScalar(L).floor())
                }, this.getScissor = function(t) {
                    return t.copy(P)
                }, this.setScissor = function(t, e, n, r) {
                    t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, r), G.scissor(T.copy(P).multiplyScalar(L).floor())
                }, this.getScissorTest = function() {
                    return I
                }, this.setScissorTest = function(t) {
                    G.setScissorTest(I = t)
                }, this.setOpaqueSort = function(t) {
                    R = t
                }, this.setTransparentSort = function(t) {
                    C = t
                }, this.getClearColor = function() {
                    return rt.getClearColor()
                }, this.setClearColor = function() {
                    rt.setClearColor.apply(rt, arguments)
                }, this.getClearAlpha = function() {
                    return rt.getClearAlpha()
                }, this.setClearAlpha = function() {
                    rt.setClearAlpha.apply(rt, arguments)
                }, this.clear = function(t, e, n) {
                    let r = 0;
                    (void 0 === t || t) && (r |= 16384), (void 0 === e || e) && (r |= 256), (void 0 === n || n) && (r |= 1024), lt.clear(r)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    e.removeEventListener("webglcontextlost", ft, !1), e.removeEventListener("webglcontextrestored", mt, !1), tt.dispose(), et.dispose(), W.dispose(), q.dispose(), J.dispose(), ct.dispose(), dt.dispose(), St.stop()
                }, this.renderBufferImmediate = function(t, e) {
                    ct.initAttributes();
                    const n = W.get(t);
                    t.hasPositions && !n.position && (n.position = lt.createBuffer()), t.hasNormals && !n.normal && (n.normal = lt.createBuffer()), t.hasUvs && !n.uv && (n.uv = lt.createBuffer()), t.hasColors && !n.color && (n.color = lt.createBuffer());
                    const r = e.getAttributes();
                    t.hasPositions && (lt.bindBuffer(34962, n.position), lt.bufferData(34962, t.positionArray, 35048), ct.enableAttribute(r.position), lt.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)), t.hasNormals && (lt.bindBuffer(34962, n.normal), lt.bufferData(34962, t.normalArray, 35048), ct.enableAttribute(r.normal), lt.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (lt.bindBuffer(34962, n.uv), lt.bufferData(34962, t.uvArray, 35048), ct.enableAttribute(r.uv), lt.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)), t.hasColors && (lt.bindBuffer(34962, n.color), lt.bufferData(34962, t.colorArray, 35048), ct.enableAttribute(r.color), lt.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)), ct.disableUnusedAttributes(), lt.drawArrays(4, 0, t.count), t.count = 0
                }, this.renderBufferDirect = function(t, e, n, r, i, o) {
                    null === e && (e = U);
                    const a = i.isMesh && i.matrixWorld.determinant() < 0,
                        s = Ct(t, e, r, i);
                    G.setMaterial(r, a);
                    let c = n.index;
                    const l = n.attributes.position;
                    if (null === c) {
                        if (void 0 === l || 0 === l.count) return
                    } else if (0 === c.count) return;
                    let u, h = 1;
                    !0 === r.wireframe && (c = Z.getWireframeAttribute(n), h = 2), (r.morphTargets || r.morphNormals) && it.update(i, n, r, s), ct.setup(i, r, s, n, c);
                    let d = ot;
                    null !== c && (u = Y.get(c), d = at, d.setIndex(u));
                    const p = null !== c ? c.count : l.count,
                        f = n.drawRange.start * h,
                        m = n.drawRange.count * h,
                        g = null !== o ? o.start * h : 0,
                        v = null !== o ? o.count * h : 1 / 0,
                        y = Math.max(f, g),
                        _ = Math.min(p, f + m, g + v) - 1,
                        b = Math.max(0, _ - y + 1);
                    if (0 !== b) {
                        if (i.isMesh) !0 === r.wireframe ? (G.setLineWidth(r.wireframeLinewidth * H()), d.setMode(1)) : d.setMode(4);
                        else if (i.isLine) {
                            let t = r.linewidth;
                            void 0 === t && (t = 1), G.setLineWidth(t * H()), i.isLineSegments ? d.setMode(1) : i.isLineLoop ? d.setMode(2) : d.setMode(3)
                        } else i.isPoints ? d.setMode(0) : i.isSprite && d.setMode(4);
                        if (i.isInstancedMesh) d.renderInstances(y, b, i.count);
                        else if (n.isInstancedBufferGeometry) {
                            const t = Math.min(n.instanceCount, n._maxInstanceCount);
                            d.renderInstances(y, b, t)
                        } else d.render(y, b)
                    }
                }, this.compile = function(t, e) {
                    d = et.get(t, e), d.init(), t.traverseVisible((function(t) {
                        t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t))
                    })), d.setupLights(e);
                    const n = new WeakMap;
                    t.traverse((function(e) {
                        const r = e.material;
                        if (r)
                            if (Array.isArray(r))
                                for (let i = 0; i < r.length; i++) {
                                    const o = r[i];
                                    !1 === n.has(o) && (Rt(o, t, e), n.set(o))
                                } else !1 === n.has(r) && (Rt(r, t, e), n.set(r))
                    }))
                };
                let xt = null;

                function wt(t) {
                    dt.isPresenting || xt && xt(t)
                }
                const St = new Ki;

                function Et(t, e, n, r) {
                    if (!1 === t.visible) return;
                    const i = t.layers.test(e.layers);
                    if (i)
                        if (t.isGroup) n = t.renderOrder;
                        else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                    else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || N.intersectsSprite(t)) {
                            r && B.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F);
                            const e = J.update(t),
                                i = t.material;
                            i.visible && h.push(t, e, i, n, B.z, null)
                        }
                    } else if (t.isImmediateRenderObject) r && B.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F), h.push(t, null, t.material, n, B.z, null);
                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== V.render.frame && (t.skeleton.update(), t.skeleton.frame = V.render.frame), !t.frustumCulled || N.intersectsObject(t))) {
                        r && B.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F);
                        const e = J.update(t),
                            i = t.material;
                        if (Array.isArray(i)) {
                            const r = e.groups;
                            for (let o = 0, a = r.length; o < a; o++) {
                                const a = r[o],
                                    s = i[a.materialIndex];
                                s && s.visible && h.push(t, e, s, n, B.z, a)
                            }
                        } else i.visible && h.push(t, e, i, n, B.z, null)
                    }
                    const o = t.children;
                    for (let a = 0, s = o.length; a < s; a++) Et(o[a], e, n, r)
                }

                function At(t, e, n) {
                    const r = !0 === e.isScene ? e.overrideMaterial : null;
                    for (let i = 0, o = t.length; i < o; i++) {
                        const o = t[i],
                            a = o.object,
                            s = o.geometry,
                            c = null === r ? o.material : r,
                            l = o.group;
                        if (n.isArrayCamera) {
                            w = n;
                            const t = n.cameras;
                            for (let n = 0, r = t.length; n < r; n++) {
                                const r = t[n];
                                a.layers.test(r.layers) && (G.viewport(M.copy(r.viewport)), d.setupLights(r), Lt(a, e, r, s, c, l))
                            }
                        } else w = null, Lt(a, e, n, s, c, l)
                    }
                }

                function Lt(t, e, n, r, i, o) {
                    if (t.onBeforeRender(p, e, n, r, i, o), d = et.get(e, w || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                        const r = Ct(n, e, i, t);
                        G.setMaterial(i), ct.reset(), bt(t, r)
                    } else p.renderBufferDirect(n, e, r, i, t, o);
                    t.onAfterRender(p, e, n, r, i, o), d = et.get(e, w || n)
                }

                function Rt(t, e, n) {
                    !0 !== e.isScene && (e = U);
                    const r = W.get(t),
                        i = d.state.lights,
                        o = d.state.shadowsArray,
                        a = i.state.version,
                        s = K.getParameters(t, i.state, o, e, n),
                        c = K.getProgramCacheKey(s);
                    let l = r.program,
                        u = !0;
                    if (void 0 === l) t.addEventListener("dispose", gt);
                    else if (l.cacheKey !== c) _t(t);
                    else if (r.lightsStateVersion !== a) u = !1;
                    else {
                        if (void 0 !== s.shaderID) {
                            const n = t.isMeshStandardMaterial ? e.environment : null;
                            return void(r.envMap = q.get(t.envMap || n))
                        }
                        u = !1
                    }
                    u && (s.uniforms = K.getUniforms(t), t.onBeforeCompile(s, p), l = K.acquireProgram(s, c), r.program = l, r.uniforms = s.uniforms, r.outputEncoding = s.outputEncoding);
                    const h = r.uniforms;
                    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (r.numClippingPlanes = nt.numPlanes, r.numIntersection = nt.numIntersection, h.clippingPlanes = nt.uniform), r.environment = t.isMeshStandardMaterial ? e.environment : null, r.fog = e.fog, r.envMap = q.get(t.envMap || r.environment), r.needsLights = It(t), r.lightsStateVersion = a, r.needsLights && (h.ambientLightColor.value = i.state.ambient, h.lightProbe.value = i.state.probe, h.directionalLights.value = i.state.directional, h.directionalLightShadows.value = i.state.directionalShadow, h.spotLights.value = i.state.spot, h.spotLightShadows.value = i.state.spotShadow, h.rectAreaLights.value = i.state.rectArea, h.ltc_1.value = i.state.rectAreaLTC1, h.ltc_2.value = i.state.rectAreaLTC2, h.pointLights.value = i.state.point, h.pointLightShadows.value = i.state.pointShadow, h.hemisphereLights.value = i.state.hemi, h.directionalShadowMap.value = i.state.directionalShadowMap, h.directionalShadowMatrix.value = i.state.directionalShadowMatrix, h.spotShadowMap.value = i.state.spotShadowMap, h.spotShadowMatrix.value = i.state.spotShadowMatrix, h.pointShadowMap.value = i.state.pointShadowMap, h.pointShadowMatrix.value = i.state.pointShadowMatrix);
                    const f = r.program.getUniforms(),
                        m = Bc.seqWithValue(f.seq, h);
                    r.uniformsList = m
                }

                function Ct(t, e, n, r) {
                    !0 !== e.isScene && (e = U), X.resetTextureUnits();
                    const i = e.fog,
                        o = n.isMeshStandardMaterial ? e.environment : null,
                        a = null === y ? p.outputEncoding : y.texture.encoding,
                        s = q.get(n.envMap || o),
                        c = W.get(n),
                        l = d.state.lights;
                    if (!0 === D && (!0 === k || t !== x)) {
                        const e = t === x && n.id === b;
                        nt.setState(n, t, e)
                    }
                    n.version === c.__version ? n.fog && c.fog !== i || c.environment !== o || c.needsLights && c.lightsStateVersion !== l.state.version ? Rt(n, e, r) : void 0 === c.numClippingPlanes || c.numClippingPlanes === nt.numPlanes && c.numIntersection === nt.numIntersection ? (c.outputEncoding !== a || c.envMap !== s) && Rt(n, e, r) : Rt(n, e, r) : (Rt(n, e, r), c.__version = n.version);
                    let u = !1,
                        h = !1,
                        f = !1;
                    const m = c.program,
                        g = m.getUniforms(),
                        v = c.uniforms;
                    if (G.useProgram(m.program) && (u = !0, h = !0, f = !0), n.id !== b && (b = n.id, h = !0), u || x !== t) {
                        if (g.setValue(lt, "projectionMatrix", t.projectionMatrix), j.logarithmicDepthBuffer && g.setValue(lt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), x !== t && (x = t, h = !0, f = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                            const e = g.map.cameraPosition;
                            void 0 !== e && e.setValue(lt, B.setFromMatrixPosition(t.matrixWorld))
                        }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && g.setValue(lt, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && g.setValue(lt, "viewMatrix", t.matrixWorldInverse)
                    }
                    if (n.skinning) {
                        g.setOptional(lt, r, "bindMatrix"), g.setOptional(lt, r, "bindMatrixInverse");
                        const t = r.skeleton;
                        if (t) {
                            const e = t.bones;
                            if (j.floatVertexTextures) {
                                if (void 0 === t.boneTexture) {
                                    let n = Math.sqrt(4 * e.length);
                                    n = ln.ceilPowerOfTwo(n), n = Math.max(n, 4);
                                    const r = new Float32Array(n * n * 4);
                                    r.set(t.boneMatrices);
                                    const i = new Yi(r, n, n, Ot, Mt);
                                    t.boneMatrices = r, t.boneTexture = i, t.boneTextureSize = n
                                }
                                g.setValue(lt, "boneTexture", t.boneTexture, X), g.setValue(lt, "boneTextureSize", t.boneTextureSize)
                            } else g.setOptional(lt, t, "boneMatrices")
                        }
                    }
                    return (h || c.receiveShadow !== r.receiveShadow) && (c.receiveShadow = r.receiveShadow, g.setValue(lt, "receiveShadow", r.receiveShadow)), h && (g.setValue(lt, "toneMappingExposure", p.toneMappingExposure), c.needsLights && Pt(v, f), i && n.fog && Q.refreshFogUniforms(v, i), Q.refreshMaterialUniforms(v, n, L, A), Bc.upload(lt, c.uniformsList, v, X)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Bc.upload(lt, c.uniformsList, v, X), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && g.setValue(lt, "center", r.center), g.setValue(lt, "modelViewMatrix", r.modelViewMatrix), g.setValue(lt, "normalMatrix", r.normalMatrix), g.setValue(lt, "modelMatrix", r.matrixWorld), m
                }

                function Pt(t, e) {
                    t.ambientLightColor.needsUpdate = e, t.lightProbe.needsUpdate = e, t.directionalLights.needsUpdate = e, t.directionalLightShadows.needsUpdate = e, t.pointLights.needsUpdate = e, t.pointLightShadows.needsUpdate = e, t.spotLights.needsUpdate = e, t.spotLightShadows.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t.hemisphereLights.needsUpdate = e
                }

                function It(t) {
                    return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                }
                St.setAnimationLoop(wt), "undefined" !== typeof window && St.setContext(window), this.setAnimationLoop = function(t) {
                    xt = t, dt.setAnimationLoop(t), null === t ? St.stop() : St.start()
                }, this.render = function(t, e) {
                    let n, r;
                    if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), r = arguments[3]), void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === f) return;
                    ct.resetDefaultState(), b = -1, x = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === dt.enabled && !0 === dt.isPresenting && (e = dt.getCamera(e)), !0 === t.isScene && t.onBeforeRender(p, t, e, n || y), d = et.get(t, e), d.init(), F.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), N.setFromProjectionMatrix(F), k = this.localClippingEnabled, D = nt.init(this.clippingPlanes, k, e), h = tt.get(t, e), h.init(), Et(t, e, 0, p.sortObjects), h.finish(), !0 === p.sortObjects && h.sort(R, C), !0 === D && nt.beginShadows();
                    const i = d.state.shadowsArray;
                    pt.render(i, t, e), d.setupLights(e), !0 === D && nt.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), rt.render(h, t, e, r);
                    const o = h.opaque,
                        a = h.transparent;
                    o.length > 0 && At(o, t, e), a.length > 0 && At(a, t, e), !0 === t.isScene && t.onAfterRender(p, t, e), null !== y && (X.updateRenderTargetMipmap(y), X.updateMultisampleRenderTarget(y)), G.buffers.depth.setTest(!0), G.buffers.depth.setMask(!0), G.buffers.color.setMask(!0), G.setPolygonOffset(!1), h = null, d = null
                }, this.setFramebuffer = function(t) {
                    m !== t && null === y && lt.bindFramebuffer(36160, t), m = t
                }, this.getActiveCubeFace = function() {
                    return g
                }, this.getActiveMipmapLevel = function() {
                    return v
                }, this.getRenderList = function() {
                    return h
                }, this.setRenderList = function(t) {
                    h = t
                }, this.getRenderState = function() {
                    return d
                }, this.setRenderState = function(t) {
                    d = t
                }, this.getRenderTarget = function() {
                    return y
                }, this.setRenderTarget = function(t, e = 0, n = 0) {
                    y = t, g = e, v = n, t && void 0 === W.get(t).__webglFramebuffer && X.setupRenderTarget(t);
                    let r = m,
                        i = !1;
                    if (t) {
                        const n = W.get(t).__webglFramebuffer;
                        t.isWebGLCubeRenderTarget ? (r = n[e], i = !0) : r = t.isWebGLMultisampleRenderTarget ? W.get(t).__webglMultisampledFramebuffer : n, M.copy(t.viewport), T.copy(t.scissor), S = t.scissorTest
                    } else M.copy(O).multiplyScalar(L).floor(), T.copy(P).multiplyScalar(L).floor(), S = I;
                    if (_ !== r && (lt.bindFramebuffer(36160, r), _ = r), G.viewport(M), G.scissor(T), G.setScissorTest(S), i) {
                        const r = W.get(t.texture);
                        lt.framebufferTexture2D(36160, 36064, 34069 + e, r.__webglTexture, n)
                    }
                }, this.readRenderTargetPixels = function(t, e, n, r, i, o, a) {
                    if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let s = W.get(t).__webglFramebuffer;
                    if (t.isWebGLCubeRenderTarget && void 0 !== a && (s = s[a]), s) {
                        let a = !1;
                        s !== _ && (lt.bindFramebuffer(36160, s), a = !0);
                        try {
                            const s = t.texture,
                                c = s.format,
                                l = s.type;
                            if (c !== Ot && st.convert(c) !== lt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            if (l !== vt && st.convert(l) !== lt.getParameter(35738) && (l !== Mt || !(j.isWebGL2 || z.get("OES_texture_float") || z.get("WEBGL_color_buffer_float"))) && (l !== Tt || !(j.isWebGL2 ? z.get("EXT_color_buffer_float") : z.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            36053 === lt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - r && n >= 0 && n <= t.height - i && lt.readPixels(e, n, r, i, st.convert(c), st.convert(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            a && lt.bindFramebuffer(36160, _)
                        }
                    }
                }, this.copyFramebufferToTexture = function(t, e, n) {
                    void 0 === n && (n = 0);
                    const r = Math.pow(2, -n),
                        i = Math.floor(e.image.width * r),
                        o = Math.floor(e.image.height * r),
                        a = st.convert(e.format);
                    X.setTexture2D(e, 0), lt.copyTexImage2D(3553, n, a, t.x, t.y, i, o, 0), G.unbindTexture()
                }, this.copyTextureToTexture = function(t, e, n, r) {
                    void 0 === r && (r = 0);
                    const i = e.image.width,
                        o = e.image.height,
                        a = st.convert(n.format),
                        s = st.convert(n.type);
                    X.setTexture2D(n, 0), lt.pixelStorei(37440, n.flipY), lt.pixelStorei(37441, n.premultiplyAlpha), lt.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? lt.texSubImage2D(3553, r, t.x, t.y, i, o, a, s, e.image.data) : e.isCompressedTexture ? lt.compressedTexSubImage2D(3553, r, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : lt.texSubImage2D(3553, r, t.x, t.y, a, s, e.image), 0 === r && n.generateMipmaps && lt.generateMipmap(3553), G.unbindTexture()
                }, this.initTexture = function(t) {
                    X.setTexture2D(t, 0), G.unbindTexture()
                }, "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }

            function Hl(t) {
                Ul.call(this, t)
            }
            Nl.prototype = Object.assign(Object.create(ji.prototype), {
                constructor: Nl,
                isArrayCamera: !0
            }), Dl.prototype = Object.assign(Object.create(_r.prototype), {
                constructor: Dl,
                isGroup: !0
            }), Object.assign(kl.prototype, {
                constructor: kl,
                getHandSpace: function() {
                    if (null === this._hand && (this._hand = new Dl, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = [], this._hand.inputState = {
                            pinching: !1
                        }, window.XRHand))
                        for (let t = 0; t <= window.XRHand.LITTLE_PHALANX_TIP; t++) {
                            const t = new Dl;
                            t.matrixAutoUpdate = !1, t.visible = !1, this._hand.joints.push(t), this._hand.add(t)
                        }
                    return this._hand
                },
                getTargetRaySpace: function() {
                    return null === this._targetRay && (this._targetRay = new Dl, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay
                },
                getGripSpace: function() {
                    return null === this._grip && (this._grip = new Dl, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip
                },
                dispatchEvent: function(t) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
                },
                disconnect: function(t) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: t
                    }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                },
                update: function(t, e, n) {
                    let r = null,
                        i = null,
                        o = null;
                    const a = this._targetRay,
                        s = this._grip,
                        c = this._hand;
                    if (t)
                        if (c && t.hand) {
                            o = !0;
                            for (let r = 0; r <= window.XRHand.LITTLE_PHALANX_TIP; r++)
                                if (t.hand[r]) {
                                    const i = e.getJointPose(t.hand[r], n),
                                        o = c.joints[r];
                                    null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.jointRadius = i.radius), o.visible = null !== i;
                                    const a = c.joints[window.XRHand.INDEX_PHALANX_TIP],
                                        s = c.joints[window.XRHand.THUMB_PHALANX_TIP],
                                        l = a.position.distanceTo(s.position),
                                        u = .02,
                                        h = .005;
                                    c.inputState.pinching && l > u + h ? (c.inputState.pinching = !1, this.dispatchEvent({
                                        type: "pinchend",
                                        handedness: t.handedness,
                                        target: this
                                    })) : !c.inputState.pinching && l <= u - h && (c.inputState.pinching = !0, this.dispatchEvent({
                                        type: "pinchstart",
                                        handedness: t.handedness,
                                        target: this
                                    }))
                                }
                        } else null !== a && (r = e.getPose(t.targetRaySpace, n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale))), null !== s && t.gripSpace && (i = e.getPose(t.gripSpace, n), null !== i && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale)));
                    return null !== a && (a.visible = null !== r), null !== s && (s.visible = null !== i), null !== c && (c.visible = null !== o), this
                }
            }), Object.assign(Fl.prototype, an.prototype), Hl.prototype = Object.assign(Object.create(Ul.prototype), {
                constructor: Hl,
                isWebGL1Renderer: !0
            });
            class zl extends _r {
                constructor() {
                    super(), Object.defineProperty(this, "isScene", {
                        value: !0
                    }), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                copy(t, e) {
                    return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                }
            }

            function jl(t, e) {
                this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = nn, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0, this.uuid = ln.generateUUID()
            }
            Object.defineProperty(jl.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(jl.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function() {},
                setUsage: function(t) {
                    return this.usage = t, this
                },
                copy: function(t) {
                    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
                },
                copyAt: function(t, e, n) {
                    t *= this.stride, n *= e.stride;
                    for (let r = 0, i = this.stride; r < i; r++) this.array[t + r] = e.array[n + r];
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                clone: function(t) {
                    void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ln.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                        n = new jl(e, this.stride);
                    return n.setUsage(this.usage), n
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                },
                toJSON: function(t) {
                    return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ln.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride
                    }
                }
            });
            const Gl = new bn;

            function Vl(t, e, n, r) {
                this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === r
            }

            function Wl(t) {
                Vr.call(this), this.type = "SpriteMaterial", this.color = new zr(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
            }
            let Xl;
            Object.defineProperties(Vl.prototype, {
                count: {
                    get: function() {
                        return this.data.count
                    }
                },
                array: {
                    get: function() {
                        return this.data.array
                    }
                },
                needsUpdate: {
                    set: function(t) {
                        this.data.needsUpdate = t
                    }
                }
            }), Object.assign(Vl.prototype, {
                isInterleavedBufferAttribute: !0,
                applyMatrix4: function(t) {
                    for (let e = 0, n = this.data.count; e < n; e++) Gl.x = this.getX(e), Gl.y = this.getY(e), Gl.z = this.getZ(e), Gl.applyMatrix4(t), this.setXYZ(e, Gl.x, Gl.y, Gl.z);
                    return this
                },
                setX: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset] = e, this
                },
                setY: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 1] = e, this
                },
                setZ: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 2] = e, this
                },
                setW: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 3] = e, this
                },
                getX: function(t) {
                    return this.data.array[t * this.data.stride + this.offset]
                },
                getY: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1]
                },
                getZ: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2]
                },
                getW: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3]
                },
                setXY: function(t, e, n) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
                },
                setXYZ: function(t, e, n, r) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this
                },
                setXYZW: function(t, e, n, r, i) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = i, this
                },
                clone: function(t) {
                    if (void 0 === t) {
                        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                        const t = [];
                        for (let e = 0; e < this.count; e++) {
                            const n = e * this.data.stride + this.offset;
                            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                        }
                        return new Yr(new this.array.constructor(t), this.itemSize, this.normalized)
                    }
                    return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Vl(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                },
                toJSON: function(t) {
                    if (void 0 === t) {
                        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                        const t = [];
                        for (let e = 0; e < this.count; e++) {
                            const n = e * this.data.stride + this.offset;
                            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: t,
                            normalized: this.normalized
                        }
                    }
                    return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    }
                }
            }), Wl.prototype = Object.create(Vr.prototype), Wl.prototype.constructor = Wl, Wl.prototype.isSpriteMaterial = !0, Wl.prototype.copy = function(t) {
                return Vr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
            };
            const ql = new bn,
                Yl = new bn,
                $l = new bn,
                Zl = new un,
                Jl = new un,
                Kl = new Yn,
                Ql = new bn,
                tu = new bn,
                eu = new bn,
                nu = new un,
                ru = new un,
                iu = new un;

            function ou(t) {
                if (_r.call(this), this.type = "Sprite", void 0 === Xl) {
                    Xl = new pi;
                    const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                        e = new jl(t, 5);
                    Xl.setIndex([0, 1, 2, 0, 2, 3]), Xl.setAttribute("position", new Vl(e, 3, 0, !1)), Xl.setAttribute("uv", new Vl(e, 2, 3, !1))
                }
                this.geometry = Xl, this.material = void 0 !== t ? t : new Wl, this.center = new un(.5, .5)
            }

            function au(t, e, n, r, i, o) {
                Zl.subVectors(t, n).addScalar(.5).multiply(r), void 0 !== i ? (Jl.x = o * Zl.x - i * Zl.y, Jl.y = i * Zl.x + o * Zl.y) : Jl.copy(Zl), t.copy(e), t.x += Jl.x, t.y += Jl.y, t.applyMatrix4(Kl)
            }
            ou.prototype = Object.assign(Object.create(_r.prototype), {
                constructor: ou,
                isSprite: !0,
                raycast: function(t, e) {
                    null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Yl.setFromMatrixScale(this.matrixWorld), Kl.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), $l.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Yl.multiplyScalar(-$l.z);
                    const n = this.material.rotation;
                    let r, i;
                    0 !== n && (i = Math.cos(n), r = Math.sin(n));
                    const o = this.center;
                    au(Ql.set(-.5, -.5, 0), $l, o, Yl, r, i), au(tu.set(.5, -.5, 0), $l, o, Yl, r, i), au(eu.set(.5, .5, 0), $l, o, Yl, r, i), nu.set(0, 0), ru.set(1, 0), iu.set(1, 1);
                    let a = t.ray.intersectTriangle(Ql, tu, eu, !1, ql);
                    if (null === a && (au(tu.set(-.5, .5, 0), $l, o, Yl, r, i), ru.set(0, 1), a = t.ray.intersectTriangle(Ql, eu, tu, !1, ql), null === a)) return;
                    const s = t.ray.origin.distanceTo(ql);
                    s < t.near || s > t.far || e.push({
                        distance: s,
                        point: ql.clone(),
                        uv: Nr.getUV(ql, Ql, tu, eu, nu, ru, iu, new un),
                        face: null,
                        object: this
                    })
                },
                copy: function(t) {
                    return _r.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
                }
            });
            const su = new bn,
                cu = new bn;

            function lu() {
                _r.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                }), this.autoUpdate = !0
            }

            function uu(t, e) {
                t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Oi.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Yn, this.bindMatrixInverse = new Yn
            }
            lu.prototype = Object.assign(Object.create(_r.prototype), {
                constructor: lu,
                isLOD: !0,
                copy: function(t) {
                    _r.prototype.copy.call(this, t, !1);
                    const e = t.levels;
                    for (let n = 0, r = e.length; n < r; n++) {
                        const t = e[n];
                        this.addLevel(t.object.clone(), t.distance)
                    }
                    return this.autoUpdate = t.autoUpdate, this
                },
                addLevel: function(t, e) {
                    void 0 === e && (e = 0), e = Math.abs(e);
                    const n = this.levels;
                    let r;
                    for (r = 0; r < n.length; r++)
                        if (e < n[r].distance) break;
                    return n.splice(r, 0, {
                        distance: e,
                        object: t
                    }), this.add(t), this
                },
                getCurrentLevel: function() {
                    return this._currentLevel
                },
                getObjectForDistance: function(t) {
                    const e = this.levels;
                    if (e.length > 0) {
                        let n, r;
                        for (n = 1, r = e.length; n < r; n++)
                            if (t < e[n].distance) break;
                        return e[n - 1].object
                    }
                    return null
                },
                raycast: function(t, e) {
                    const n = this.levels;
                    if (n.length > 0) {
                        su.setFromMatrixPosition(this.matrixWorld);
                        const n = t.ray.origin.distanceTo(su);
                        this.getObjectForDistance(n).raycast(t, e)
                    }
                },
                update: function(t) {
                    const e = this.levels;
                    if (e.length > 1) {
                        su.setFromMatrixPosition(t.matrixWorld), cu.setFromMatrixPosition(this.matrixWorld);
                        const n = su.distanceTo(cu) / t.zoom;
                        let r, i;
                        for (e[0].object.visible = !0, r = 1, i = e.length; r < i; r++) {
                            if (!(n >= e[r].distance)) break;
                            e[r - 1].object.visible = !1, e[r].object.visible = !0
                        }
                        for (this._currentLevel = r - 1; r < i; r++) e[r].object.visible = !1
                    }
                },
                toJSON: function(t) {
                    const e = _r.prototype.toJSON.call(this, t);
                    !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
                    const n = this.levels;
                    for (let r = 0, i = n.length; r < i; r++) {
                        const t = n[r];
                        e.object.levels.push({
                            object: t.object.uuid,
                            distance: t.distance
                        })
                    }
                    return e
                }
            }), uu.prototype = Object.assign(Object.create(Oi.prototype), {
                constructor: uu,
                isSkinnedMesh: !0,
                copy: function(t) {
                    return Oi.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
                },
                bind: function(t, e) {
                    this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
                },
                pose: function() {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function() {
                    const t = new gn,
                        e = this.geometry.attributes.skinWeight;
                    for (let n = 0, r = e.count; n < r; n++) {
                        t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                        const r = 1 / t.manhattanLength();
                        r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                    }
                },
                updateMatrixWorld: function(t) {
                    Oi.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                },
                boneTransform: function() {
                    const t = new bn,
                        e = new gn,
                        n = new gn,
                        r = new bn,
                        i = new Yn;
                    return function(o, a) {
                        const s = this.skeleton,
                            c = this.geometry;
                        e.fromBufferAttribute(c.attributes.skinIndex, o), n.fromBufferAttribute(c.attributes.skinWeight, o), t.fromBufferAttribute(c.attributes.position, o).applyMatrix4(this.bindMatrix), a.set(0, 0, 0);
                        for (let l = 0; l < 4; l++) {
                            const o = n.getComponent(l);
                            if (0 !== o) {
                                const n = e.getComponent(l);
                                i.multiplyMatrices(s.bones[n].matrixWorld, s.boneInverses[n]), a.addScaledVector(r.copy(t).applyMatrix4(i), o)
                            }
                        }
                        return a.applyMatrix4(this.bindMatrixInverse)
                    }
                }()
            });
            const hu = new Yn,
                du = new Yn;

            function pu(t, e) {
                if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === e) this.calculateInverses();
                else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
                else {
                    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                    for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Yn)
                }
            }

            function fu() {
                _r.call(this), this.type = "Bone"
            }
            Object.assign(pu.prototype, {
                calculateInverses: function() {
                    this.boneInverses = [];
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        const e = new Yn;
                        this.bones[t] && e.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(e)
                    }
                },
                pose: function() {
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        const e = this.bones[t];
                        e && e.matrixWorld.getInverse(this.boneInverses[t])
                    }
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        const e = this.bones[t];
                        e && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                    }
                },
                update: function() {
                    const t = this.bones,
                        e = this.boneInverses,
                        n = this.boneMatrices,
                        r = this.boneTexture;
                    for (let i = 0, o = t.length; i < o; i++) {
                        const r = t[i] ? t[i].matrixWorld : du;
                        hu.multiplyMatrices(r, e[i]), hu.toArray(n, 16 * i)
                    }
                    void 0 !== r && (r.needsUpdate = !0)
                },
                clone: function() {
                    return new pu(this.bones, this.boneInverses)
                },
                getBoneByName: function(t) {
                    for (let e = 0, n = this.bones.length; e < n; e++) {
                        const n = this.bones[e];
                        if (n.name === t) return n
                    }
                },
                dispose: function() {
                    this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0)
                }
            }), fu.prototype = Object.assign(Object.create(_r.prototype), {
                constructor: fu,
                isBone: !0
            });
            const mu = new Yn,
                gu = new Yn,
                vu = [],
                yu = new Oi;

            function _u(t, e, n) {
                Oi.call(this, t, e), this.instanceMatrix = new Yr(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
            }

            function bu(t) {
                Vr.call(this), this.type = "LineBasicMaterial", this.color = new zr(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t)
            }
            _u.prototype = Object.assign(Object.create(Oi.prototype), {
                constructor: _u,
                isInstancedMesh: !0,
                copy: function(t) {
                    return Oi.prototype.copy.call(this, t), this.instanceMatrix.copy(t.instanceMatrix), this.count = t.count, this
                },
                setColorAt: function(t, e) {
                    null === this.instanceColor && (this.instanceColor = new Yr(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
                },
                getMatrixAt: function(t, e) {
                    e.fromArray(this.instanceMatrix.array, 16 * t)
                },
                raycast: function(t, e) {
                    const n = this.matrixWorld,
                        r = this.count;
                    if (yu.geometry = this.geometry, yu.material = this.material, void 0 !== yu.material)
                        for (let i = 0; i < r; i++) {
                            this.getMatrixAt(i, mu), gu.multiplyMatrices(n, mu), yu.matrixWorld = gu, yu.raycast(t, vu);
                            for (let t = 0, n = vu.length; t < n; t++) {
                                const n = vu[t];
                                n.instanceId = i, n.object = this, e.push(n)
                            }
                            vu.length = 0
                        }
                },
                setMatrixAt: function(t, e) {
                    e.toArray(this.instanceMatrix.array, 16 * t)
                },
                updateMorphTargets: function() {}
            }), bu.prototype = Object.create(Vr.prototype), bu.prototype.constructor = bu, bu.prototype.isLineBasicMaterial = !0, bu.prototype.copy = function(t) {
                return Vr.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this
            };
            const xu = new bn,
                wu = new bn,
                Mu = new Yn,
                Tu = new qn,
                Su = new Un;

            function Eu(t, e, n) {
                1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), _r.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new pi, this.material = void 0 !== e ? e : new bu, this.updateMorphTargets()
            }
            Eu.prototype = Object.assign(Object.create(_r.prototype), {
                constructor: Eu,
                isLine: !0,
                copy: function(t) {
                    return _r.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this
                },
                computeLineDistances: function() {
                    const t = this.geometry;
                    if (t.isBufferGeometry)
                        if (null === t.index) {
                            const e = t.attributes.position,
                                n = [0];
                            for (let t = 1, r = e.count; t < r; t++) xu.fromBufferAttribute(e, t - 1), wu.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += xu.distanceTo(wu);
                            t.setAttribute("lineDistance", new ni(n, 1))
                        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else if (t.isGeometry) {
                        const e = t.vertices,
                            n = t.lineDistances;
                        n[0] = 0;
                        for (let t = 1, r = e.length; t < r; t++) n[t] = n[t - 1], n[t] += e[t - 1].distanceTo(e[t])
                    }
                    return this
                },
                raycast: function(t, e) {
                    const n = this.geometry,
                        r = this.matrixWorld,
                        i = t.params.Line.threshold;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), Su.copy(n.boundingSphere), Su.applyMatrix4(r), Su.radius += i, !1 === t.ray.intersectsSphere(Su)) return;
                    Mu.getInverse(r), Tu.copy(t.ray).applyMatrix4(Mu);
                    const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        a = o * o,
                        s = new bn,
                        c = new bn,
                        l = new bn,
                        u = new bn,
                        h = this.isLineSegments ? 2 : 1;
                    if (n.isBufferGeometry) {
                        const r = n.index,
                            i = n.attributes,
                            o = i.position;
                        if (null !== r) {
                            const n = r.array;
                            for (let r = 0, i = n.length - 1; r < i; r += h) {
                                const i = n[r],
                                    h = n[r + 1];
                                s.fromBufferAttribute(o, i), c.fromBufferAttribute(o, h);
                                const d = Tu.distanceSqToSegment(s, c, u, l);
                                if (d > a) continue;
                                u.applyMatrix4(this.matrixWorld);
                                const p = t.ray.origin.distanceTo(u);
                                p < t.near || p > t.far || e.push({
                                    distance: p,
                                    point: l.clone().applyMatrix4(this.matrixWorld),
                                    index: r,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        } else
                            for (let n = 0, d = o.count - 1; n < d; n += h) {
                                s.fromBufferAttribute(o, n), c.fromBufferAttribute(o, n + 1);
                                const r = Tu.distanceSqToSegment(s, c, u, l);
                                if (r > a) continue;
                                u.applyMatrix4(this.matrixWorld);
                                const i = t.ray.origin.distanceTo(u);
                                i < t.near || i > t.far || e.push({
                                    distance: i,
                                    point: l.clone().applyMatrix4(this.matrixWorld),
                                    index: n,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                    } else if (n.isGeometry) {
                        const r = n.vertices,
                            i = r.length;
                        for (let n = 0; n < i - 1; n += h) {
                            const i = Tu.distanceSqToSegment(r[n], r[n + 1], u, l);
                            if (i > a) continue;
                            u.applyMatrix4(this.matrixWorld);
                            const o = t.ray.origin.distanceTo(u);
                            o < t.near || o > t.far || e.push({
                                distance: o,
                                point: l.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    }
                },
                updateMorphTargets: function() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            n = Object.keys(e);
                        if (n.length > 0) {
                            const t = e[n[0]];
                            if (void 0 !== t) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
            });
            const Au = new bn,
                Lu = new bn;

            function Ru(t, e) {
                Eu.call(this, t, e), this.type = "LineSegments"
            }

            function Cu(t, e) {
                Eu.call(this, t, e), this.type = "LineLoop"
            }

            function Ou(t) {
                Vr.call(this), this.type = "PointsMaterial", this.color = new zr(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t)
            }
            Ru.prototype = Object.assign(Object.create(Eu.prototype), {
                constructor: Ru,
                isLineSegments: !0,
                computeLineDistances: function() {
                    const t = this.geometry;
                    if (t.isBufferGeometry)
                        if (null === t.index) {
                            const e = t.attributes.position,
                                n = [];
                            for (let t = 0, r = e.count; t < r; t += 2) Au.fromBufferAttribute(e, t), Lu.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + Au.distanceTo(Lu);
                            t.setAttribute("lineDistance", new ni(n, 1))
                        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else if (t.isGeometry) {
                        const e = t.vertices,
                            n = t.lineDistances;
                        for (let t = 0, r = e.length; t < r; t += 2) Au.copy(e[t]), Lu.copy(e[t + 1]), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + Au.distanceTo(Lu)
                    }
                    return this
                }
            }), Cu.prototype = Object.assign(Object.create(Eu.prototype), {
                constructor: Cu,
                isLineLoop: !0
            }), Ou.prototype = Object.create(Vr.prototype), Ou.prototype.constructor = Ou, Ou.prototype.isPointsMaterial = !0, Ou.prototype.copy = function(t) {
                return Vr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
            };
            const Pu = new Yn,
                Iu = new qn,
                Nu = new Un,
                Du = new bn;

            function ku(t, e) {
                _r.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new pi, this.material = void 0 !== e ? e : new Ou, this.updateMorphTargets()
            }

            function Fu(t, e, n, r, i, o, a) {
                const s = Iu.distanceSqToPoint(t);
                if (s < n) {
                    const n = new bn;
                    Iu.closestPointToPoint(t, n), n.applyMatrix4(r);
                    const c = i.ray.origin.distanceTo(n);
                    if (c < i.near || c > i.far) return;
                    o.push({
                        distance: c,
                        distanceToRay: Math.sqrt(s),
                        point: n,
                        index: e,
                        face: null,
                        object: a
                    })
                }
            }

            function Bu(t, e, n, r, i, o, a, s, c) {
                mn.call(this, t, e, n, r, i, o, a, s, c), this.format = void 0 !== a ? a : Ct, this.minFilter = void 0 !== o ? o : ft, this.magFilter = void 0 !== i ? i : ft, this.generateMipmaps = !1;
                const l = this;

                function u() {
                    l.needsUpdate = !0, t.requestVideoFrameCallback(u)
                }
                "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(u)
            }

            function Uu(t, e, n, r, i, o, a, s, c, l, u, h) {
                mn.call(this, null, o, a, s, c, l, r, i, u, h), this.image = {
                    width: e,
                    height: n
                }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
            }

            function Hu(t, e, n, r, i, o, a, s, c) {
                mn.call(this, t, e, n, r, i, o, a, s, c), this.needsUpdate = !0
            }

            function zu(t, e, n, r, i, o, a, s, c, l) {
                if (l = void 0 !== l ? l : Nt, l !== Nt && l !== Dt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && l === Nt && (n = bt), void 0 === n && l === Dt && (n = Lt), mn.call(this, null, r, i, o, a, s, l, n, c), this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== a ? a : ht, this.minFilter = void 0 !== s ? s : ht, this.flipY = !1, this.generateMipmaps = !1
            }
            ku.prototype = Object.assign(Object.create(_r.prototype), {
                constructor: ku,
                isPoints: !0,
                copy: function(t) {
                    return _r.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this
                },
                raycast: function(t, e) {
                    const n = this.geometry,
                        r = this.matrixWorld,
                        i = t.params.Points.threshold;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), Nu.copy(n.boundingSphere), Nu.applyMatrix4(r), Nu.radius += i, !1 === t.ray.intersectsSphere(Nu)) return;
                    Pu.getInverse(r), Iu.copy(t.ray).applyMatrix4(Pu);
                    const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        a = o * o;
                    if (n.isBufferGeometry) {
                        const i = n.index,
                            o = n.attributes,
                            s = o.position;
                        if (null !== i) {
                            const n = i.array;
                            for (let i = 0, o = n.length; i < o; i++) {
                                const o = n[i];
                                Du.fromBufferAttribute(s, o), Fu(Du, o, a, r, t, e, this)
                            }
                        } else
                            for (let n = 0, c = s.count; n < c; n++) Du.fromBufferAttribute(s, n), Fu(Du, n, a, r, t, e, this)
                    } else {
                        const i = n.vertices;
                        for (let n = 0, o = i.length; n < o; n++) Fu(i[n], n, a, r, t, e, this)
                    }
                },
                updateMorphTargets: function() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            n = Object.keys(e);
                        if (n.length > 0) {
                            const t = e[n[0]];
                            if (void 0 !== t) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
            }), Bu.prototype = Object.assign(Object.create(mn.prototype), {
                constructor: Bu,
                clone: function() {
                    return new this.constructor(this.image).copy(this)
                },
                isVideoTexture: !0,
                update: function() {
                    const t = this.image,
                        e = "requestVideoFrameCallback" in t;
                    !1 === e && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }), Uu.prototype = Object.create(mn.prototype), Uu.prototype.constructor = Uu, Uu.prototype.isCompressedTexture = !0, Hu.prototype = Object.create(mn.prototype), Hu.prototype.constructor = Hu, Hu.prototype.isCanvasTexture = !0, zu.prototype = Object.create(mn.prototype), zu.prototype.constructor = zu, zu.prototype.isDepthTexture = !0;
            let ju = 0;
            const Gu = new Yn,
                Vu = new _r,
                Wu = new bn;

            function Xu() {
                Object.defineProperty(this, "id", {
                    value: ju += 2
                }), this.uuid = ln.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }
            Xu.prototype = Object.assign(Object.create(an.prototype), {
                constructor: Xu,
                isGeometry: !0,
                applyMatrix4: function(t) {
                    const e = (new hn).getNormalMatrix(t);
                    for (let n = 0, r = this.vertices.length; n < r; n++) {
                        const e = this.vertices[n];
                        e.applyMatrix4(t)
                    }
                    for (let n = 0, r = this.faces.length; n < r; n++) {
                        const t = this.faces[n];
                        t.normal.applyMatrix3(e).normalize();
                        for (let n = 0, r = t.vertexNormals.length; n < r; n++) t.vertexNormals[n].applyMatrix3(e).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: function(t) {
                    return Gu.makeRotationX(t), this.applyMatrix4(Gu), this
                },
                rotateY: function(t) {
                    return Gu.makeRotationY(t), this.applyMatrix4(Gu), this
                },
                rotateZ: function(t) {
                    return Gu.makeRotationZ(t), this.applyMatrix4(Gu), this
                },
                translate: function(t, e, n) {
                    return Gu.makeTranslation(t, e, n), this.applyMatrix4(Gu), this
                },
                scale: function(t, e, n) {
                    return Gu.makeScale(t, e, n), this.applyMatrix4(Gu), this
                },
                lookAt: function(t) {
                    return Vu.lookAt(t), Vu.updateMatrix(), this.applyMatrix4(Vu.matrix), this
                },
                fromBufferGeometry: function(t) {
                    const e = this,
                        n = null !== t.index ? t.index : void 0,
                        r = t.attributes;
                    if (void 0 === r.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
                    const i = r.position,
                        o = r.normal,
                        a = r.color,
                        s = r.uv,
                        c = r.uv2;
                    void 0 !== c && (this.faceVertexUvs[1] = []);
                    for (let h = 0; h < i.count; h++) e.vertices.push((new bn).fromBufferAttribute(i, h)), void 0 !== a && e.colors.push((new zr).fromBufferAttribute(a, h));

                    function l(t, n, r, i) {
                        const l = void 0 === a ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[r].clone()],
                            u = void 0 === o ? [] : [(new bn).fromBufferAttribute(o, t), (new bn).fromBufferAttribute(o, n), (new bn).fromBufferAttribute(o, r)],
                            h = new jr(t, n, r, u, l, i);
                        e.faces.push(h), void 0 !== s && e.faceVertexUvs[0].push([(new un).fromBufferAttribute(s, t), (new un).fromBufferAttribute(s, n), (new un).fromBufferAttribute(s, r)]), void 0 !== c && e.faceVertexUvs[1].push([(new un).fromBufferAttribute(c, t), (new un).fromBufferAttribute(c, n), (new un).fromBufferAttribute(c, r)])
                    }
                    const u = t.groups;
                    if (u.length > 0)
                        for (let h = 0; h < u.length; h++) {
                            const t = u[h],
                                e = t.start,
                                r = t.count;
                            for (let i = e, o = e + r; i < o; i += 3) void 0 !== n ? l(n.getX(i), n.getX(i + 1), n.getX(i + 2), t.materialIndex) : l(i, i + 1, i + 2, t.materialIndex)
                        } else if (void 0 !== n)
                            for (let h = 0; h < n.count; h += 3) l(n.getX(h), n.getX(h + 1), n.getX(h + 2));
                        else
                            for (let h = 0; h < i.count; h += 3) l(h, h + 1, h + 2);
                    return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                },
                center: function() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(Wu).negate(), this.translate(Wu.x, Wu.y, Wu.z), this
                },
                normalize: function() {
                    this.computeBoundingSphere();
                    const t = this.boundingSphere.center,
                        e = this.boundingSphere.radius,
                        n = 0 === e ? 1 : 1 / e,
                        r = new Yn;
                    return r.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix4(r), this
                },
                computeFaceNormals: function() {
                    const t = new bn,
                        e = new bn;
                    for (let n = 0, r = this.faces.length; n < r; n++) {
                        const r = this.faces[n],
                            i = this.vertices[r.a],
                            o = this.vertices[r.b],
                            a = this.vertices[r.c];
                        t.subVectors(a, o), e.subVectors(i, o), t.cross(e), t.normalize(), r.normal.copy(t)
                    }
                },
                computeVertexNormals: function(t) {
                    void 0 === t && (t = !0);
                    const e = new Array(this.vertices.length);
                    for (let n = 0, r = this.vertices.length; n < r; n++) e[n] = new bn;
                    if (t) {
                        const t = new bn,
                            n = new bn;
                        for (let r = 0, i = this.faces.length; r < i; r++) {
                            const i = this.faces[r],
                                o = this.vertices[i.a],
                                a = this.vertices[i.b],
                                s = this.vertices[i.c];
                            t.subVectors(s, a), n.subVectors(o, a), t.cross(n), e[i.a].add(t), e[i.b].add(t), e[i.c].add(t)
                        }
                    } else {
                        this.computeFaceNormals();
                        for (let t = 0, n = this.faces.length; t < n; t++) {
                            const n = this.faces[t];
                            e[n.a].add(n.normal), e[n.b].add(n.normal), e[n.c].add(n.normal)
                        }
                    }
                    for (let n = 0, r = this.vertices.length; n < r; n++) e[n].normalize();
                    for (let n = 0, r = this.faces.length; n < r; n++) {
                        const t = this.faces[n],
                            r = t.vertexNormals;
                        3 === r.length ? (r[0].copy(e[t.a]), r[1].copy(e[t.b]), r[2].copy(e[t.c])) : (r[0] = e[t.a].clone(), r[1] = e[t.b].clone(), r[2] = e[t.c].clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function() {
                    this.computeFaceNormals();
                    for (let t = 0, e = this.faces.length; t < e; t++) {
                        const e = this.faces[t],
                            n = e.vertexNormals;
                        3 === n.length ? (n[0].copy(e.normal), n[1].copy(e.normal), n[2].copy(e.normal)) : (n[0] = e.normal.clone(), n[1] = e.normal.clone(), n[2] = e.normal.clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    for (let e = 0, n = this.faces.length; e < n; e++) {
                        const t = this.faces[e];
                        t.__originalFaceNormal ? t.__originalFaceNormal.copy(t.normal) : t.__originalFaceNormal = t.normal.clone(), t.__originalVertexNormals || (t.__originalVertexNormals = []);
                        for (let e = 0, n = t.vertexNormals.length; e < n; e++) t.__originalVertexNormals[e] ? t.__originalVertexNormals[e].copy(t.vertexNormals[e]) : t.__originalVertexNormals[e] = t.vertexNormals[e].clone()
                    }
                    const t = new Xu;
                    t.faces = this.faces;
                    for (let e = 0, n = this.morphTargets.length; e < n; e++) {
                        if (!this.morphNormals[e]) {
                            this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                            const t = this.morphNormals[e].faceNormals,
                                n = this.morphNormals[e].vertexNormals;
                            for (let e = 0, r = this.faces.length; e < r; e++) {
                                const e = new bn,
                                    r = {
                                        a: new bn,
                                        b: new bn,
                                        c: new bn
                                    };
                                t.push(e), n.push(r)
                            }
                        }
                        const n = this.morphNormals[e];
                        t.vertices = this.morphTargets[e].vertices, t.computeFaceNormals(), t.computeVertexNormals();
                        for (let t = 0, e = this.faces.length; t < e; t++) {
                            const e = this.faces[t],
                                r = n.faceNormals[t],
                                i = n.vertexNormals[t];
                            r.copy(e.normal), i.a.copy(e.vertexNormals[0]), i.b.copy(e.vertexNormals[1]), i.c.copy(e.vertexNormals[2])
                        }
                    }
                    for (let e = 0, n = this.faces.length; e < n; e++) {
                        const t = this.faces[e];
                        t.normal = t.__originalFaceNormal, t.vertexNormals = t.__originalVertexNormals
                    }
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new Mn), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new Un), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(t, e, n) {
                    if (!t || !t.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
                    let r;
                    const i = this.vertices.length,
                        o = this.vertices,
                        a = t.vertices,
                        s = this.faces,
                        c = t.faces,
                        l = this.colors,
                        u = t.colors;
                    void 0 === n && (n = 0), void 0 !== e && (r = (new hn).getNormalMatrix(e));
                    for (let h = 0, d = a.length; h < d; h++) {
                        const t = a[h],
                            n = t.clone();
                        void 0 !== e && n.applyMatrix4(e), o.push(n)
                    }
                    for (let h = 0, d = u.length; h < d; h++) l.push(u[h].clone());
                    for (let h = 0, d = c.length; h < d; h++) {
                        const t = c[h];
                        let e, o;
                        const a = t.vertexNormals,
                            l = t.vertexColors,
                            u = new jr(t.a + i, t.b + i, t.c + i);
                        u.normal.copy(t.normal), void 0 !== r && u.normal.applyMatrix3(r).normalize();
                        for (let n = 0, i = a.length; n < i; n++) e = a[n].clone(), void 0 !== r && e.applyMatrix3(r).normalize(), u.vertexNormals.push(e);
                        u.color.copy(t.color);
                        for (let n = 0, r = l.length; n < r; n++) o = l[n], u.vertexColors.push(o.clone());
                        u.materialIndex = t.materialIndex + n, s.push(u)
                    }
                    for (let h = 0, d = t.faceVertexUvs.length; h < d; h++) {
                        const e = t.faceVertexUvs[h];
                        void 0 === this.faceVertexUvs[h] && (this.faceVertexUvs[h] = []);
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t],
                                r = [];
                            for (let t = 0, e = n.length; t < e; t++) r.push(n[t].clone());
                            this.faceVertexUvs[h].push(r)
                        }
                    }
                },
                mergeMesh: function(t) {
                    t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
                },
                mergeVertices: function() {
                    const t = {},
                        e = [],
                        n = [],
                        r = 4,
                        i = Math.pow(10, r);
                    for (let s = 0, c = this.vertices.length; s < c; s++) {
                        const r = this.vertices[s],
                            o = Math.round(r.x * i) + "_" + Math.round(r.y * i) + "_" + Math.round(r.z * i);
                        void 0 === t[o] ? (t[o] = s, e.push(this.vertices[s]), n[s] = e.length - 1) : n[s] = n[t[o]]
                    }
                    const o = [];
                    for (let s = 0, c = this.faces.length; s < c; s++) {
                        const t = this.faces[s];
                        t.a = n[t.a], t.b = n[t.b], t.c = n[t.c];
                        const e = [t.a, t.b, t.c];
                        for (let n = 0; n < 3; n++)
                            if (e[n] === e[(n + 1) % 3]) {
                                o.push(s);
                                break
                            }
                    }
                    for (let s = o.length - 1; s >= 0; s--) {
                        const t = o[s];
                        this.faces.splice(t, 1);
                        for (let e = 0, n = this.faceVertexUvs.length; e < n; e++) this.faceVertexUvs[e].splice(t, 1)
                    }
                    const a = this.vertices.length - e.length;
                    return this.vertices = e, a
                },
                setFromPoints: function(t) {
                    this.vertices = [];
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        this.vertices.push(new bn(n.x, n.y, n.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function() {
                    const t = this.faces,
                        e = t.length;
                    for (let s = 0; s < e; s++) t[s]._id = s;

                    function n(t, e) {
                        return t.materialIndex - e.materialIndex
                    }
                    t.sort(n);
                    const r = this.faceVertexUvs[0],
                        i = this.faceVertexUvs[1];
                    let o, a;
                    r && r.length === e && (o = []), i && i.length === e && (a = []);
                    for (let s = 0; s < e; s++) {
                        const e = t[s]._id;
                        o && o.push(r[e]), a && a.push(i[e])
                    }
                    o && (this.faceVertexUvs[0] = o), a && (this.faceVertexUvs[1] = a)
                },
                toJSON: function() {
                    const t = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                        const e = this.parameters;
                        for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                        return t
                    }
                    const e = [];
                    for (let p = 0; p < this.vertices.length; p++) {
                        const t = this.vertices[p];
                        e.push(t.x, t.y, t.z)
                    }
                    const n = [],
                        r = [],
                        i = {},
                        o = [],
                        a = {},
                        s = [],
                        c = {};
                    for (let p = 0; p < this.faces.length; p++) {
                        const t = this.faces[p],
                            e = !0,
                            r = !1,
                            i = void 0 !== this.faceVertexUvs[0][p],
                            o = t.normal.length() > 0,
                            a = t.vertexNormals.length > 0,
                            s = 1 !== t.color.r || 1 !== t.color.g || 1 !== t.color.b,
                            c = t.vertexColors.length > 0;
                        let f = 0;
                        if (f = l(f, 0, 0), f = l(f, 1, e), f = l(f, 2, r), f = l(f, 3, i), f = l(f, 4, o), f = l(f, 5, a), f = l(f, 6, s), f = l(f, 7, c), n.push(f), n.push(t.a, t.b, t.c), n.push(t.materialIndex), i) {
                            const t = this.faceVertexUvs[0][p];
                            n.push(d(t[0]), d(t[1]), d(t[2]))
                        }
                        if (o && n.push(u(t.normal)), a) {
                            const e = t.vertexNormals;
                            n.push(u(e[0]), u(e[1]), u(e[2]))
                        }
                        if (s && n.push(h(t.color)), c) {
                            const e = t.vertexColors;
                            n.push(h(e[0]), h(e[1]), h(e[2]))
                        }
                    }

                    function l(t, e, n) {
                        return n ? t | 1 << e : t & ~(1 << e)
                    }

                    function u(t) {
                        const e = t.x.toString() + t.y.toString() + t.z.toString();
                        return void 0 !== i[e] || (i[e] = r.length / 3, r.push(t.x, t.y, t.z)), i[e]
                    }

                    function h(t) {
                        const e = t.r.toString() + t.g.toString() + t.b.toString();
                        return void 0 !== a[e] || (a[e] = o.length, o.push(t.getHex())), a[e]
                    }

                    function d(t) {
                        const e = t.x.toString() + t.y.toString();
                        return void 0 !== c[e] || (c[e] = s.length / 2, s.push(t.x, t.y)), c[e]
                    }
                    return t.data = {}, t.data.vertices = e, t.data.normals = r, o.length > 0 && (t.data.colors = o), s.length > 0 && (t.data.uvs = [s]), t.data.faces = n, t
                },
                clone: function() {
                    return (new Xu).copy(this)
                },
                copy: function(t) {
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    const e = t.vertices;
                    for (let h = 0, d = e.length; h < d; h++) this.vertices.push(e[h].clone());
                    const n = t.colors;
                    for (let h = 0, d = n.length; h < d; h++) this.colors.push(n[h].clone());
                    const r = t.faces;
                    for (let h = 0, d = r.length; h < d; h++) this.faces.push(r[h].clone());
                    for (let h = 0, d = t.faceVertexUvs.length; h < d; h++) {
                        const e = t.faceVertexUvs[h];
                        void 0 === this.faceVertexUvs[h] && (this.faceVertexUvs[h] = []);
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t],
                                r = [];
                            for (let t = 0, e = n.length; t < e; t++) {
                                const e = n[t];
                                r.push(e.clone())
                            }
                            this.faceVertexUvs[h].push(r)
                        }
                    }
                    const i = t.morphTargets;
                    for (let h = 0, d = i.length; h < d; h++) {
                        const t = {};
                        if (t.name = i[h].name, void 0 !== i[h].vertices) {
                            t.vertices = [];
                            for (let e = 0, n = i[h].vertices.length; e < n; e++) t.vertices.push(i[h].vertices[e].clone())
                        }
                        if (void 0 !== i[h].normals) {
                            t.normals = [];
                            for (let e = 0, n = i[h].normals.length; e < n; e++) t.normals.push(i[h].normals[e].clone())
                        }
                        this.morphTargets.push(t)
                    }
                    const o = t.morphNormals;
                    for (let h = 0, d = o.length; h < d; h++) {
                        const t = {};
                        if (void 0 !== o[h].vertexNormals) {
                            t.vertexNormals = [];
                            for (let e = 0, n = o[h].vertexNormals.length; e < n; e++) {
                                const n = o[h].vertexNormals[e],
                                    r = {};
                                r.a = n.a.clone(), r.b = n.b.clone(), r.c = n.c.clone(), t.vertexNormals.push(r)
                            }
                        }
                        if (void 0 !== o[h].faceNormals) {
                            t.faceNormals = [];
                            for (let e = 0, n = o[h].faceNormals.length; e < n; e++) t.faceNormals.push(o[h].faceNormals[e].clone())
                        }
                        this.morphNormals.push(t)
                    }
                    const a = t.skinWeights;
                    for (let h = 0, d = a.length; h < d; h++) this.skinWeights.push(a[h].clone());
                    const s = t.skinIndices;
                    for (let h = 0, d = s.length; h < d; h++) this.skinIndices.push(s[h].clone());
                    const c = t.lineDistances;
                    for (let h = 0, d = c.length; h < d; h++) this.lineDistances.push(c[h]);
                    const l = t.boundingBox;
                    null !== l && (this.boundingBox = l.clone());
                    const u = t.boundingSphere;
                    return null !== u && (this.boundingSphere = u.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            new bn, new bn, new bn, new Nr;
            const qu = {
                triangulate: function(t, e, n) {
                    n = n || 2;
                    const r = e && e.length,
                        i = r ? e[0] * n : t.length;
                    let o = Yu(t, 0, i, n, !0);
                    const a = [];
                    if (!o || o.next === o.prev) return a;
                    let s, c, l, u, h, d, p;
                    if (r && (o = eh(t, e, o, n)), t.length > 80 * n) {
                        s = l = t[0], c = u = t[1];
                        for (let e = n; e < i; e += n) h = t[e], d = t[e + 1], h < s && (s = h), d < c && (c = d), h > l && (l = h), d > u && (u = d);
                        p = Math.max(l - s, u - c), p = 0 !== p ? 1 / p : 0
                    }
                    return Zu(o, a, n, s, c, p), a
                }
            };

            function Yu(t, e, n, r, i) {
                let o, a;
                if (i === Th(t, e, n, r) > 0)
                    for (o = e; o < n; o += r) a = xh(o, t[o], t[o + 1], a);
                else
                    for (o = n - r; o >= e; o -= r) a = xh(o, t[o], t[o + 1], a);
                return a && ph(a, a.next) && (wh(a), a = a.next), a
            }

            function $u(t, e) {
                if (!t) return t;
                e || (e = t);
                let n, r = t;
                do {
                    if (n = !1, r.steiner || !ph(r, r.next) && 0 !== dh(r.prev, r, r.next)) r = r.next;
                    else {
                        if (wh(r), r = e = r.prev, r === r.next) break;
                        n = !0
                    }
                } while (n || r !== e);
                return e
            }

            function Zu(t, e, n, r, i, o, a) {
                if (!t) return;
                !a && o && ah(t, r, i, o);
                let s, c, l = t;
                while (t.prev !== t.next)
                    if (s = t.prev, c = t.next, o ? Ku(t, r, i, o) : Ju(t)) e.push(s.i / n), e.push(t.i / n), e.push(c.i / n), wh(t), t = c.next, l = c.next;
                    else if (t = c, t === l) {
                    a ? 1 === a ? (t = Qu($u(t), e, n), Zu(t, e, n, r, i, o, 2)) : 2 === a && th(t, e, n, r, i, o) : Zu($u(t), e, n, r, i, o, 1);
                    break
                }
            }

            function Ju(t) {
                const e = t.prev,
                    n = t,
                    r = t.next;
                if (dh(e, n, r) >= 0) return !1;
                let i = t.next.next;
                while (i !== t.prev) {
                    if (uh(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && dh(i.prev, i, i.next) >= 0) return !1;
                    i = i.next
                }
                return !0
            }

            function Ku(t, e, n, r) {
                const i = t.prev,
                    o = t,
                    a = t.next;
                if (dh(i, o, a) >= 0) return !1;
                const s = i.x < o.x ? i.x < a.x ? i.x : a.x : o.x < a.x ? o.x : a.x,
                    c = i.y < o.y ? i.y < a.y ? i.y : a.y : o.y < a.y ? o.y : a.y,
                    l = i.x > o.x ? i.x > a.x ? i.x : a.x : o.x > a.x ? o.x : a.x,
                    u = i.y > o.y ? i.y > a.y ? i.y : a.y : o.y > a.y ? o.y : a.y,
                    h = ch(s, c, e, n, r),
                    d = ch(l, u, e, n, r);
                let p = t.prevZ,
                    f = t.nextZ;
                while (p && p.z >= h && f && f.z <= d) {
                    if (p !== t.prev && p !== t.next && uh(i.x, i.y, o.x, o.y, a.x, a.y, p.x, p.y) && dh(p.prev, p, p.next) >= 0) return !1;
                    if (p = p.prevZ, f !== t.prev && f !== t.next && uh(i.x, i.y, o.x, o.y, a.x, a.y, f.x, f.y) && dh(f.prev, f, f.next) >= 0) return !1;
                    f = f.nextZ
                }
                while (p && p.z >= h) {
                    if (p !== t.prev && p !== t.next && uh(i.x, i.y, o.x, o.y, a.x, a.y, p.x, p.y) && dh(p.prev, p, p.next) >= 0) return !1;
                    p = p.prevZ
                }
                while (f && f.z <= d) {
                    if (f !== t.prev && f !== t.next && uh(i.x, i.y, o.x, o.y, a.x, a.y, f.x, f.y) && dh(f.prev, f, f.next) >= 0) return !1;
                    f = f.nextZ
                }
                return !0
            }

            function Qu(t, e, n) {
                let r = t;
                do {
                    const i = r.prev,
                        o = r.next.next;
                    !ph(i, o) && fh(i, r, r.next, o) && yh(i, o) && yh(o, i) && (e.push(i.i / n), e.push(r.i / n), e.push(o.i / n), wh(r), wh(r.next), r = t = o), r = r.next
                } while (r !== t);
                return $u(r)
            }

            function th(t, e, n, r, i, o) {
                let a = t;
                do {
                    let t = a.next.next;
                    while (t !== a.prev) {
                        if (a.i !== t.i && hh(a, t)) {
                            let s = bh(a, t);
                            return a = $u(a, a.next), s = $u(s, s.next), Zu(a, e, n, r, i, o), void Zu(s, e, n, r, i, o)
                        }
                        t = t.next
                    }
                    a = a.next
                } while (a !== t)
            }

            function eh(t, e, n, r) {
                const i = [];
                let o, a, s, c, l;
                for (o = 0, a = e.length; o < a; o++) s = e[o] * r, c = o < a - 1 ? e[o + 1] * r : t.length, l = Yu(t, s, c, r, !1), l === l.next && (l.steiner = !0), i.push(lh(l));
                for (i.sort(nh), o = 0; o < i.length; o++) rh(i[o], n), n = $u(n, n.next);
                return n
            }

            function nh(t, e) {
                return t.x - e.x
            }

            function rh(t, e) {
                if (e = ih(t, e), e) {
                    const n = bh(e, t);
                    $u(e, e.next), $u(n, n.next)
                }
            }

            function ih(t, e) {
                let n = e;
                const r = t.x,
                    i = t.y;
                let o, a = -1 / 0;
                do {
                    if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
                        const t = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                        if (t <= r && t > a) {
                            if (a = t, t === r) {
                                if (i === n.y) return n;
                                if (i === n.next.y) return n.next
                            }
                            o = n.x < n.next.x ? n : n.next
                        }
                    }
                    n = n.next
                } while (n !== e);
                if (!o) return null;
                if (r === a) return o;
                const s = o,
                    c = o.x,
                    l = o.y;
                let u, h = 1 / 0;
                n = o;
                do {
                    r >= n.x && n.x >= c && r !== n.x && uh(i < l ? r : a, i, c, l, i < l ? a : r, i, n.x, n.y) && (u = Math.abs(i - n.y) / (r - n.x), yh(n, t) && (u < h || u === h && (n.x > o.x || n.x === o.x && oh(o, n))) && (o = n, h = u)), n = n.next
                } while (n !== s);
                return o
            }

            function oh(t, e) {
                return dh(t.prev, t, e.prev) < 0 && dh(e.next, t, t.next) < 0
            }

            function ah(t, e, n, r) {
                let i = t;
                do {
                    null === i.z && (i.z = ch(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next
                } while (i !== t);
                i.prevZ.nextZ = null, i.prevZ = null, sh(i)
            }

            function sh(t) {
                let e, n, r, i, o, a, s, c, l = 1;
                do {
                    n = t, t = null, o = null, a = 0;
                    while (n) {
                        for (a++, r = n, s = 0, e = 0; e < l; e++)
                            if (s++, r = r.nextZ, !r) break;
                        c = l;
                        while (s > 0 || c > 0 && r) 0 !== s && (0 === c || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, c--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i;
                        n = r
                    }
                    o.nextZ = null, l *= 2
                } while (a > 1);
                return t
            }

            function ch(t, e, n, r, i) {
                return t = 32767 * (t - n) * i, e = 32767 * (e - r) * i, t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t | e << 1
            }

            function lh(t) {
                let e = t,
                    n = t;
                do {
                    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                } while (e !== t);
                return n
            }

            function uh(t, e, n, r, i, o, a, s) {
                return (i - a) * (e - s) - (t - a) * (o - s) >= 0 && (t - a) * (r - s) - (n - a) * (e - s) >= 0 && (n - a) * (o - s) - (i - a) * (r - s) >= 0
            }

            function hh(t, e) {
                return t.next.i !== e.i && t.prev.i !== e.i && !vh(t, e) && (yh(t, e) && yh(e, t) && _h(t, e) && (dh(t.prev, t, e.prev) || dh(t, e.prev, e)) || ph(t, e) && dh(t.prev, t, t.next) > 0 && dh(e.prev, e, e.next) > 0)
            }

            function dh(t, e, n) {
                return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
            }

            function ph(t, e) {
                return t.x === e.x && t.y === e.y
            }

            function fh(t, e, n, r) {
                const i = gh(dh(t, e, n)),
                    o = gh(dh(t, e, r)),
                    a = gh(dh(n, r, t)),
                    s = gh(dh(n, r, e));
                return i !== o && a !== s || (!(0 !== i || !mh(t, n, e)) || (!(0 !== o || !mh(t, r, e)) || (!(0 !== a || !mh(n, t, r)) || !(0 !== s || !mh(n, e, r)))))
            }

            function mh(t, e, n) {
                return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
            }

            function gh(t) {
                return t > 0 ? 1 : t < 0 ? -1 : 0
            }

            function vh(t, e) {
                let n = t;
                do {
                    if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && fh(n, n.next, t, e)) return !0;
                    n = n.next
                } while (n !== t);
                return !1
            }

            function yh(t, e) {
                return dh(t.prev, t, t.next) < 0 ? dh(t, e, t.next) >= 0 && dh(t, t.prev, e) >= 0 : dh(t, e, t.prev) < 0 || dh(t, t.next, e) < 0
            }

            function _h(t, e) {
                let n = t,
                    r = !1;
                const i = (t.x + e.x) / 2,
                    o = (t.y + e.y) / 2;
                do {
                    n.y > o !== n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next
                } while (n !== t);
                return r
            }

            function bh(t, e) {
                const n = new Mh(t.i, t.x, t.y),
                    r = new Mh(e.i, e.x, e.y),
                    i = t.next,
                    o = e.prev;
                return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r
            }

            function xh(t, e, n, r) {
                const i = new Mh(t, e, n);
                return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
            }

            function wh(t) {
                t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
            }

            function Mh(t, e, n) {
                this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }

            function Th(t, e, n, r) {
                let i = 0;
                for (let o = e, a = n - r; o < n; o += r) i += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o;
                return i
            }
            const Sh = {
                area: function(t) {
                    const e = t.length;
                    let n = 0;
                    for (let r = e - 1, i = 0; i < e; r = i++) n += t[r].x * t[i].y - t[i].x * t[r].y;
                    return .5 * n
                },
                isClockWise: function(t) {
                    return Sh.area(t) < 0
                },
                triangulateShape: function(t, e) {
                    const n = [],
                        r = [],
                        i = [];
                    Eh(t), Ah(n, t);
                    let o = t.length;
                    e.forEach(Eh);
                    for (let s = 0; s < e.length; s++) r.push(o), o += e[s].length, Ah(n, e[s]);
                    const a = qu.triangulate(n, r);
                    for (let s = 0; s < a.length; s += 3) i.push(a.slice(s, s + 3));
                    return i
                }
            };

            function Eh(t) {
                const e = t.length;
                e > 2 && t[e - 1].equals(t[0]) && t.pop()
            }

            function Ah(t, e) {
                for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
            }
            class Lh extends pi {
                constructor(t, e) {
                    super(), this.type = "ExtrudeBufferGeometry", this.parameters = {
                        shapes: t,
                        options: e
                    }, t = Array.isArray(t) ? t : [t];
                    const n = this,
                        r = [],
                        i = [];
                    for (let a = 0, s = t.length; a < s; a++) {
                        const e = t[a];
                        o(e)
                    }

                    function o(t) {
                        const o = [],
                            a = void 0 !== e.curveSegments ? e.curveSegments : 12,
                            s = void 0 !== e.steps ? e.steps : 1;
                        let c = void 0 !== e.depth ? e.depth : 100,
                            l = void 0 === e.bevelEnabled || e.bevelEnabled,
                            u = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                            h = void 0 !== e.bevelSize ? e.bevelSize : u - 2,
                            d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                            p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                        const f = e.extrudePath,
                            m = void 0 !== e.UVGenerator ? e.UVGenerator : Rh;
                        void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = e.amount);
                        let g, v, y, _, b, x = !1;
                        f && (g = f.getSpacedPoints(s), x = !0, l = !1, v = f.computeFrenetFrames(s, !1), y = new bn, _ = new bn, b = new bn), l || (p = 0, u = 0, h = 0, d = 0);
                        const w = t.extractPoints(a);
                        let M = w.shape;
                        const T = w.holes,
                            S = !Sh.isClockWise(M);
                        if (S) {
                            M = M.reverse();
                            for (let t = 0, e = T.length; t < e; t++) {
                                const e = T[t];
                                Sh.isClockWise(e) && (T[t] = e.reverse())
                            }
                        }
                        const E = Sh.triangulateShape(M, T),
                            A = M;
                        for (let e = 0, n = T.length; e < n; e++) {
                            const t = T[e];
                            M = M.concat(t)
                        }

                        function L(t, e, n) {
                            return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
                        }
                        const R = M.length,
                            C = E.length;

                        function O(t, e, n) {
                            let r, i, o;
                            const a = t.x - e.x,
                                s = t.y - e.y,
                                c = n.x - t.x,
                                l = n.y - t.y,
                                u = a * a + s * s,
                                h = a * l - s * c;
                            if (Math.abs(h) > Number.EPSILON) {
                                const h = Math.sqrt(u),
                                    d = Math.sqrt(c * c + l * l),
                                    p = e.x - s / h,
                                    f = e.y + a / h,
                                    m = n.x - l / d,
                                    g = n.y + c / d,
                                    v = ((m - p) * l - (g - f) * c) / (a * l - s * c);
                                r = p + a * v - t.x, i = f + s * v - t.y;
                                const y = r * r + i * i;
                                if (y <= 2) return new un(r, i);
                                o = Math.sqrt(y / 2)
                            } else {
                                let t = !1;
                                a > Number.EPSILON ? c > Number.EPSILON && (t = !0) : a < -Number.EPSILON ? c < -Number.EPSILON && (t = !0) : Math.sign(s) === Math.sign(l) && (t = !0), t ? (r = -s, i = a, o = Math.sqrt(u)) : (r = a, i = s, o = Math.sqrt(u / 2))
                            }
                            return new un(r / o, i / o)
                        }
                        const P = [];
                        for (let e = 0, n = A.length, r = n - 1, i = e + 1; e < n; e++, r++, i++) r === n && (r = 0), i === n && (i = 0), P[e] = O(A[e], A[r], A[i]);
                        const I = [];
                        let N, D = P.concat();
                        for (let e = 0, n = T.length; e < n; e++) {
                            const t = T[e];
                            N = [];
                            for (let e = 0, n = t.length, r = n - 1, i = e + 1; e < n; e++, r++, i++) r === n && (r = 0), i === n && (i = 0), N[e] = O(t[e], t[r], t[i]);
                            I.push(N), D = D.concat(N)
                        }
                        for (let e = 0; e < p; e++) {
                            const t = e / p,
                                n = u * Math.cos(t * Math.PI / 2),
                                r = h * Math.sin(t * Math.PI / 2) + d;
                            for (let e = 0, i = A.length; e < i; e++) {
                                const t = L(A[e], P[e], r);
                                H(t.x, t.y, -n)
                            }
                            for (let e = 0, i = T.length; e < i; e++) {
                                const t = T[e];
                                N = I[e];
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = L(t[e], N[e], r);
                                    H(i.x, i.y, -n)
                                }
                            }
                        }
                        const k = h + d;
                        for (let e = 0; e < R; e++) {
                            const t = l ? L(M[e], D[e], k) : M[e];
                            x ? (_.copy(v.normals[0]).multiplyScalar(t.x), y.copy(v.binormals[0]).multiplyScalar(t.y), b.copy(g[0]).add(_).add(y), H(b.x, b.y, b.z)) : H(t.x, t.y, 0)
                        }
                        for (let e = 1; e <= s; e++)
                            for (let t = 0; t < R; t++) {
                                const n = l ? L(M[t], D[t], k) : M[t];
                                x ? (_.copy(v.normals[e]).multiplyScalar(n.x), y.copy(v.binormals[e]).multiplyScalar(n.y), b.copy(g[e]).add(_).add(y), H(b.x, b.y, b.z)) : H(n.x, n.y, c / s * e)
                            }
                        for (let e = p - 1; e >= 0; e--) {
                            const t = e / p,
                                n = u * Math.cos(t * Math.PI / 2),
                                r = h * Math.sin(t * Math.PI / 2) + d;
                            for (let e = 0, i = A.length; e < i; e++) {
                                const t = L(A[e], P[e], r);
                                H(t.x, t.y, c + n)
                            }
                            for (let e = 0, i = T.length; e < i; e++) {
                                const t = T[e];
                                N = I[e];
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = L(t[e], N[e], r);
                                    x ? H(i.x, i.y + g[s - 1].y, g[s - 1].x + n) : H(i.x, i.y, c + n)
                                }
                            }
                        }

                        function F() {
                            const t = r.length / 3;
                            if (l) {
                                let t = 0,
                                    e = R * t;
                                for (let n = 0; n < C; n++) {
                                    const t = E[n];
                                    z(t[2] + e, t[1] + e, t[0] + e)
                                }
                                t = s + 2 * p, e = R * t;
                                for (let n = 0; n < C; n++) {
                                    const t = E[n];
                                    z(t[0] + e, t[1] + e, t[2] + e)
                                }
                            } else {
                                for (let t = 0; t < C; t++) {
                                    const e = E[t];
                                    z(e[2], e[1], e[0])
                                }
                                for (let t = 0; t < C; t++) {
                                    const e = E[t];
                                    z(e[0] + R * s, e[1] + R * s, e[2] + R * s)
                                }
                            }
                            n.addGroup(t, r.length / 3 - t, 0)
                        }

                        function B() {
                            const t = r.length / 3;
                            let e = 0;
                            U(A, e), e += A.length;
                            for (let n = 0, r = T.length; n < r; n++) {
                                const t = T[n];
                                U(t, e), e += t.length
                            }
                            n.addGroup(t, r.length / 3 - t, 1)
                        }

                        function U(t, e) {
                            let n = t.length;
                            while (--n >= 0) {
                                const r = n;
                                let i = n - 1;
                                i < 0 && (i = t.length - 1);
                                for (let t = 0, n = s + 2 * p; t < n; t++) {
                                    const n = R * t,
                                        o = R * (t + 1),
                                        a = e + r + n,
                                        s = e + i + n,
                                        c = e + i + o,
                                        l = e + r + o;
                                    j(a, s, c, l)
                                }
                            }
                        }

                        function H(t, e, n) {
                            o.push(t), o.push(e), o.push(n)
                        }

                        function z(t, e, i) {
                            G(t), G(e), G(i);
                            const o = r.length / 3,
                                a = m.generateTopUV(n, r, o - 3, o - 2, o - 1);
                            V(a[0]), V(a[1]), V(a[2])
                        }

                        function j(t, e, i, o) {
                            G(t), G(e), G(o), G(e), G(i), G(o);
                            const a = r.length / 3,
                                s = m.generateSideWallUV(n, r, a - 6, a - 3, a - 2, a - 1);
                            V(s[0]), V(s[1]), V(s[3]), V(s[1]), V(s[2]), V(s[3])
                        }

                        function G(t) {
                            r.push(o[3 * t + 0]), r.push(o[3 * t + 1]), r.push(o[3 * t + 2])
                        }

                        function V(t) {
                            i.push(t.x), i.push(t.y)
                        }
                        F(), B()
                    }
                    this.setAttribute("position", new ni(r, 3)), this.setAttribute("uv", new ni(i, 2)), this.computeVertexNormals()
                }
                toJSON() {
                    const t = pi.prototype.toJSON.call(this),
                        e = this.parameters.shapes,
                        n = this.parameters.options;
                    return Ch(e, n, t)
                }
            }
            const Rh = {
                generateTopUV: function(t, e, n, r, i) {
                    const o = e[3 * n],
                        a = e[3 * n + 1],
                        s = e[3 * r],
                        c = e[3 * r + 1],
                        l = e[3 * i],
                        u = e[3 * i + 1];
                    return [new un(o, a), new un(s, c), new un(l, u)]
                },
                generateSideWallUV: function(t, e, n, r, i, o) {
                    const a = e[3 * n],
                        s = e[3 * n + 1],
                        c = e[3 * n + 2],
                        l = e[3 * r],
                        u = e[3 * r + 1],
                        h = e[3 * r + 2],
                        d = e[3 * i],
                        p = e[3 * i + 1],
                        f = e[3 * i + 2],
                        m = e[3 * o],
                        g = e[3 * o + 1],
                        v = e[3 * o + 2];
                    return Math.abs(s - u) < .01 ? [new un(a, 1 - c), new un(l, 1 - h), new un(d, 1 - f), new un(m, 1 - v)] : [new un(s, 1 - c), new un(u, 1 - h), new un(p, 1 - f), new un(g, 1 - v)]
                }
            };

            function Ch(t, e, n) {
                if (n.shapes = [], Array.isArray(t))
                    for (let r = 0, i = t.length; r < i; r++) {
                        const e = t[r];
                        n.shapes.push(e.uuid)
                    } else n.shapes.push(t.uuid);
                return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
            }
            class Oh extends Xu {
                constructor(t, e) {
                    super(), this.type = "ExtrudeGeometry", this.parameters = {
                        shapes: t,
                        options: e
                    }, this.fromBufferGeometry(new Lh(t, e)), this.mergeVertices()
                }
                toJSON() {
                    const t = super.toJSON(),
                        e = this.parameters.shapes,
                        n = this.parameters.options;
                    return Ph(e, n, t)
                }
            }

            function Ph(t, e, n) {
                if (n.shapes = [], Array.isArray(t))
                    for (let r = 0, i = t.length; r < i; r++) {
                        const e = t[r];
                        n.shapes.push(e.uuid)
                    } else n.shapes.push(t.uuid);
                return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
            }

            function Ih(t, e, n) {
                pi.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: n
                };
                const r = [],
                    i = [],
                    o = [],
                    a = [],
                    s = 1e-5,
                    c = new bn,
                    l = new bn,
                    u = new bn,
                    h = new bn,
                    d = new bn;
                t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                const p = e + 1;
                for (let f = 0; f <= n; f++) {
                    const r = f / n;
                    for (let n = 0; n <= e; n++) {
                        const p = n / e;
                        t(p, r, l), i.push(l.x, l.y, l.z), p - s >= 0 ? (t(p - s, r, u), h.subVectors(l, u)) : (t(p + s, r, u), h.subVectors(u, l)), r - s >= 0 ? (t(p, r - s, u), d.subVectors(l, u)) : (t(p, r + s, u), d.subVectors(u, l)), c.crossVectors(h, d).normalize(), o.push(c.x, c.y, c.z), a.push(p, r)
                    }
                }
                for (let f = 0; f < n; f++)
                    for (let t = 0; t < e; t++) {
                        const e = f * p + t,
                            n = f * p + t + 1,
                            i = (f + 1) * p + t + 1,
                            o = (f + 1) * p + t;
                        r.push(e, n, o), r.push(n, i, o)
                    }
                this.setIndex(r), this.setAttribute("position", new ni(i, 3)), this.setAttribute("normal", new ni(o, 3)), this.setAttribute("uv", new ni(a, 2))
            }

            function Nh(t, e, n) {
                Xu.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: n
                }, this.fromBufferGeometry(new Ih(t, e, n)), this.mergeVertices()
            }
            Ih.prototype = Object.create(pi.prototype), Ih.prototype.constructor = Ih, Nh.prototype = Object.create(Xu.prototype), Nh.prototype.constructor = Nh;
            class Dh extends Xu {
                constructor(t, e, n, r) {
                    super(), this.type = "PlaneGeometry", this.parameters = {
                        width: t,
                        height: e,
                        widthSegments: n,
                        heightSegments: r
                    }, this.fromBufferGeometry(new to(t, e, n, r)), this.mergeVertices()
                }
            }
            class kh extends pi {
                constructor(t, e) {
                    super(), this.type = "ShapeBufferGeometry", this.parameters = {
                        shapes: t,
                        curveSegments: e
                    }, e = e || 12;
                    const n = [],
                        r = [],
                        i = [],
                        o = [];
                    let a = 0,
                        s = 0;
                    if (!1 === Array.isArray(t)) c(t);
                    else
                        for (let l = 0; l < t.length; l++) c(t[l]), this.addGroup(a, s, l), a += s, s = 0;

                    function c(t) {
                        const a = r.length / 3,
                            c = t.extractPoints(e);
                        let l = c.shape;
                        const u = c.holes;
                        !1 === Sh.isClockWise(l) && (l = l.reverse());
                        for (let e = 0, n = u.length; e < n; e++) {
                            const t = u[e];
                            !0 === Sh.isClockWise(t) && (u[e] = t.reverse())
                        }
                        const h = Sh.triangulateShape(l, u);
                        for (let e = 0, n = u.length; e < n; e++) {
                            const t = u[e];
                            l = l.concat(t)
                        }
                        for (let e = 0, n = l.length; e < n; e++) {
                            const t = l[e];
                            r.push(t.x, t.y, 0), i.push(0, 0, 1), o.push(t.x, t.y)
                        }
                        for (let e = 0, r = h.length; e < r; e++) {
                            const t = h[e],
                                r = t[0] + a,
                                i = t[1] + a,
                                o = t[2] + a;
                            n.push(r, i, o), s += 3
                        }
                    }
                    this.setIndex(n), this.setAttribute("position", new ni(r, 3)), this.setAttribute("normal", new ni(i, 3)), this.setAttribute("uv", new ni(o, 2))
                }
                toJSON() {
                    const t = pi.prototype.toJSON.call(this),
                        e = this.parameters.shapes;
                    return Fh(e, t)
                }
            }

            function Fh(t, e) {
                if (e.shapes = [], Array.isArray(t))
                    for (let n = 0, r = t.length; n < r; n++) {
                        const r = t[n];
                        e.shapes.push(r.uuid)
                    } else e.shapes.push(t.uuid);
                return e
            }
            class Bh extends Xu {
                constructor(t, e) {
                    super(), this.type = "ShapeGeometry", "object" === typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
                        shapes: t,
                        curveSegments: e
                    }, this.fromBufferGeometry(new kh(t, e)), this.mergeVertices()
                }
                toJSON() {
                    const t = Xu.prototype.toJSON.call(this),
                        e = this.parameters.shapes;
                    return Uh(e, t)
                }
            }

            function Uh(t, e) {
                if (e.shapes = [], Array.isArray(t))
                    for (let n = 0, r = t.length; n < r; n++) {
                        const r = t[n];
                        e.shapes.push(r.uuid)
                    } else e.shapes.push(t.uuid);
                return e
            }
            class Hh extends pi {
                constructor(t, e, n, r, i, o, a) {
                    super(), this.type = "SphereBufferGeometry", this.parameters = {
                        radius: t,
                        widthSegments: e,
                        heightSegments: n,
                        phiStart: r,
                        phiLength: i,
                        thetaStart: o,
                        thetaLength: a
                    }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : Math.PI;
                    const s = Math.min(o + a, Math.PI);
                    let c = 0;
                    const l = [],
                        u = new bn,
                        h = new bn,
                        d = [],
                        p = [],
                        f = [],
                        m = [];
                    for (let g = 0; g <= n; g++) {
                        const d = [],
                            v = g / n;
                        let y = 0;
                        0 == g && 0 == o ? y = .5 / e : g == n && s == Math.PI && (y = -.5 / e);
                        for (let n = 0; n <= e; n++) {
                            const s = n / e;
                            u.x = -t * Math.cos(r + s * i) * Math.sin(o + v * a), u.y = t * Math.cos(o + v * a), u.z = t * Math.sin(r + s * i) * Math.sin(o + v * a), p.push(u.x, u.y, u.z), h.copy(u).normalize(), f.push(h.x, h.y, h.z), m.push(s + y, 1 - v), d.push(c++)
                        }
                        l.push(d)
                    }
                    for (let g = 0; g < n; g++)
                        for (let t = 0; t < e; t++) {
                            const e = l[g][t + 1],
                                r = l[g][t],
                                i = l[g + 1][t],
                                a = l[g + 1][t + 1];
                            (0 !== g || o > 0) && d.push(e, r, a), (g !== n - 1 || s < Math.PI) && d.push(r, i, a)
                        }
                    this.setIndex(d), this.setAttribute("position", new ni(p, 3)), this.setAttribute("normal", new ni(f, 3)), this.setAttribute("uv", new ni(m, 2))
                }
            }

            function zh(t) {
                Vr.call(this), this.type = "ShadowMaterial", this.color = new zr(0), this.transparent = !0, this.setValues(t)
            }

            function jh(t) {
                Hi.call(this, t), this.type = "RawShaderMaterial"
            }

            function Gh(t) {
                Vr.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new zr(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new zr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ke, this.normalScale = new un(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t)
            }

            function Vh(t) {
                Gh.call(this), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new un(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", {
                    get: function() {
                        return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
                    },
                    set: function(t) {
                        this.reflectivity = ln.clamp(2.5 * (t - 1) / (t + 1), 0, 1)
                    }
                }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t)
            }

            function Wh(t) {
                Vr.call(this), this.type = "MeshPhongMaterial", this.color = new zr(16777215), this.specular = new zr(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new zr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ke, this.normalScale = new un(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = X, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Xh(t) {
                Vr.call(this), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.color = new zr(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new zr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ke, this.normalScale = new un(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function qh(t) {
                Vr.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ke, this.normalScale = new un(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Yh(t) {
                Vr.call(this), this.type = "MeshLambertMaterial", this.color = new zr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new zr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = X, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function $h(t) {
                Vr.call(this), this.defines = {
                    MATCAP: ""
                }, this.type = "MeshMatcapMaterial", this.color = new zr(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ke, this.normalScale = new un(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Zh(t) {
                bu.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
            }
            zh.prototype = Object.create(Vr.prototype), zh.prototype.constructor = zh, zh.prototype.isShadowMaterial = !0, zh.prototype.copy = function(t) {
                return Vr.prototype.copy.call(this, t), this.color.copy(t.color), this
            }, jh.prototype = Object.create(Hi.prototype), jh.prototype.constructor = jh, jh.prototype.isRawShaderMaterial = !0, Gh.prototype = Object.create(Vr.prototype), Gh.prototype.constructor = Gh, Gh.prototype.isMeshStandardMaterial = !0, Gh.prototype.copy = function(t) {
                return Vr.prototype.copy.call(this, t), this.defines = {
                    STANDARD: ""
                }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this
            }, Vh.prototype = Object.create(Gh.prototype), Vh.prototype.constructor = Vh, Vh.prototype.isMeshPhysicalMaterial = !0, Vh.prototype.copy = function(t) {
                return Gh.prototype.copy.call(this, t), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new zr).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this
            }, Wh.prototype = Object.create(Vr.prototype), Wh.prototype.constructor = Wh, Wh.prototype.isMeshPhongMaterial = !0, Wh.prototype.copy = function(t) {
                return Vr.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Xh.prototype = Object.create(Vr.prototype), Xh.prototype.constructor = Xh, Xh.prototype.isMeshToonMaterial = !0, Xh.prototype.copy = function(t) {
                return Vr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, qh.prototype = Object.create(Vr.prototype), qh.prototype.constructor = qh, qh.prototype.isMeshNormalMaterial = !0, qh.prototype.copy = function(t) {
                return Vr.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Yh.prototype = Object.create(Vr.prototype), Yh.prototype.constructor = Yh, Yh.prototype.isMeshLambertMaterial = !0, Yh.prototype.copy = function(t) {
                return Vr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, $h.prototype = Object.create(Vr.prototype), $h.prototype.constructor = $h, $h.prototype.isMeshMatcapMaterial = !0, $h.prototype.copy = function(t) {
                return Vr.prototype.copy.call(this, t), this.defines = {
                    MATCAP: ""
                }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Zh.prototype = Object.create(bu.prototype), Zh.prototype.constructor = Zh, Zh.prototype.isLineDashedMaterial = !0, Zh.prototype.copy = function(t) {
                return bu.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
            };
            var Jh = Object.freeze({
                __proto__: null,
                ShadowMaterial: zh,
                SpriteMaterial: Wl,
                RawShaderMaterial: jh,
                ShaderMaterial: Hi,
                PointsMaterial: Ou,
                MeshPhysicalMaterial: Vh,
                MeshStandardMaterial: Gh,
                MeshPhongMaterial: Wh,
                MeshToonMaterial: Xh,
                MeshNormalMaterial: qh,
                MeshLambertMaterial: Yh,
                MeshDepthMaterial: El,
                MeshDistanceMaterial: Al,
                MeshBasicMaterial: Wr,
                MeshMatcapMaterial: $h,
                LineDashedMaterial: Zh,
                LineBasicMaterial: bu,
                Material: Vr
            });
            const Kh = {
                arraySlice: function(t, e, n) {
                    return Kh.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
                },
                convertArray: function(t, e, n) {
                    return !t || !n && t.constructor === e ? t : "number" === typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                },
                isTypedArray: function(t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView)
                },
                getKeyframeOrder: function(t) {
                    function e(e, n) {
                        return t[e] - t[n]
                    }
                    const n = t.length,
                        r = new Array(n);
                    for (let i = 0; i !== n; ++i) r[i] = i;
                    return r.sort(e), r
                },
                sortedArray: function(t, e, n) {
                    const r = t.length,
                        i = new t.constructor(r);
                    for (let o = 0, a = 0; a !== r; ++o) {
                        const r = n[o] * e;
                        for (let n = 0; n !== e; ++n) i[a++] = t[r + n]
                    }
                    return i
                },
                flattenJSON: function(t, e, n, r) {
                    let i = 1,
                        o = t[0];
                    while (void 0 !== o && void 0 === o[r]) o = t[i++];
                    if (void 0 === o) return;
                    let a = o[r];
                    if (void 0 !== a)
                        if (Array.isArray(a))
                            do {
                                a = o[r], void 0 !== a && (e.push(o.time), n.push.apply(n, a)), o = t[i++]
                            } while (void 0 !== o);
                        else if (void 0 !== a.toArray)
                        do {
                            a = o[r], void 0 !== a && (e.push(o.time), a.toArray(n, n.length)), o = t[i++]
                        } while (void 0 !== o);
                    else
                        do {
                            a = o[r], void 0 !== a && (e.push(o.time), n.push(a)), o = t[i++]
                        } while (void 0 !== o)
                },
                subclip: function(t, e, n, r, i) {
                    i = i || 30;
                    const o = t.clone();
                    o.name = e;
                    const a = [];
                    for (let c = 0; c < o.tracks.length; ++c) {
                        const t = o.tracks[c],
                            e = t.getValueSize(),
                            s = [],
                            l = [];
                        for (let o = 0; o < t.times.length; ++o) {
                            const a = t.times[o] * i;
                            if (!(a < n || a >= r)) {
                                s.push(t.times[o]);
                                for (let n = 0; n < e; ++n) l.push(t.values[o * e + n])
                            }
                        }
                        0 !== s.length && (t.times = Kh.convertArray(s, t.times.constructor), t.values = Kh.convertArray(l, t.values.constructor), a.push(t))
                    }
                    o.tracks = a;
                    let s = 1 / 0;
                    for (let c = 0; c < o.tracks.length; ++c) s > o.tracks[c].times[0] && (s = o.tracks[c].times[0]);
                    for (let c = 0; c < o.tracks.length; ++c) o.tracks[c].shift(-1 * s);
                    return o.resetDuration(), o
                },
                makeClipAdditive: function(t, e, n, r) {
                    void 0 === e && (e = 0), void 0 === n && (n = t), (void 0 === r || r <= 0) && (r = 30);
                    const i = n.tracks.length,
                        o = e / r;
                    for (let a = 0; a < i; ++a) {
                        const e = n.tracks[a],
                            r = e.ValueTypeName;
                        if ("bool" === r || "string" === r) continue;
                        const i = t.tracks.find((function(t) {
                            return t.name === e.name && t.ValueTypeName === r
                        }));
                        if (void 0 === i) continue;
                        let s = 0;
                        const c = e.getValueSize();
                        e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s = c / 3);
                        let l = 0;
                        const u = i.getValueSize();
                        i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (l = u / 3);
                        const h = e.times.length - 1;
                        let d;
                        if (o <= e.times[0]) {
                            const t = s,
                                n = c - s;
                            d = Kh.arraySlice(e.values, t, n)
                        } else if (o >= e.times[h]) {
                            const t = h * c + s,
                                n = t + c - s;
                            d = Kh.arraySlice(e.values, t, n)
                        } else {
                            const t = e.createInterpolant(),
                                n = s,
                                r = c - s;
                            t.evaluate(o), d = Kh.arraySlice(t.resultBuffer, n, r)
                        }
                        if ("quaternion" === r) {
                            const t = (new _n).fromArray(d).normalize().conjugate();
                            t.toArray(d)
                        }
                        const p = i.times.length;
                        for (let t = 0; t < p; ++t) {
                            const e = t * u + l;
                            if ("quaternion" === r) _n.multiplyQuaternionsFlat(i.values, e, d, 0, i.values, e);
                            else {
                                const t = u - 2 * l;
                                for (let n = 0; n < t; ++n) i.values[e + n] -= d[n]
                            }
                        }
                    }
                    return t.blendMode = Be, t
                }
            };

            function Qh(t, e, n, r) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n
            }

            function td(t, e, n, r) {
                Qh.call(this, t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }

            function ed(t, e, n, r) {
                Qh.call(this, t, e, n, r)
            }

            function nd(t, e, n, r) {
                Qh.call(this, t, e, n, r)
            }

            function rd(t, e, n, r) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = Kh.convertArray(e, this.TimeBufferType), this.values = Kh.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
            }

            function id(t, e, n) {
                rd.call(this, t, e, n)
            }

            function od(t, e, n, r) {
                rd.call(this, t, e, n, r)
            }

            function ad(t, e, n, r) {
                rd.call(this, t, e, n, r)
            }

            function sd(t, e, n, r) {
                Qh.call(this, t, e, n, r)
            }

            function cd(t, e, n, r) {
                rd.call(this, t, e, n, r)
            }

            function ld(t, e, n, r) {
                rd.call(this, t, e, n, r)
            }

            function ud(t, e, n, r) {
                rd.call(this, t, e, n, r)
            }

            function hd(t, e, n, r) {
                this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.blendMode = void 0 !== r ? r : Fe, this.uuid = ln.generateUUID(), this.duration < 0 && this.resetDuration()
            }

            function dd(t) {
                switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return ad;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return ud;
                    case "color":
                        return od;
                    case "quaternion":
                        return cd;
                    case "bool":
                    case "boolean":
                        return id;
                    case "string":
                        return ld
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }

            function pd(t) {
                if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                const e = dd(t.type);
                if (void 0 === t.times) {
                    const e = [],
                        n = [];
                    Kh.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
            }
            Object.assign(Qh.prototype, {
                evaluate: function(t) {
                    const e = this.parameterPositions;
                    let n = this._cachedIndex,
                        r = e[n],
                        i = e[n - 1];
                    t: {
                        e: {
                            let o;n: {
                                r: if (!(t < r)) {
                                    for (let o = n + 2;;) {
                                        if (void 0 === r) {
                                            if (t < i) break r;
                                            return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, i)
                                        }
                                        if (n === o) break;
                                        if (i = r, r = e[++n], t < r) break e
                                    }
                                    o = e.length;
                                    break n
                                }if (t >= i) break t; {
                                    const a = e[1];
                                    t < a && (n = 2, i = a);
                                    for (let o = n - 2;;) {
                                        if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                                        if (n === o) break;
                                        if (r = i, i = e[--n - 1], t >= i) break e
                                    }
                                    o = n, n = 0
                                }
                            }
                            while (n < o) {
                                const r = n + o >>> 1;
                                t < e[r] ? o = r : n = r + 1
                            }
                            if (r = e[n], i = e[n - 1], void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                            if (void 0 === r) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, i, t)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, i, r)
                    }
                    return this.interpolate_(n, i, t, r)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function() {
                    return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function(t) {
                    const e = this.resultBuffer,
                        n = this.sampleValues,
                        r = this.valueSize,
                        i = t * r;
                    for (let o = 0; o !== r; ++o) e[o] = n[i + o];
                    return e
                },
                interpolate_: function() {
                    throw new Error("call to abstract method")
                },
                intervalChanged_: function() {}
            }), Object.assign(Qh.prototype, {
                beforeStart_: Qh.prototype.copySampleValue_,
                afterEnd_: Qh.prototype.copySampleValue_
            }), td.prototype = Object.assign(Object.create(Qh.prototype), {
                constructor: td,
                DefaultSettings_: {
                    endingStart: Ne,
                    endingEnd: Ne
                },
                intervalChanged_: function(t, e, n) {
                    const r = this.parameterPositions;
                    let i = t - 2,
                        o = t + 1,
                        a = r[i],
                        s = r[o];
                    if (void 0 === a) switch (this.getSettings_().endingStart) {
                        case De:
                            i = t, a = 2 * e - n;
                            break;
                        case ke:
                            i = r.length - 2, a = e + r[i] - r[i + 1];
                            break;
                        default:
                            i = t, a = n
                    }
                    if (void 0 === s) switch (this.getSettings_().endingEnd) {
                        case De:
                            o = t, s = 2 * n - e;
                            break;
                        case ke:
                            o = 1, s = n + r[1] - r[0];
                            break;
                        default:
                            o = t - 1, s = e
                    }
                    const c = .5 * (n - e),
                        l = this.valueSize;
                    this._weightPrev = c / (e - a), this._weightNext = c / (s - n), this._offsetPrev = i * l, this._offsetNext = o * l
                },
                interpolate_: function(t, e, n, r) {
                    const i = this.resultBuffer,
                        o = this.sampleValues,
                        a = this.valueSize,
                        s = t * a,
                        c = s - a,
                        l = this._offsetPrev,
                        u = this._offsetNext,
                        h = this._weightPrev,
                        d = this._weightNext,
                        p = (n - e) / (r - e),
                        f = p * p,
                        m = f * p,
                        g = -h * m + 2 * h * f - h * p,
                        v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1,
                        y = (-1 - d) * m + (1.5 + d) * f + .5 * p,
                        _ = d * m - d * f;
                    for (let b = 0; b !== a; ++b) i[b] = g * o[l + b] + v * o[c + b] + y * o[s + b] + _ * o[u + b];
                    return i
                }
            }), ed.prototype = Object.assign(Object.create(Qh.prototype), {
                constructor: ed,
                interpolate_: function(t, e, n, r) {
                    const i = this.resultBuffer,
                        o = this.sampleValues,
                        a = this.valueSize,
                        s = t * a,
                        c = s - a,
                        l = (n - e) / (r - e),
                        u = 1 - l;
                    for (let h = 0; h !== a; ++h) i[h] = o[c + h] * u + o[s + h] * l;
                    return i
                }
            }), nd.prototype = Object.assign(Object.create(Qh.prototype), {
                constructor: nd,
                interpolate_: function(t) {
                    return this.copySampleValue_(t - 1)
                }
            }), Object.assign(rd, {
                toJSON: function(t) {
                    const e = t.constructor;
                    let n;
                    if (void 0 !== e.toJSON) n = e.toJSON(t);
                    else {
                        n = {
                            name: t.name,
                            times: Kh.convertArray(t.times, Array),
                            values: Kh.convertArray(t.values, Array)
                        };
                        const e = t.getInterpolation();
                        e !== t.DefaultInterpolation && (n.interpolation = e)
                    }
                    return n.type = t.ValueTypeName, n
                }
            }), Object.assign(rd.prototype, {
                constructor: rd,
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: Pe,
                InterpolantFactoryMethodDiscrete: function(t) {
                    return new nd(this.times, this.values, this.getValueSize(), t)
                },
                InterpolantFactoryMethodLinear: function(t) {
                    return new ed(this.times, this.values, this.getValueSize(), t)
                },
                InterpolantFactoryMethodSmooth: function(t) {
                    return new td(this.times, this.values, this.getValueSize(), t)
                },
                setInterpolation: function(t) {
                    let e;
                    switch (t) {
                        case Oe:
                            e = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case Pe:
                            e = this.InterpolantFactoryMethodLinear;
                            break;
                        case Ie:
                            e = this.InterpolantFactoryMethodSmooth;
                            break
                    }
                    if (void 0 === e) {
                        const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (t === this.DefaultInterpolation) throw new Error(e);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return console.warn("THREE.KeyframeTrack:", e), this
                    }
                    return this.createInterpolant = e, this
                },
                getInterpolation: function() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return Oe;
                        case this.InterpolantFactoryMethodLinear:
                            return Pe;
                        case this.InterpolantFactoryMethodSmooth:
                            return Ie
                    }
                },
                getValueSize: function() {
                    return this.values.length / this.times.length
                },
                shift: function(t) {
                    if (0 !== t) {
                        const e = this.times;
                        for (let n = 0, r = e.length; n !== r; ++n) e[n] += t
                    }
                    return this
                },
                scale: function(t) {
                    if (1 !== t) {
                        const e = this.times;
                        for (let n = 0, r = e.length; n !== r; ++n) e[n] *= t
                    }
                    return this
                },
                trim: function(t, e) {
                    const n = this.times,
                        r = n.length;
                    let i = 0,
                        o = r - 1;
                    while (i !== r && n[i] < t) ++i;
                    while (-1 !== o && n[o] > e) --o;
                    if (++o, 0 !== i || o !== r) {
                        i >= o && (o = Math.max(o, 1), i = o - 1);
                        const t = this.getValueSize();
                        this.times = Kh.arraySlice(n, i, o), this.values = Kh.arraySlice(this.values, i * t, o * t)
                    }
                    return this
                },
                validate: function() {
                    let t = !0;
                    const e = this.getValueSize();
                    e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                    const n = this.times,
                        r = this.values,
                        i = n.length;
                    0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                    let o = null;
                    for (let a = 0; a !== i; a++) {
                        const e = n[a];
                        if ("number" === typeof e && isNaN(e)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, e), t = !1;
                            break
                        }
                        if (null !== o && o > e) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, a, e, o), t = !1;
                            break
                        }
                        o = e
                    }
                    if (void 0 !== r && Kh.isTypedArray(r))
                        for (let a = 0, s = r.length; a !== s; ++a) {
                            const e = r[a];
                            if (isNaN(e)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, e), t = !1;
                                break
                            }
                        }
                    return t
                },
                optimize: function() {
                    const t = Kh.arraySlice(this.times),
                        e = Kh.arraySlice(this.values),
                        n = this.getValueSize(),
                        r = this.getInterpolation() === Ie,
                        i = t.length - 1;
                    let o = 1;
                    for (let a = 1; a < i; ++a) {
                        let i = !1;
                        const s = t[a],
                            c = t[a + 1];
                        if (s !== c && (1 !== a || s !== s[0]))
                            if (r) i = !0;
                            else {
                                const t = a * n,
                                    r = t - n,
                                    o = t + n;
                                for (let a = 0; a !== n; ++a) {
                                    const n = e[t + a];
                                    if (n !== e[r + a] || n !== e[o + a]) {
                                        i = !0;
                                        break
                                    }
                                }
                            }
                        if (i) {
                            if (a !== o) {
                                t[o] = t[a];
                                const r = a * n,
                                    i = o * n;
                                for (let t = 0; t !== n; ++t) e[i + t] = e[r + t]
                            }++o
                        }
                    }
                    if (i > 0) {
                        t[o] = t[i];
                        for (let t = i * n, r = o * n, a = 0; a !== n; ++a) e[r + a] = e[t + a];
                        ++o
                    }
                    return o !== t.length ? (this.times = Kh.arraySlice(t, 0, o), this.values = Kh.arraySlice(e, 0, o * n)) : (this.times = t, this.values = e), this
                },
                clone: function() {
                    const t = Kh.arraySlice(this.times, 0),
                        e = Kh.arraySlice(this.values, 0),
                        n = this.constructor,
                        r = new n(this.name, t, e);
                    return r.createInterpolant = this.createInterpolant, r
                }
            }), id.prototype = Object.assign(Object.create(rd.prototype), {
                constructor: id,
                ValueTypeName: "bool",
                ValueBufferType: Array,
                DefaultInterpolation: Oe,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), od.prototype = Object.assign(Object.create(rd.prototype), {
                constructor: od,
                ValueTypeName: "color"
            }), ad.prototype = Object.assign(Object.create(rd.prototype), {
                constructor: ad,
                ValueTypeName: "number"
            }), sd.prototype = Object.assign(Object.create(Qh.prototype), {
                constructor: sd,
                interpolate_: function(t, e, n, r) {
                    const i = this.resultBuffer,
                        o = this.sampleValues,
                        a = this.valueSize,
                        s = (n - e) / (r - e);
                    let c = t * a;
                    for (let l = c + a; c !== l; c += 4) _n.slerpFlat(i, 0, o, c - a, o, c, s);
                    return i
                }
            }), cd.prototype = Object.assign(Object.create(rd.prototype), {
                constructor: cd,
                ValueTypeName: "quaternion",
                DefaultInterpolation: Pe,
                InterpolantFactoryMethodLinear: function(t) {
                    return new sd(this.times, this.values, this.getValueSize(), t)
                },
                InterpolantFactoryMethodSmooth: void 0
            }), ld.prototype = Object.assign(Object.create(rd.prototype), {
                constructor: ld,
                ValueTypeName: "string",
                ValueBufferType: Array,
                DefaultInterpolation: Oe,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), ud.prototype = Object.assign(Object.create(rd.prototype), {
                constructor: ud,
                ValueTypeName: "vector"
            }), Object.assign(hd, {
                parse: function(t) {
                    const e = [],
                        n = t.tracks,
                        r = 1 / (t.fps || 1);
                    for (let i = 0, o = n.length; i !== o; ++i) e.push(pd(n[i]).scale(r));
                    return new hd(t.name, t.duration, e, t.blendMode)
                },
                toJSON: function(t) {
                    const e = [],
                        n = t.tracks,
                        r = {
                            name: t.name,
                            duration: t.duration,
                            tracks: e,
                            uuid: t.uuid,
                            blendMode: t.blendMode
                        };
                    for (let i = 0, o = n.length; i !== o; ++i) e.push(rd.toJSON(n[i]));
                    return r
                },
                CreateFromMorphTargetSequence: function(t, e, n, r) {
                    const i = e.length,
                        o = [];
                    for (let a = 0; a < i; a++) {
                        let t = [],
                            s = [];
                        t.push((a + i - 1) % i, a, (a + 1) % i), s.push(0, 1, 0);
                        const c = Kh.getKeyframeOrder(t);
                        t = Kh.sortedArray(t, 1, c), s = Kh.sortedArray(s, 1, c), r || 0 !== t[0] || (t.push(i), s.push(s[0])), o.push(new ad(".morphTargetInfluences[" + e[a].name + "]", t, s).scale(1 / n))
                    }
                    return new hd(t, -1, o)
                },
                findByName: function(t, e) {
                    let n = t;
                    if (!Array.isArray(t)) {
                        const e = t;
                        n = e.geometry && e.geometry.animations || e.animations
                    }
                    for (let r = 0; r < n.length; r++)
                        if (n[r].name === e) return n[r];
                    return null
                },
                CreateClipsFromMorphTargetSequences: function(t, e, n) {
                    const r = {},
                        i = /^([\w-]*?)([\d]+)$/;
                    for (let a = 0, s = t.length; a < s; a++) {
                        const e = t[a],
                            n = e.name.match(i);
                        if (n && n.length > 1) {
                            const t = n[1];
                            let i = r[t];
                            i || (r[t] = i = []), i.push(e)
                        }
                    }
                    const o = [];
                    for (const a in r) o.push(hd.CreateFromMorphTargetSequence(a, r[a], e, n));
                    return o
                },
                parseAnimation: function(t, e) {
                    if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    const n = function(t, e, n, r, i) {
                            if (0 !== n.length) {
                                const o = [],
                                    a = [];
                                Kh.flattenJSON(n, o, a, r), 0 !== o.length && i.push(new t(e, o, a))
                            }
                        },
                        r = [],
                        i = t.name || "default",
                        o = t.fps || 30,
                        a = t.blendMode;
                    let s = t.length || -1;
                    const c = t.hierarchy || [];
                    for (let u = 0; u < c.length; u++) {
                        const t = c[u].keys;
                        if (t && 0 !== t.length)
                            if (t[0].morphTargets) {
                                const e = {};
                                let n;
                                for (n = 0; n < t.length; n++)
                                    if (t[n].morphTargets)
                                        for (let r = 0; r < t[n].morphTargets.length; r++) e[t[n].morphTargets[r]] = -1;
                                for (const i in e) {
                                    const e = [],
                                        o = [];
                                    for (let r = 0; r !== t[n].morphTargets.length; ++r) {
                                        const r = t[n];
                                        e.push(r.time), o.push(r.morphTarget === i ? 1 : 0)
                                    }
                                    r.push(new ad(".morphTargetInfluence[" + i + "]", e, o))
                                }
                                s = e.length * (o || 1)
                            } else {
                                const i = ".bones[" + e[u].name + "]";
                                n(ud, i + ".position", t, "pos", r), n(cd, i + ".quaternion", t, "rot", r), n(ud, i + ".scale", t, "scl", r)
                            }
                    }
                    if (0 === r.length) return null;
                    const l = new hd(i, s, r, a);
                    return l
                }
            }), Object.assign(hd.prototype, {
                resetDuration: function() {
                    const t = this.tracks;
                    let e = 0;
                    for (let n = 0, r = t.length; n !== r; ++n) {
                        const t = this.tracks[n];
                        e = Math.max(e, t.times[t.times.length - 1])
                    }
                    return this.duration = e, this
                },
                trim: function() {
                    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                    return this
                },
                validate: function() {
                    let t = !0;
                    for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                    return t
                },
                optimize: function() {
                    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                    return this
                },
                clone: function() {
                    const t = [];
                    for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                    return new hd(this.name, this.duration, t, this.blendMode)
                }
            });
            const fd = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function(t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                },
                clear: function() {
                    this.files = {}
                }
            };

            function md(t, e, n) {
                const r = this;
                let i = !1,
                    o = 0,
                    a = 0,
                    s = void 0;
                const c = [];
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
                    a++, !1 === i && void 0 !== r.onStart && r.onStart(t, o, a), i = !0
                }, this.itemEnd = function(t) {
                    o++, void 0 !== r.onProgress && r.onProgress(t, o, a), o === a && (i = !1, void 0 !== r.onLoad && r.onLoad())
                }, this.itemError = function(t) {
                    void 0 !== r.onError && r.onError(t)
                }, this.resolveURL = function(t) {
                    return s ? s(t) : t
                }, this.setURLModifier = function(t) {
                    return s = t, this
                }, this.addHandler = function(t, e) {
                    return c.push(t, e), this
                }, this.removeHandler = function(t) {
                    const e = c.indexOf(t);
                    return -1 !== e && c.splice(e, 2), this
                }, this.getHandler = function(t) {
                    for (let e = 0, n = c.length; e < n; e += 2) {
                        const n = c[e],
                            r = c[e + 1];
                        if (n.global && (n.lastIndex = 0), n.test(t)) return r
                    }
                    return null
                }
            }
            const gd = new md;

            function vd(t) {
                this.manager = void 0 !== t ? t : gd, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
            }
            Object.assign(vd.prototype, {
                load: function() {},
                loadAsync: function(t, e) {
                    const n = this;
                    return new Promise((function(r, i) {
                        n.load(t, r, e, i)
                    }))
                },
                parse: function() {},
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setWithCredentials: function(t) {
                    return this.withCredentials = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResourcePath: function(t) {
                    return this.resourcePath = t, this
                },
                setRequestHeader: function(t) {
                    return this.requestHeader = t, this
                }
            });
            const yd = {};

            function _d(t) {
                vd.call(this, t)
            }

            function bd(t) {
                vd.call(this, t)
            }

            function xd(t) {
                vd.call(this, t)
            }

            function wd(t) {
                vd.call(this, t)
            }

            function Md(t) {
                vd.call(this, t)
            }

            function Td(t) {
                vd.call(this, t)
            }

            function Sd(t) {
                vd.call(this, t)
            }

            function Ed() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }

            function Ad(t, e, n, r, i, o, a, s) {
                Ed.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = r || 1, this.aStartAngle = i || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
            }

            function Ld(t, e, n, r, i, o) {
                Ad.call(this, t, e, n, n, r, i, o), this.type = "ArcCurve"
            }

            function Rd() {
                let t = 0,
                    e = 0,
                    n = 0,
                    r = 0;

                function i(i, o, a, s) {
                    t = i, e = a, n = -3 * i + 3 * o - 2 * a - s, r = 2 * i - 2 * o + a + s
                }
                return {
                    initCatmullRom: function(t, e, n, r, o) {
                        i(e, n, o * (n - t), o * (r - e))
                    },
                    initNonuniformCatmullRom: function(t, e, n, r, o, a, s) {
                        let c = (e - t) / o - (n - t) / (o + a) + (n - e) / a,
                            l = (n - e) / a - (r - e) / (a + s) + (r - n) / s;
                        c *= a, l *= a, i(e, n, c, l)
                    },
                    calc: function(i) {
                        const o = i * i,
                            a = o * i;
                        return t + e * i + n * o + r * a
                    }
                }
            }
            _d.prototype = Object.assign(Object.create(vd.prototype), {
                constructor: _d,
                load: function(t, e, n, r) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    const i = this,
                        o = fd.get(t);
                    if (void 0 !== o) return i.manager.itemStart(t), setTimeout((function() {
                        e && e(o), i.manager.itemEnd(t)
                    }), 0), o;
                    if (void 0 !== yd[t]) return void yd[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: r
                    });
                    const a = /^data:(.*?)(;base64)?,(.*)$/,
                        s = t.match(a);
                    let c;
                    if (s) {
                        const n = s[1],
                            o = !!s[2];
                        let a = s[3];
                        a = decodeURIComponent(a), o && (a = atob(a));
                        try {
                            let r;
                            const o = (this.responseType || "").toLowerCase();
                            switch (o) {
                                case "arraybuffer":
                                case "blob":
                                    const t = new Uint8Array(a.length);
                                    for (let n = 0; n < a.length; n++) t[n] = a.charCodeAt(n);
                                    r = "blob" === o ? new Blob([t.buffer], {
                                        type: n
                                    }) : t.buffer;
                                    break;
                                case "document":
                                    const e = new DOMParser;
                                    r = e.parseFromString(a, n);
                                    break;
                                case "json":
                                    r = JSON.parse(a);
                                    break;
                                default:
                                    r = a;
                                    break
                            }
                            setTimeout((function() {
                                e && e(r), i.manager.itemEnd(t)
                            }), 0)
                        } catch (l) {
                            setTimeout((function() {
                                r && r(l), i.manager.itemError(t), i.manager.itemEnd(t)
                            }), 0)
                        }
                    } else {
                        yd[t] = [], yd[t].push({
                            onLoad: e,
                            onProgress: n,
                            onError: r
                        }), c = new XMLHttpRequest, c.open("GET", t, !0), c.addEventListener("load", (function(e) {
                            const n = this.response,
                                r = yd[t];
                            if (delete yd[t], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), fd.add(t, n);
                                for (let t = 0, e = r.length; t < e; t++) {
                                    const e = r[t];
                                    e.onLoad && e.onLoad(n)
                                }
                                i.manager.itemEnd(t)
                            } else {
                                for (let t = 0, n = r.length; t < n; t++) {
                                    const n = r[t];
                                    n.onError && n.onError(e)
                                }
                                i.manager.itemError(t), i.manager.itemEnd(t)
                            }
                        }), !1), c.addEventListener("progress", (function(e) {
                            const n = yd[t];
                            for (let t = 0, r = n.length; t < r; t++) {
                                const r = n[t];
                                r.onProgress && r.onProgress(e)
                            }
                        }), !1), c.addEventListener("error", (function(e) {
                            const n = yd[t];
                            delete yd[t];
                            for (let t = 0, r = n.length; t < r; t++) {
                                const r = n[t];
                                r.onError && r.onError(e)
                            }
                            i.manager.itemError(t), i.manager.itemEnd(t)
                        }), !1), c.addEventListener("abort", (function(e) {
                            const n = yd[t];
                            delete yd[t];
                            for (let t = 0, r = n.length; t < r; t++) {
                                const r = n[t];
                                r.onError && r.onError(e)
                            }
                            i.manager.itemError(t), i.manager.itemEnd(t)
                        }), !1), void 0 !== this.responseType && (c.responseType = this.responseType), void 0 !== this.withCredentials && (c.withCredentials = this.withCredentials), c.overrideMimeType && c.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                        for (const t in this.requestHeader) c.setRequestHeader(t, this.requestHeader[t]);
                        c.send(null)
                    }
                    return i.manager.itemStart(t), c
                },
                setResponseType: function(t) {
                    return this.responseType = t, this
                },
                setMimeType: function(t) {
                    return this.mimeType = t, this
                }
            }), bd.prototype = Object.assign(Object.create(vd.prototype), {
                constructor: bd,
                load: function(t, e, n, r) {
                    const i = this,
                        o = new _d(i.manager);
                    o.setPath(i.path), o.setRequestHeader(i.requestHeader), o.setWithCredentials(i.withCredentials), o.load(t, (function(n) {
                        try {
                            e(i.parse(JSON.parse(n)))
                        } catch (o) {
                            r ? r(o) : console.error(o), i.manager.itemError(t)
                        }
                    }), n, r)
                },
                parse: function(t) {
                    const e = [];
                    for (let n = 0; n < t.length; n++) {
                        const r = hd.parse(t[n]);
                        e.push(r)
                    }
                    return e
                }
            }), xd.prototype = Object.assign(Object.create(vd.prototype), {
                constructor: xd,
                load: function(t, e, n, r) {
                    const i = this,
                        o = [],
                        a = new Uu;
                    a.image = o;
                    const s = new _d(this.manager);
                    s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(i.withCredentials);
                    let c = 0;

                    function l(l) {
                        s.load(t[l], (function(t) {
                            const n = i.parse(t, !0);
                            o[l] = {
                                width: n.width,
                                height: n.height,
                                format: n.format,
                                mipmaps: n.mipmaps
                            }, c += 1, 6 === c && (1 === n.mipmapCount && (a.minFilter = ft), a.format = n.format, a.needsUpdate = !0, e && e(a))
                        }), n, r)
                    }
                    if (Array.isArray(t))
                        for (let u = 0, h = t.length; u < h; ++u) l(u);
                    else s.load(t, (function(t) {
                        const n = i.parse(t, !0);
                        if (n.isCubemap) {
                            const t = n.mipmaps.length / n.mipmapCount;
                            for (let e = 0; e < t; e++) {
                                o[e] = {
                                    mipmaps: []
                                };
                                for (let t = 0; t < n.mipmapCount; t++) o[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]), o[e].format = n.format, o[e].width = n.width, o[e].height = n.height
                            }
                        } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (a.minFilter = ft), a.format = n.format, a.needsUpdate = !0, e && e(a)
                    }), n, r);
                    return a
                }
            }), wd.prototype = Object.assign(Object.create(vd.prototype), {
                constructor: wd,
                load: function(t, e, n, r) {
                    void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    const i = this,
                        o = fd.get(t);
                    if (void 0 !== o) return i.manager.itemStart(t), setTimeout((function() {
                        e && e(o), i.manager.itemEnd(t)
                    }), 0), o;
                    const a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                    function s() {
                        a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), fd.add(t, this), e && e(this), i.manager.itemEnd(t)
                    }

                    function c(e) {
                        a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
                    }
                    return a.addEventListener("load", s, !1), a.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), i.manager.itemStart(t), a.src = t, a
                }
            }), Md.prototype = Object.assign(Object.create(vd.prototype), {
                constructor: Md,
                load: function(t, e, n, r) {
                    const i = new Xi,
                        o = new wd(this.manager);
                    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                    let a = 0;

                    function s(n) {
                        o.load(t[n], (function(t) {
                            i.images[n] = t, a++, 6 === a && (i.needsUpdate = !0, e && e(i))
                        }), void 0, r)
                    }
                    for (let c = 0; c < t.length; ++c) s(c);
                    return i
                }
            }), Td.prototype = Object.assign(Object.create(vd.prototype), {
                constructor: Td,
                load: function(t, e, n, r) {
                    const i = this,
                        o = new Yi,
                        a = new _d(this.manager);
                    return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(i.withCredentials), a.load(t, (function(t) {
                        const n = i.parse(t);
                        n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : lt, o.wrapT = void 0 !== n.wrapT ? n.wrapT : lt, o.magFilter = void 0 !== n.magFilter ? n.magFilter : ft, o.minFilter = void 0 !== n.minFilter ? n.minFilter : ft, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps, o.minFilter = gt), 1 === n.mipmapCount && (o.minFilter = ft), o.needsUpdate = !0, e && e(o, n))
                    }), n, r), o
                }
            }), Sd.prototype = Object.assign(Object.create(vd.prototype), {
                constructor: Sd,
                load: function(t, e, n, r) {
                    const i = new mn,
                        o = new wd(this.manager);
                    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, (function(n) {
                        i.image = n;
                        const r = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                        i.format = r ? Ct : Ot, i.needsUpdate = !0, void 0 !== e && e(i)
                    }), n, r), i
                }
            }), Object.assign(Ed.prototype, {
                getPoint: function() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                },
                getPointAt: function(t, e) {
                    const n = this.getUtoTmapping(t);
                    return this.getPoint(n, e)
                },
                getPoints: function(t) {
                    void 0 === t && (t = 5);
                    const e = [];
                    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return e
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 5);
                    const e = [];
                    for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                    return e
                },
                getLength: function() {
                    const t = this.getLengths();
                    return t[t.length - 1]
                },
                getLengths: function(t) {
                    if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    const e = [];
                    let n, r = this.getPoint(0),
                        i = 0;
                    e.push(0);
                    for (let o = 1; o <= t; o++) n = this.getPoint(o / t), i += n.distanceTo(r), e.push(i), r = n;
                    return this.cacheArcLengths = e, e
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function(t, e) {
                    const n = this.getLengths();
                    let r = 0;
                    const i = n.length;
                    let o;
                    o = e || t * n[i - 1];
                    let a, s = 0,
                        c = i - 1;
                    while (s <= c)
                        if (r = Math.floor(s + (c - s) / 2), a = n[r] - o, a < 0) s = r + 1;
                        else {
                            if (!(a > 0)) {
                                c = r;
                                break
                            }
                            c = r - 1
                        }
                    if (r = c, n[r] === o) return r / (i - 1);
                    const l = n[r],
                        u = n[r + 1],
                        h = u - l,
                        d = (o - l) / h,
                        p = (r + d) / (i - 1);
                    return p
                },
                getTangent: function(t, e) {
                    const n = 1e-4;
                    let r = t - n,
                        i = t + n;
                    r < 0 && (r = 0), i > 1 && (i = 1);
                    const o = this.getPoint(r),
                        a = this.getPoint(i),
                        s = e || (o.isVector2 ? new un : new bn);
                    return s.copy(a).sub(o).normalize(), s
                },
                getTangentAt: function(t, e) {
                    const n = this.getUtoTmapping(t);
                    return this.getTangent(n, e)
                },
                computeFrenetFrames: function(t, e) {
                    const n = new bn,
                        r = [],
                        i = [],
                        o = [],
                        a = new bn,
                        s = new Yn;
                    for (let d = 0; d <= t; d++) {
                        const e = d / t;
                        r[d] = this.getTangentAt(e, new bn), r[d].normalize()
                    }
                    i[0] = new bn, o[0] = new bn;
                    let c = Number.MAX_VALUE;
                    const l = Math.abs(r[0].x),
                        u = Math.abs(r[0].y),
                        h = Math.abs(r[0].z);
                    l <= c && (c = l, n.set(1, 0, 0)), u <= c && (c = u, n.set(0, 1, 0)), h <= c && n.set(0, 0, 1), a.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], a), o[0].crossVectors(r[0], i[0]);
                    for (let d = 1; d <= t; d++) {
                        if (i[d] = i[d - 1].clone(), o[d] = o[d - 1].clone(), a.crossVectors(r[d - 1], r[d]), a.length() > Number.EPSILON) {
                            a.normalize();
                            const t = Math.acos(ln.clamp(r[d - 1].dot(r[d]), -1, 1));
                            i[d].applyMatrix4(s.makeRotationAxis(a, t))
                        }
                        o[d].crossVectors(r[d], i[d])
                    }
                    if (!0 === e) {
                        let e = Math.acos(ln.clamp(i[0].dot(i[t]), -1, 1));
                        e /= t, r[0].dot(a.crossVectors(i[0], i[t])) > 0 && (e = -e);
                        for (let n = 1; n <= t; n++) i[n].applyMatrix4(s.makeRotationAxis(r[n], e * n)), o[n].crossVectors(r[n], i[n])
                    }
                    return {
                        tangents: r,
                        normals: i,
                        binormals: o
                    }
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                },
                toJSON: function() {
                    const t = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                },
                fromJSON: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                }
            }), Ad.prototype = Object.create(Ed.prototype), Ad.prototype.constructor = Ad, Ad.prototype.isEllipseCurve = !0, Ad.prototype.getPoint = function(t, e) {
                const n = e || new un,
                    r = 2 * Math.PI;
                let i = this.aEndAngle - this.aStartAngle;
                const o = Math.abs(i) < Number.EPSILON;
                while (i < 0) i += r;
                while (i > r) i -= r;
                i < Number.EPSILON && (i = o ? 0 : r), !0 !== this.aClockwise || o || (i === r ? i = -r : i -= r);
                const a = this.aStartAngle + t * i;
                let s = this.aX + this.xRadius * Math.cos(a),
                    c = this.aY + this.yRadius * Math.sin(a);
                if (0 !== this.aRotation) {
                    const t = Math.cos(this.aRotation),
                        e = Math.sin(this.aRotation),
                        n = s - this.aX,
                        r = c - this.aY;
                    s = n * t - r * e + this.aX, c = n * e + r * t + this.aY
                }
                return n.set(s, c)
            }, Ad.prototype.copy = function(t) {
                return Ed.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, Ad.prototype.toJSON = function() {
                const t = Ed.prototype.toJSON.call(this);
                return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
            }, Ad.prototype.fromJSON = function(t) {
                return Ed.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, Ld.prototype = Object.create(Ad.prototype), Ld.prototype.constructor = Ld, Ld.prototype.isArcCurve = !0;
            const Cd = new bn,
                Od = new Rd,
                Pd = new Rd,
                Id = new Rd;

            function Nd(t, e, n, r) {
                Ed.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = void 0 !== r ? r : .5
            }

            function Dd(t, e, n, r, i) {
                const o = .5 * (r - e),
                    a = .5 * (i - n),
                    s = t * t,
                    c = t * s;
                return (2 * n - 2 * r + o + a) * c + (-3 * n + 3 * r - 2 * o - a) * s + o * t + n
            }

            function kd(t, e) {
                const n = 1 - t;
                return n * n * e
            }

            function Fd(t, e) {
                return 2 * (1 - t) * t * e
            }

            function Bd(t, e) {
                return t * t * e
            }

            function Ud(t, e, n, r) {
                return kd(t, e) + Fd(t, n) + Bd(t, r)
            }

            function Hd(t, e) {
                const n = 1 - t;
                return n * n * n * e
            }

            function zd(t, e) {
                const n = 1 - t;
                return 3 * n * n * t * e
            }

            function jd(t, e) {
                return 3 * (1 - t) * t * t * e
            }

            function Gd(t, e) {
                return t * t * t * e
            }

            function Vd(t, e, n, r, i) {
                return Hd(t, e) + zd(t, n) + jd(t, r) + Gd(t, i)
            }

            function Wd(t, e, n, r) {
                Ed.call(this), this.type = "CubicBezierCurve", this.v0 = t || new un, this.v1 = e || new un, this.v2 = n || new un, this.v3 = r || new un
            }

            function Xd(t, e, n, r) {
                Ed.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new bn, this.v1 = e || new bn, this.v2 = n || new bn, this.v3 = r || new bn
            }

            function qd(t, e) {
                Ed.call(this), this.type = "LineCurve", this.v1 = t || new un, this.v2 = e || new un
            }

            function Yd(t, e) {
                Ed.call(this), this.type = "LineCurve3", this.v1 = t || new bn, this.v2 = e || new bn
            }

            function $d(t, e, n) {
                Ed.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new un, this.v1 = e || new un, this.v2 = n || new un
            }

            function Zd(t, e, n) {
                Ed.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new bn, this.v1 = e || new bn, this.v2 = n || new bn
            }

            function Jd(t) {
                Ed.call(this), this.type = "SplineCurve", this.points = t || []
            }
            Nd.prototype = Object.create(Ed.prototype), Nd.prototype.constructor = Nd, Nd.prototype.isCatmullRomCurve3 = !0, Nd.prototype.getPoint = function(t, e) {
                const n = e || new bn,
                    r = this.points,
                    i = r.length,
                    o = (i - (this.closed ? 0 : 1)) * t;
                let a, s, c = Math.floor(o),
                    l = o - c;
                this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / i) + 1) * i : 0 === l && c === i - 1 && (c = i - 2, l = 1), this.closed || c > 0 ? a = r[(c - 1) % i] : (Cd.subVectors(r[0], r[1]).add(r[0]), a = Cd);
                const u = r[c % i],
                    h = r[(c + 1) % i];
                if (this.closed || c + 2 < i ? s = r[(c + 2) % i] : (Cd.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]), s = Cd), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    const t = "chordal" === this.curveType ? .5 : .25;
                    let e = Math.pow(a.distanceToSquared(u), t),
                        n = Math.pow(u.distanceToSquared(h), t),
                        r = Math.pow(h.distanceToSquared(s), t);
                    n < 1e-4 && (n = 1), e < 1e-4 && (e = n), r < 1e-4 && (r = n), Od.initNonuniformCatmullRom(a.x, u.x, h.x, s.x, e, n, r), Pd.initNonuniformCatmullRom(a.y, u.y, h.y, s.y, e, n, r), Id.initNonuniformCatmullRom(a.z, u.z, h.z, s.z, e, n, r)
                } else "catmullrom" === this.curveType && (Od.initCatmullRom(a.x, u.x, h.x, s.x, this.tension), Pd.initCatmullRom(a.y, u.y, h.y, s.y, this.tension), Id.initCatmullRom(a.z, u.z, h.z, s.z, this.tension));
                return n.set(Od.calc(l), Pd.calc(l), Id.calc(l)), n
            }, Nd.prototype.copy = function(t) {
                Ed.prototype.copy.call(this, t), this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push(n.clone())
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, Nd.prototype.toJSON = function() {
                const t = Ed.prototype.toJSON.call(this);
                t.points = [];
                for (let e = 0, n = this.points.length; e < n; e++) {
                    const n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
            }, Nd.prototype.fromJSON = function(t) {
                Ed.prototype.fromJSON.call(this, t), this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push((new bn).fromArray(n))
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, Wd.prototype = Object.create(Ed.prototype), Wd.prototype.constructor = Wd, Wd.prototype.isCubicBezierCurve = !0, Wd.prototype.getPoint = function(t, e) {
                const n = e || new un,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2,
                    a = this.v3;
                return n.set(Vd(t, r.x, i.x, o.x, a.x), Vd(t, r.y, i.y, o.y, a.y)), n
            }, Wd.prototype.copy = function(t) {
                return Ed.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, Wd.prototype.toJSON = function() {
                const t = Ed.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, Wd.prototype.fromJSON = function(t) {
                return Ed.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, Xd.prototype = Object.create(Ed.prototype), Xd.prototype.constructor = Xd, Xd.prototype.isCubicBezierCurve3 = !0, Xd.prototype.getPoint = function(t, e) {
                const n = e || new bn,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2,
                    a = this.v3;
                return n.set(Vd(t, r.x, i.x, o.x, a.x), Vd(t, r.y, i.y, o.y, a.y), Vd(t, r.z, i.z, o.z, a.z)), n
            }, Xd.prototype.copy = function(t) {
                return Ed.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, Xd.prototype.toJSON = function() {
                const t = Ed.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, Xd.prototype.fromJSON = function(t) {
                return Ed.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, qd.prototype = Object.create(Ed.prototype), qd.prototype.constructor = qd, qd.prototype.isLineCurve = !0, qd.prototype.getPoint = function(t, e) {
                const n = e || new un;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }, qd.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, qd.prototype.getTangent = function(t, e) {
                const n = e || new un;
                return n.copy(this.v2).sub(this.v1).normalize(), n
            }, qd.prototype.copy = function(t) {
                return Ed.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, qd.prototype.toJSON = function() {
                const t = Ed.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, qd.prototype.fromJSON = function(t) {
                return Ed.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Yd.prototype = Object.create(Ed.prototype), Yd.prototype.constructor = Yd, Yd.prototype.isLineCurve3 = !0, Yd.prototype.getPoint = function(t, e) {
                const n = e || new bn;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }, Yd.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, Yd.prototype.copy = function(t) {
                return Ed.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Yd.prototype.toJSON = function() {
                const t = Ed.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Yd.prototype.fromJSON = function(t) {
                return Ed.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, $d.prototype = Object.create(Ed.prototype), $d.prototype.constructor = $d, $d.prototype.isQuadraticBezierCurve = !0, $d.prototype.getPoint = function(t, e) {
                const n = e || new un,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2;
                return n.set(Ud(t, r.x, i.x, o.x), Ud(t, r.y, i.y, o.y)), n
            }, $d.prototype.copy = function(t) {
                return Ed.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, $d.prototype.toJSON = function() {
                const t = Ed.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, $d.prototype.fromJSON = function(t) {
                return Ed.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Zd.prototype = Object.create(Ed.prototype), Zd.prototype.constructor = Zd, Zd.prototype.isQuadraticBezierCurve3 = !0, Zd.prototype.getPoint = function(t, e) {
                const n = e || new bn,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2;
                return n.set(Ud(t, r.x, i.x, o.x), Ud(t, r.y, i.y, o.y), Ud(t, r.z, i.z, o.z)), n
            }, Zd.prototype.copy = function(t) {
                return Ed.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Zd.prototype.toJSON = function() {
                const t = Ed.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Zd.prototype.fromJSON = function(t) {
                return Ed.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Jd.prototype = Object.create(Ed.prototype), Jd.prototype.constructor = Jd, Jd.prototype.isSplineCurve = !0, Jd.prototype.getPoint = function(t, e) {
                const n = e || new un,
                    r = this.points,
                    i = (r.length - 1) * t,
                    o = Math.floor(i),
                    a = i - o,
                    s = r[0 === o ? o : o - 1],
                    c = r[o],
                    l = r[o > r.length - 2 ? r.length - 1 : o + 1],
                    u = r[o > r.length - 3 ? r.length - 1 : o + 2];
                return n.set(Dd(a, s.x, c.x, l.x, u.x), Dd(a, s.y, c.y, l.y, u.y)), n
            }, Jd.prototype.copy = function(t) {
                Ed.prototype.copy.call(this, t), this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push(n.clone())
                }
                return this
            }, Jd.prototype.toJSON = function() {
                const t = Ed.prototype.toJSON.call(this);
                t.points = [];
                for (let e = 0, n = this.points.length; e < n; e++) {
                    const n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t
            }, Jd.prototype.fromJSON = function(t) {
                Ed.prototype.fromJSON.call(this, t), this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push((new un).fromArray(n))
                }
                return this
            };
            var Kd = Object.freeze({
                __proto__: null,
                ArcCurve: Ld,
                CatmullRomCurve3: Nd,
                CubicBezierCurve: Wd,
                CubicBezierCurve3: Xd,
                EllipseCurve: Ad,
                LineCurve: qd,
                LineCurve3: Yd,
                QuadraticBezierCurve: $d,
                QuadraticBezierCurve3: Zd,
                SplineCurve: Jd
            });

            function Qd() {
                Ed.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }

            function tp(t) {
                Qd.call(this), this.type = "Path", this.currentPoint = new un, t && this.setFromPoints(t)
            }

            function ep(t) {
                tp.call(this, t), this.uuid = ln.generateUUID(), this.type = "Shape", this.holes = []
            }

            function np(t, e) {
                _r.call(this), this.type = "Light", this.color = new zr(t), this.intensity = void 0 !== e ? e : 1
            }

            function rp(t, e, n) {
                np.call(this, t, n), this.type = "HemisphereLight", this.position.copy(_r.DefaultUp), this.updateMatrix(), this.groundColor = new zr(e)
            }

            function ip(t) {
                this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new un(512, 512), this.map = null, this.mapPass = null, this.matrix = new Yn, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Ji, this._frameExtents = new un(1, 1), this._viewportCount = 1, this._viewports = [new gn(0, 0, 1, 1)]
            }

            function op() {
                ip.call(this, new ji(50, 1, .5, 500)), this.focus = 1
            }

            function ap(t, e, n, r, i, o) {
                np.call(this, t, e), this.type = "SpotLight", this.position.copy(_r.DefaultUp), this.updateMatrix(), this.target = new _r, Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / Math.PI
                    }
                }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new op
            }

            function sp() {
                ip.call(this, new ji(90, 1, .5, 500)), this._frameExtents = new un(4, 2), this._viewportCount = 6, this._viewports = [new gn(2, 1, 1, 1), new gn(0, 1, 1, 1), new gn(3, 1, 1, 1), new gn(1, 1, 1, 1), new gn(3, 0, 1, 1), new gn(1, 0, 1, 1)], this._cubeDirections = [new bn(1, 0, 0), new bn(-1, 0, 0), new bn(0, 0, 1), new bn(0, 0, -1), new bn(0, 1, 0), new bn(0, -1, 0)], this._cubeUps = [new bn(0, 1, 0), new bn(0, 1, 0), new bn(0, 1, 0), new bn(0, 1, 0), new bn(0, 0, 1), new bn(0, 0, -1)]
            }

            function cp(t, e, n, r) {
                np.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                    get: function() {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / (4 * Math.PI)
                    }
                }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new sp
            }

            function lp(t, e, n, r, i, o) {
                zi.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== r ? r : -1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
            }

            function up() {
                ip.call(this, new lp(-5, 5, 5, -5, .5, 500))
            }

            function hp(t, e) {
                np.call(this, t, e), this.type = "DirectionalLight", this.position.copy(_r.DefaultUp), this.updateMatrix(), this.target = new _r, this.shadow = new up
            }

            function dp(t, e) {
                np.call(this, t, e), this.type = "AmbientLight"
            }

            function pp(t, e, n, r) {
                np.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== r ? r : 10
            }
            Qd.prototype = Object.assign(Object.create(Ed.prototype), {
                constructor: Qd,
                add: function(t) {
                    this.curves.push(t)
                },
                closePath: function() {
                    const t = this.curves[0].getPoint(0),
                        e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new qd(e, t))
                },
                getPoint: function(t) {
                    const e = t * this.getLength(),
                        n = this.getCurveLengths();
                    let r = 0;
                    while (r < n.length) {
                        if (n[r] >= e) {
                            const t = n[r] - e,
                                i = this.curves[r],
                                o = i.getLength(),
                                a = 0 === o ? 0 : 1 - t / o;
                            return i.getPointAt(a)
                        }
                        r++
                    }
                    return null
                },
                getLength: function() {
                    const t = this.getCurveLengths();
                    return t[t.length - 1]
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                },
                getCurveLengths: function() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    const t = [];
                    let e = 0;
                    for (let n = 0, r = this.curves.length; n < r; n++) e += this.curves[n].getLength(), t.push(e);
                    return this.cacheLengths = t, t
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 40);
                    const e = [];
                    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return this.autoClose && e.push(e[0]), e
                },
                getPoints: function(t) {
                    t = t || 12;
                    const e = [];
                    let n;
                    for (let r = 0, i = this.curves; r < i.length; r++) {
                        const o = i[r],
                            a = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t,
                            s = o.getPoints(a);
                        for (let t = 0; t < s.length; t++) {
                            const r = s[t];
                            n && n.equals(r) || (e.push(r), n = r)
                        }
                    }
                    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
                },
                copy: function(t) {
                    Ed.prototype.copy.call(this, t), this.curves = [];
                    for (let e = 0, n = t.curves.length; e < n; e++) {
                        const n = t.curves[e];
                        this.curves.push(n.clone())
                    }
                    return this.autoClose = t.autoClose, this
                },
                toJSON: function() {
                    const t = Ed.prototype.toJSON.call(this);
                    t.autoClose = this.autoClose, t.curves = [];
                    for (let e = 0, n = this.curves.length; e < n; e++) {
                        const n = this.curves[e];
                        t.curves.push(n.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    Ed.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
                    for (let e = 0, n = t.curves.length; e < n; e++) {
                        const n = t.curves[e];
                        this.curves.push((new Kd[n.type]).fromJSON(n))
                    }
                    return this
                }
            }), tp.prototype = Object.assign(Object.create(Qd.prototype), {
                constructor: tp,
                setFromPoints: function(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
                    return this
                },
                moveTo: function(t, e) {
                    return this.currentPoint.set(t, e), this
                },
                lineTo: function(t, e) {
                    const n = new qd(this.currentPoint.clone(), new un(t, e));
                    return this.curves.push(n), this.currentPoint.set(t, e), this
                },
                quadraticCurveTo: function(t, e, n, r) {
                    const i = new $d(this.currentPoint.clone(), new un(t, e), new un(n, r));
                    return this.curves.push(i), this.currentPoint.set(n, r), this
                },
                bezierCurveTo: function(t, e, n, r, i, o) {
                    const a = new Wd(this.currentPoint.clone(), new un(t, e), new un(n, r), new un(i, o));
                    return this.curves.push(a), this.currentPoint.set(i, o), this
                },
                splineThru: function(t) {
                    const e = [this.currentPoint.clone()].concat(t),
                        n = new Jd(e);
                    return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
                },
                arc: function(t, e, n, r, i, o) {
                    const a = this.currentPoint.x,
                        s = this.currentPoint.y;
                    return this.absarc(t + a, e + s, n, r, i, o), this
                },
                absarc: function(t, e, n, r, i, o) {
                    return this.absellipse(t, e, n, n, r, i, o), this
                },
                ellipse: function(t, e, n, r, i, o, a, s) {
                    const c = this.currentPoint.x,
                        l = this.currentPoint.y;
                    return this.absellipse(t + c, e + l, n, r, i, o, a, s), this
                },
                absellipse: function(t, e, n, r, i, o, a, s) {
                    const c = new Ad(t, e, n, r, i, o, a, s);
                    if (this.curves.length > 0) {
                        const t = c.getPoint(0);
                        t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                    }
                    this.curves.push(c);
                    const l = c.getPoint(1);
                    return this.currentPoint.copy(l), this
                },
                copy: function(t) {
                    return Qd.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
                },
                toJSON: function() {
                    const t = Qd.prototype.toJSON.call(this);
                    return t.currentPoint = this.currentPoint.toArray(), t
                },
                fromJSON: function(t) {
                    return Qd.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
                }
            }), ep.prototype = Object.assign(Object.create(tp.prototype), {
                constructor: ep,
                getPointsHoles: function(t) {
                    const e = [];
                    for (let n = 0, r = this.holes.length; n < r; n++) e[n] = this.holes[n].getPoints(t);
                    return e
                },
                extractPoints: function(t) {
                    return {
                        shape: this.getPoints(t),
                        holes: this.getPointsHoles(t)
                    }
                },
                copy: function(t) {
                    tp.prototype.copy.call(this, t), this.holes = [];
                    for (let e = 0, n = t.holes.length; e < n; e++) {
                        const n = t.holes[e];
                        this.holes.push(n.clone())
                    }
                    return this
                },
                toJSON: function() {
                    const t = tp.prototype.toJSON.call(this);
                    t.uuid = this.uuid, t.holes = [];
                    for (let e = 0, n = this.holes.length; e < n; e++) {
                        const n = this.holes[e];
                        t.holes.push(n.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    tp.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
                    for (let e = 0, n = t.holes.length; e < n; e++) {
                        const n = t.holes[e];
                        this.holes.push((new tp).fromJSON(n))
                    }
                    return this
                }
            }), np.prototype = Object.assign(Object.create(_r.prototype), {
                constructor: np,
                isLight: !0,
                copy: function(t) {
                    return _r.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
                },
                toJSON: function(t) {
                    const e = _r.prototype.toJSON.call(this, t);
                    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                }
            }), rp.prototype = Object.assign(Object.create(np.prototype), {
                constructor: rp,
                isHemisphereLight: !0,
                copy: function(t) {
                    return np.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                }
            }), Object.assign(ip.prototype, {
                _projScreenMatrix: new Yn,
                _lightPositionWorld: new bn,
                _lookTarget: new bn,
                getViewportCount: function() {
                    return this._viewportCount
                },
                getFrustum: function() {
                    return this._frustum
                },
                updateMatrices: function(t) {
                    const e = this.camera,
                        n = this.matrix,
                        r = this._projScreenMatrix,
                        i = this._lookTarget,
                        o = this._lightPositionWorld;
                    o.setFromMatrixPosition(t.matrixWorld), e.position.copy(o), i.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(i), e.updateMatrixWorld(), r.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(r), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
                },
                getViewport: function(t) {
                    return this._viewports[t]
                },
                getFrameExtents: function() {
                    return this._frameExtents
                },
                copy: function(t) {
                    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    const t = {};
                    return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                }
            }), op.prototype = Object.assign(Object.create(ip.prototype), {
                constructor: op,
                isSpotLightShadow: !0,
                updateMatrices: function(t) {
                    const e = this.camera,
                        n = 2 * ln.RAD2DEG * t.angle * this.focus,
                        r = this.mapSize.width / this.mapSize.height,
                        i = t.distance || e.far;
                    n === e.fov && r === e.aspect && i === e.far || (e.fov = n, e.aspect = r, e.far = i, e.updateProjectionMatrix()), ip.prototype.updateMatrices.call(this, t)
                }
            }), ap.prototype = Object.assign(Object.create(np.prototype), {
                constructor: ap,
                isSpotLight: !0,
                copy: function(t) {
                    return np.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), sp.prototype = Object.assign(Object.create(ip.prototype), {
                constructor: sp,
                isPointLightShadow: !0,
                updateMatrices: function(t, e) {
                    void 0 === e && (e = 0);
                    const n = this.camera,
                        r = this.matrix,
                        i = this._lightPositionWorld,
                        o = this._lookTarget,
                        a = this._projScreenMatrix;
                    i.setFromMatrixPosition(t.matrixWorld), n.position.copy(i), o.copy(n.position), o.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(o), n.updateMatrixWorld(), r.makeTranslation(-i.x, -i.y, -i.z), a.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(a)
                }
            }), cp.prototype = Object.assign(Object.create(np.prototype), {
                constructor: cp,
                isPointLight: !0,
                copy: function(t) {
                    return np.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                }
            }), lp.prototype = Object.assign(Object.create(zi.prototype), {
                constructor: lp,
                isOrthographicCamera: !0,
                copy: function(t, e) {
                    return zi.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                },
                setViewOffset: function(t, e, n, r, i, o) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    const t = (this.right - this.left) / (2 * this.zoom),
                        e = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        r = (this.top + this.bottom) / 2;
                    let i = n - t,
                        o = n + t,
                        a = r + e,
                        s = r - e;
                    if (null !== this.view && this.view.enabled) {
                        const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                            e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        i += t * this.view.offsetX, o = i + t * this.view.width, a -= e * this.view.offsetY, s = a - e * this.view.height
                    }
                    this.projectionMatrix.makeOrthographic(i, o, a, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    const e = _r.prototype.toJSON.call(this, t);
                    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                }
            }), up.prototype = Object.assign(Object.create(ip.prototype), {
                constructor: up,
                isDirectionalLightShadow: !0,
                updateMatrices: function(t) {
                    ip.prototype.updateMatrices.call(this, t)
                }
            }), hp.prototype = Object.assign(Object.create(np.prototype), {
                constructor: hp,
                isDirectionalLight: !0,
                copy: function(t) {
                    return np.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), dp.prototype = Object.assign(Object.create(np.prototype), {
                constructor: dp,
                isAmbientLight: !0
            }), pp.prototype = Object.assign(Object.create(np.prototype), {
                constructor: pp,
                isRectAreaLight: !0,
                copy: function(t) {
                    return np.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
                },
                toJSON: function(t) {
                    const e = np.prototype.toJSON.call(this, t);
                    return e.object.width = this.width, e.object.height = this.height, e
                }
            });
            class fp {
                constructor() {
                    Object.defineProperty(this, "isSphericalHarmonics3", {
                        value: !0
                    }), this.coefficients = [];
                    for (let t = 0; t < 9; t++) this.coefficients.push(new bn)
                }
                set(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                    return this
                }
                zero() {
                    for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                    return this
                }
                getAt(t, e) {
                    const n = t.x,
                        r = t.y,
                        i = t.z,
                        o = this.coefficients;
                    return e.copy(o[0]).multiplyScalar(.282095), e.addScaledVector(o[1], .488603 * r), e.addScaledVector(o[2], .488603 * i), e.addScaledVector(o[3], .488603 * n), e.addScaledVector(o[4], n * r * 1.092548), e.addScaledVector(o[5], r * i * 1.092548), e.addScaledVector(o[6], .315392 * (3 * i * i - 1)), e.addScaledVector(o[7], n * i * 1.092548), e.addScaledVector(o[8], .546274 * (n * n - r * r)), e
                }
                getIrradianceAt(t, e) {
                    const n = t.x,
                        r = t.y,
                        i = t.z,
                        o = this.coefficients;
                    return e.copy(o[0]).multiplyScalar(.886227), e.addScaledVector(o[1], 1.023328 * r), e.addScaledVector(o[2], 1.023328 * i), e.addScaledVector(o[3], 1.023328 * n), e.addScaledVector(o[4], .858086 * n * r), e.addScaledVector(o[5], .858086 * r * i), e.addScaledVector(o[6], .743125 * i * i - .247708), e.addScaledVector(o[7], .858086 * n * i), e.addScaledVector(o[8], .429043 * (n * n - r * r)), e
                }
                add(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                    return this
                }
                addScaledSH(t, e) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
                    return this
                }
                scale(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                    return this
                }
                lerp(t, e) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
                    return this
                }
                equals(t) {
                    for (let e = 0; e < 9; e++)
                        if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                    return !0
                }
                copy(t) {
                    return this.set(t.coefficients)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                fromArray(t, e = 0) {
                    const n = this.coefficients;
                    for (let r = 0; r < 9; r++) n[r].fromArray(t, e + 3 * r);
                    return this
                }
                toArray(t = [], e = 0) {
                    const n = this.coefficients;
                    for (let r = 0; r < 9; r++) n[r].toArray(t, e + 3 * r);
                    return t
                }
                static getBasisAt(t, e) {
                    const n = t.x,
                        r = t.y,
                        i = t.z;
                    e[0] = .282095, e[1] = .488603 * r, e[2] = .488603 * i, e[3] = .488603 * n, e[4] = 1.092548 * n * r, e[5] = 1.092548 * r * i, e[6] = .315392 * (3 * i * i - 1), e[7] = 1.092548 * n * i, e[8] = .546274 * (n * n - r * r)
                }
            }

            function mp(t, e) {
                np.call(this, void 0, e), this.type = "LightProbe", this.sh = void 0 !== t ? t : new fp
            }

            function gp(t) {
                vd.call(this, t), this.textures = {}
            }
            mp.prototype = Object.assign(Object.create(np.prototype), {
                constructor: mp,
                isLightProbe: !0,
                copy: function(t) {
                    return np.prototype.copy.call(this, t), this.sh.copy(t.sh), this
                },
                fromJSON: function(t) {
                    return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
                },
                toJSON: function(t) {
                    const e = np.prototype.toJSON.call(this, t);
                    return e.object.sh = this.sh.toArray(), e
                }
            }), gp.prototype = Object.assign(Object.create(vd.prototype), {
                constructor: gp,
                load: function(t, e, n, r) {
                    const i = this,
                        o = new _d(i.manager);
                    o.setPath(i.path), o.setRequestHeader(i.requestHeader), o.setWithCredentials(i.withCredentials), o.load(t, (function(n) {
                        try {
                            e(i.parse(JSON.parse(n)))
                        } catch (o) {
                            r ? r(o) : console.error(o), i.manager.itemError(t)
                        }
                    }), n, r)
                },
                parse: function(t) {
                    const e = this.textures;

                    function n(t) {
                        return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
                    }
                    const r = new Jh[t.type];
                    if (void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && void 0 !== r.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.sheen && (r.sheen = (new zr).setHex(t.sheen)), void 0 !== t.emissive && void 0 !== r.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== r.specular && r.specular.setHex(t.specular), void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearcoat && (r.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (r.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.flatShading && (r.flatShading = t.flatShading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.combine && (r.combine = t.combine), void 0 !== t.side && (r.side = t.side), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (r.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (r.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (r.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (r.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (r.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (r.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (r.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (r.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (r.rotation = t.rotation), 1 !== t.linewidth && (r.linewidth = t.linewidth), void 0 !== t.dashSize && (r.dashSize = t.dashSize), void 0 !== t.gapSize && (r.gapSize = t.gapSize), void 0 !== t.scale && (r.scale = t.scale), void 0 !== t.polygonOffset && (r.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (r.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (r.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (r.skinning = t.skinning), void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (r.morphNormals = t.morphNormals), void 0 !== t.dithering && (r.dithering = t.dithering), void 0 !== t.vertexTangents && (r.vertexTangents = t.vertexTangents), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.toneMapped && (r.toneMapped = t.toneMapped), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.vertexColors && ("number" === typeof t.vertexColors ? r.vertexColors = t.vertexColors > 0 : r.vertexColors = t.vertexColors), void 0 !== t.uniforms)
                        for (const i in t.uniforms) {
                            const e = t.uniforms[i];
                            switch (r.uniforms[i] = {}, e.type) {
                                case "t":
                                    r.uniforms[i].value = n(e.value);
                                    break;
                                case "c":
                                    r.uniforms[i].value = (new zr).setHex(e.value);
                                    break;
                                case "v2":
                                    r.uniforms[i].value = (new un).fromArray(e.value);
                                    break;
                                case "v3":
                                    r.uniforms[i].value = (new bn).fromArray(e.value);
                                    break;
                                case "v4":
                                    r.uniforms[i].value = (new gn).fromArray(e.value);
                                    break;
                                case "m3":
                                    r.uniforms[i].value = (new hn).fromArray(e.value);
                                    break;
                                case "m4":
                                    r.uniforms[i].value = (new Yn).fromArray(e.value);
                                    break;
                                default:
                                    r.uniforms[i].value = e.value
                            }
                        }
                    if (void 0 !== t.defines && (r.defines = t.defines), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                        for (const i in t.extensions) r.extensions[i] = t.extensions[i];
                    if (void 0 !== t.shading && (r.flatShading = 1 === t.shading), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = n(t.map)), void 0 !== t.matcap && (r.matcap = n(t.matcap)), void 0 !== t.alphaMap && (r.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (r.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (r.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                        let e = t.normalScale;
                        !1 === Array.isArray(e) && (e = [e, e]), r.normalScale = (new un).fromArray(e)
                    }
                    return void 0 !== t.displacementMap && (r.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = n(t.specularMap)), void 0 !== t.envMap && (r.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (r.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (r.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (r.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (r.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (r.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (r.clearcoatNormalScale = (new un).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmission && (r.transmission = t.transmission), void 0 !== t.transmissionMap && (r.transmissionMap = n(t.transmissionMap)), r
                },
                setTextures: function(t) {
                    return this.textures = t, this
                }
            });
            const vp = {
                decodeText: function(t) {
                    if ("undefined" !== typeof TextDecoder) return (new TextDecoder).decode(t);
                    let e = "";
                    for (let r = 0, i = t.length; r < i; r++) e += String.fromCharCode(t[r]);
                    try {
                        return decodeURIComponent(escape(e))
                    } catch (n) {
                        return e
                    }
                },
                extractUrlBase: function(t) {
                    const e = t.lastIndexOf("/");
                    return -1 === e ? "./" : t.substr(0, e + 1)
                }
            };

            function yp() {
                pi.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
            }

            function _p(t, e, n, r) {
                "number" === typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), Yr.call(this, t, e, n), this.meshPerAttribute = r || 1
            }

            function bp(t) {
                vd.call(this, t)
            }
            yp.prototype = Object.assign(Object.create(pi.prototype), {
                constructor: yp,
                isInstancedBufferGeometry: !0,
                copy: function(t) {
                    return pi.prototype.copy.call(this, t), this.instanceCount = t.instanceCount, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    const t = pi.prototype.toJSON.call(this);
                    return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
                }
            }), _p.prototype = Object.assign(Object.create(Yr.prototype), {
                constructor: _p,
                isInstancedBufferAttribute: !0,
                copy: function(t) {
                    return Yr.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                },
                toJSON: function() {
                    const t = Yr.prototype.toJSON.call(this);
                    return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
                }
            }), bp.prototype = Object.assign(Object.create(vd.prototype), {
                constructor: bp,
                load: function(t, e, n, r) {
                    const i = this,
                        o = new _d(i.manager);
                    o.setPath(i.path), o.setRequestHeader(i.requestHeader), o.setWithCredentials(i.withCredentials), o.load(t, (function(n) {
                        try {
                            e(i.parse(JSON.parse(n)))
                        } catch (o) {
                            r ? r(o) : console.error(o), i.manager.itemError(t)
                        }
                    }), n, r)
                },
                parse: function(t) {
                    const e = {},
                        n = {};

                    function r(t, n) {
                        if (void 0 !== e[n]) return e[n];
                        const r = t.interleavedBuffers,
                            o = r[n],
                            a = i(t, o.buffer),
                            s = new xp[o.type](a),
                            c = new jl(s, o.stride);
                        return c.uuid = o.uuid, e[n] = c, c
                    }

                    function i(t, e) {
                        if (void 0 !== n[e]) return n[e];
                        const r = t.arrayBuffers,
                            i = r[e],
                            o = new Uint32Array(i).buffer;
                        return n[e] = o, o
                    }
                    const o = t.isInstancedBufferGeometry ? new yp : new pi,
                        a = t.data.index;
                    if (void 0 !== a) {
                        const t = new xp[a.type](a.array);
                        o.setIndex(new Yr(t, 1))
                    }
                    const s = t.data.attributes;
                    for (const d in s) {
                        const e = s[d];
                        let n;
                        if (e.isInterleavedBufferAttribute) {
                            const i = r(t.data, e.data);
                            n = new Vl(i, e.itemSize, e.offset, e.normalized)
                        } else {
                            const t = new xp[e.type](e.array),
                                r = e.isInstancedBufferAttribute ? _p : Yr;
                            n = new r(t, e.itemSize, e.normalized)
                        }
                        void 0 !== e.name && (n.name = e.name), o.setAttribute(d, n)
                    }
                    const c = t.data.morphAttributes;
                    if (c)
                        for (const d in c) {
                            const e = c[d],
                                n = [];
                            for (let i = 0, o = e.length; i < o; i++) {
                                const o = e[i];
                                let a;
                                if (o.isInterleavedBufferAttribute) {
                                    const e = r(t.data, o.data);
                                    a = new Vl(e, o.itemSize, o.offset, o.normalized)
                                } else {
                                    const t = new xp[o.type](o.array);
                                    a = new Yr(t, o.itemSize, o.normalized)
                                }
                                void 0 !== o.name && (a.name = o.name), n.push(a)
                            }
                            o.morphAttributes[d] = n
                        }
                    const l = t.data.morphTargetsRelative;
                    l && (o.morphTargetsRelative = !0);
                    const u = t.data.groups || t.data.drawcalls || t.data.offsets;
                    if (void 0 !== u)
                        for (let d = 0, p = u.length; d !== p; ++d) {
                            const t = u[d];
                            o.addGroup(t.start, t.count, t.materialIndex)
                        }
                    const h = t.data.boundingSphere;
                    if (void 0 !== h) {
                        const t = new bn;
                        void 0 !== h.center && t.fromArray(h.center), o.boundingSphere = new Un(t, h.radius)
                    }
                    return t.name && (o.name = t.name), t.userData && (o.userData = t.userData), o
                }
            });
            const xp = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: "undefined" !== typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };

            function wp(t) {
                "undefined" === typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), vd.call(this, t), this.options = {
                    premultiplyAlpha: "none"
                }
            }

            function Mp() {
                this.type = "ShapePath", this.color = new zr, this.subPaths = [], this.currentPath = null
            }

            function Tp(t) {
                this.type = "Font", this.data = t
            }

            function Sp(t, e, n) {
                const r = Array.from ? Array.from(t) : String(t).split(""),
                    i = e / n.resolution,
                    o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i,
                    a = [];
                let s = 0,
                    c = 0;
                for (let l = 0; l < r.length; l++) {
                    const t = r[l];
                    if ("\n" === t) s = 0, c -= o;
                    else {
                        const e = Ep(t, i, s, c, n);
                        s += e.offsetX, a.push(e.path)
                    }
                }
                return a
            }

            function Ep(t, e, n, r, i) {
                const o = i.glyphs[t] || i.glyphs["?"];
                if (!o) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + i.familyName + ".");
                const a = new Mp;
                let s, c, l, u, h, d, p, f;
                if (o.o) {
                    const t = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
                    for (let i = 0, o = t.length; i < o;) {
                        const o = t[i++];
                        switch (o) {
                            case "m":
                                s = t[i++] * e + n, c = t[i++] * e + r, a.moveTo(s, c);
                                break;
                            case "l":
                                s = t[i++] * e + n, c = t[i++] * e + r, a.lineTo(s, c);
                                break;
                            case "q":
                                l = t[i++] * e + n, u = t[i++] * e + r, h = t[i++] * e + n, d = t[i++] * e + r, a.quadraticCurveTo(h, d, l, u);
                                break;
                            case "b":
                                l = t[i++] * e + n, u = t[i++] * e + r, h = t[i++] * e + n, d = t[i++] * e + r, p = t[i++] * e + n, f = t[i++] * e + r, a.bezierCurveTo(h, d, p, f, l, u);
                                break
                        }
                    }
                }
                return {
                    offsetX: o.ha * e,
                    path: a
                }
            }

            function Ap(t) {
                vd.call(this, t)
            }
            let Lp;
            wp.prototype = Object.assign(Object.create(vd.prototype), {
                constructor: wp,
                isImageBitmapLoader: !0,
                setOptions: function(t) {
                    return this.options = t, this
                },
                load: function(t, e, n, r) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    const i = this,
                        o = fd.get(t);
                    if (void 0 !== o) return i.manager.itemStart(t), setTimeout((function() {
                        e && e(o), i.manager.itemEnd(t)
                    }), 0), o;
                    const a = {};
                    a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", fetch(t, a).then((function(t) {
                        return t.blob()
                    })).then((function(t) {
                        return createImageBitmap(t, i.options)
                    })).then((function(n) {
                        fd.add(t, n), e && e(n), i.manager.itemEnd(t)
                    })).catch((function(e) {
                        r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
                    })), i.manager.itemStart(t)
                }
            }), Object.assign(Mp.prototype, {
                moveTo: function(t, e) {
                    return this.currentPath = new tp, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
                },
                lineTo: function(t, e) {
                    return this.currentPath.lineTo(t, e), this
                },
                quadraticCurveTo: function(t, e, n, r) {
                    return this.currentPath.quadraticCurveTo(t, e, n, r), this
                },
                bezierCurveTo: function(t, e, n, r, i, o) {
                    return this.currentPath.bezierCurveTo(t, e, n, r, i, o), this
                },
                splineThru: function(t) {
                    return this.currentPath.splineThru(t), this
                },
                toShapes: function(t, e) {
                    function n(t) {
                        const e = [];
                        for (let n = 0, r = t.length; n < r; n++) {
                            const r = t[n],
                                i = new ep;
                            i.curves = r.curves, e.push(i)
                        }
                        return e
                    }

                    function r(t, e) {
                        const n = e.length;
                        let r = !1;
                        for (let i = n - 1, o = 0; o < n; i = o++) {
                            let n = e[i],
                                a = e[o],
                                s = a.x - n.x,
                                c = a.y - n.y;
                            if (Math.abs(c) > Number.EPSILON) {
                                if (c < 0 && (n = e[o], s = -s, a = e[i], c = -c), t.y < n.y || t.y > a.y) continue;
                                if (t.y === n.y) {
                                    if (t.x === n.x) return !0
                                } else {
                                    const e = c * (t.x - n.x) - s * (t.y - n.y);
                                    if (0 === e) return !0;
                                    if (e < 0) continue;
                                    r = !r
                                }
                            } else {
                                if (t.y !== n.y) continue;
                                if (a.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= a.x) return !0
                            }
                        }
                        return r
                    }
                    const i = Sh.isClockWise,
                        o = this.subPaths;
                    if (0 === o.length) return [];
                    if (!0 === e) return n(o);
                    let a, s, c;
                    const l = [];
                    if (1 === o.length) return s = o[0], c = new ep, c.curves = s.curves, l.push(c), l;
                    let u = !i(o[0].getPoints());
                    u = t ? !u : u;
                    const h = [],
                        d = [];
                    let p, f, m = [],
                        g = 0;
                    d[g] = void 0, m[g] = [];
                    for (let v = 0, y = o.length; v < y; v++) s = o[v], p = s.getPoints(), a = i(p), a = t ? !a : a, a ? (!u && d[g] && g++, d[g] = {
                        s: new ep,
                        p: p
                    }, d[g].s.curves = s.curves, u && g++, m[g] = []) : m[g].push({
                        h: s,
                        p: p[0]
                    });
                    if (!d[0]) return n(o);
                    if (d.length > 1) {
                        let t = !1;
                        const e = [];
                        for (let n = 0, r = d.length; n < r; n++) h[n] = [];
                        for (let n = 0, i = d.length; n < i; n++) {
                            const i = m[n];
                            for (let o = 0; o < i.length; o++) {
                                const a = i[o];
                                let s = !0;
                                for (let i = 0; i < d.length; i++) r(a.p, d[i].p) && (n !== i && e.push({
                                    froms: n,
                                    tos: i,
                                    hole: o
                                }), s ? (s = !1, h[i].push(a)) : t = !0);
                                s && h[n].push(a)
                            }
                        }
                        e.length > 0 && (t || (m = h))
                    }
                    for (let v = 0, y = d.length; v < y; v++) {
                        c = d[v].s, l.push(c), f = m[v];
                        for (let t = 0, e = f.length; t < e; t++) c.holes.push(f[t].h)
                    }
                    return l
                }
            }), Object.assign(Tp.prototype, {
                isFont: !0,
                generateShapes: function(t, e) {
                    void 0 === e && (e = 100);
                    const n = [],
                        r = Sp(t, e, this.data);
                    for (let i = 0, o = r.length; i < o; i++) Array.prototype.push.apply(n, r[i].toShapes());
                    return n
                }
            }), Ap.prototype = Object.assign(Object.create(vd.prototype), {
                constructor: Ap,
                load: function(t, e, n, r) {
                    const i = this,
                        o = new _d(this.manager);
                    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(i.withCredentials), o.load(t, (function(t) {
                        let n;
                        try {
                            n = JSON.parse(t)
                        } catch (o) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                        }
                        const r = i.parse(n);
                        e && e(r)
                    }), n, r)
                },
                parse: function(t) {
                    return new Tp(t)
                }
            });
            const Rp = {
                getContext: function() {
                    return void 0 === Lp && (Lp = new(window.AudioContext || window.webkitAudioContext)), Lp
                },
                setContext: function(t) {
                    Lp = t
                }
            };

            function Cp(t) {
                vd.call(this, t)
            }

            function Op(t, e, n) {
                mp.call(this, void 0, n);
                const r = (new zr).set(t),
                    i = (new zr).set(e),
                    o = new bn(r.r, r.g, r.b),
                    a = new bn(i.r, i.g, i.b),
                    s = Math.sqrt(Math.PI),
                    c = s * Math.sqrt(.75);
                this.sh.coefficients[0].copy(o).add(a).multiplyScalar(s), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)
            }

            function Pp(t, e) {
                mp.call(this, void 0, e);
                const n = (new zr).set(t);
                this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
            }
            Cp.prototype = Object.assign(Object.create(vd.prototype), {
                constructor: Cp,
                load: function(t, e, n, r) {
                    const i = this,
                        o = new _d(i.manager);
                    o.setResponseType("arraybuffer"), o.setPath(i.path), o.setRequestHeader(i.requestHeader), o.setWithCredentials(i.withCredentials), o.load(t, (function(n) {
                        try {
                            const t = n.slice(0),
                                r = Rp.getContext();
                            r.decodeAudioData(t, (function(t) {
                                e(t)
                            }))
                        } catch (o) {
                            r ? r(o) : console.error(o), i.manager.itemError(t)
                        }
                    }), n, r)
                }
            }), Op.prototype = Object.assign(Object.create(mp.prototype), {
                constructor: Op,
                isHemisphereLightProbe: !0,
                copy: function(t) {
                    return mp.prototype.copy.call(this, t), this
                },
                toJSON: function(t) {
                    const e = mp.prototype.toJSON.call(this, t);
                    return e
                }
            }), Pp.prototype = Object.assign(Object.create(mp.prototype), {
                constructor: Pp,
                isAmbientLightProbe: !0,
                copy: function(t) {
                    return mp.prototype.copy.call(this, t), this
                },
                toJSON: function(t) {
                    const e = mp.prototype.toJSON.call(this, t);
                    return e
                }
            });
            const Ip = new Yn,
                Np = new Yn;

            function Dp() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new ji, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ji, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                    focus: null,
                    fov: null,
                    aspect: null,
                    near: null,
                    far: null,
                    zoom: null,
                    eyeSep: null
                }
            }
            Object.assign(Dp.prototype, {
                update: function(t) {
                    const e = this._cache,
                        n = e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep;
                    if (n) {
                        e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;
                        const n = t.projectionMatrix.clone(),
                            r = e.eyeSep / 2,
                            i = r * e.near / e.focus,
                            o = e.near * Math.tan(ln.DEG2RAD * e.fov * .5) / e.zoom;
                        let a, s;
                        Np.elements[12] = -r, Ip.elements[12] = r, a = -o * e.aspect + i, s = o * e.aspect + i, n.elements[0] = 2 * e.near / (s - a), n.elements[8] = (s + a) / (s - a), this.cameraL.projectionMatrix.copy(n), a = -o * e.aspect - i, s = o * e.aspect - i, n.elements[0] = 2 * e.near / (s - a), n.elements[8] = (s + a) / (s - a), this.cameraR.projectionMatrix.copy(n)
                    }
                    this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Np), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Ip)
                }
            });
            class kp {
                constructor(t) {
                    this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                }
                start() {
                    this.startTime = ("undefined" === typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                }
                stop() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                }
                getElapsedTime() {
                    return this.getDelta(), this.elapsedTime
                }
                getDelta() {
                    let t = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        const e = ("undefined" === typeof performance ? Date : performance).now();
                        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                    }
                    return t
                }
            }
            class Fp extends _r {
                constructor(t) {
                    super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                }
                getOutput() {
                    return this.gain
                }
                setNodeSource(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                }
                setMediaElementSource(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
                }
                setMediaStreamSource(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
                }
                setBuffer(t) {
                    return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                }
                play(t) {
                    if (void 0 === t && (t = 0), !0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                    if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                    this._startedAt = this.context.currentTime + t;
                    const e = this.context.createBufferSource();
                    return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                pause() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                stop() {
                    if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                connect() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this._connected = !0, this
                }
                disconnect() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this._connected = !1, this
                }
                getFilters() {
                    return this.filters
                }
                setFilters(t) {
                    return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
                }
                setDetune(t) {
                    if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                }
                getDetune() {
                    return this.detune
                }
                getFilter() {
                    return this.getFilters()[0]
                }
                setFilter(t) {
                    return this.setFilters(t ? [t] : [])
                }
                setPlaybackRate(t) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                getPlaybackRate() {
                    return this.playbackRate
                }
                onEnded() {
                    this.isPlaying = !1
                }
                getLoop() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                }
                setLoop(t) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                setLoopStart(t) {
                    return this.loopStart = t, this
                }
                setLoopEnd(t) {
                    return this.loopEnd = t, this
                }
                getVolume() {
                    return this.gain.gain.value
                }
                setVolume(t) {
                    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                }
            }
            class Bp {
                constructor(t, e) {
                    this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
                }
                getFrequencyData() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                }
                getAverageFrequency() {
                    let t = 0;
                    const e = this.getFrequencyData();
                    for (let n = 0; n < e.length; n++) t += e[n];
                    return t / e.length
                }
            }

            function Up(t, e, n) {
                let r, i, o;
                switch (this.binding = t, this.valueSize = n, e) {
                    case "quaternion":
                        r = this._slerp, i = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                        break;
                    case "string":
                    case "bool":
                        r = this._select, i = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                        break;
                    default:
                        r = this._lerp, i = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                }
                this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
            }
            Object.assign(Up.prototype, {
                accumulate: function(t, e) {
                    const n = this.buffer,
                        r = this.valueSize,
                        i = t * r + r;
                    let o = this.cumulativeWeight;
                    if (0 === o) {
                        for (let t = 0; t !== r; ++t) n[i + t] = n[t];
                        o = e
                    } else {
                        o += e;
                        const t = e / o;
                        this._mixBufferRegion(n, i, 0, t, r)
                    }
                    this.cumulativeWeight = o
                },
                accumulateAdditive: function(t) {
                    const e = this.buffer,
                        n = this.valueSize,
                        r = n * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, r, 0, t, n), this.cumulativeWeightAdditive += t
                },
                apply: function(t) {
                    const e = this.valueSize,
                        n = this.buffer,
                        r = t * e + e,
                        i = this.cumulativeWeight,
                        o = this.cumulativeWeightAdditive,
                        a = this.binding;
                    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) {
                        const t = e * this._origIndex;
                        this._mixBufferRegion(n, r, t, 1 - i, e)
                    }
                    o > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e);
                    for (let s = e, c = e + e; s !== c; ++s)
                        if (n[s] !== n[s + e]) {
                            a.setValue(n, r);
                            break
                        }
                },
                saveOriginalState: function() {
                    const t = this.binding,
                        e = this.buffer,
                        n = this.valueSize,
                        r = n * this._origIndex;
                    t.getValue(e, r);
                    for (let i = n, o = r; i !== o; ++i) e[i] = e[r + i % n];
                    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                },
                restoreOriginalState: function() {
                    const t = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, t)
                },
                _setAdditiveIdentityNumeric: function() {
                    const t = this._addIndex * this.valueSize,
                        e = t + this.valueSize;
                    for (let n = t; n < e; n++) this.buffer[n] = 0
                },
                _setAdditiveIdentityQuaternion: function() {
                    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                },
                _setAdditiveIdentityOther: function() {
                    const t = this._origIndex * this.valueSize,
                        e = this._addIndex * this.valueSize;
                    for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
                },
                _select: function(t, e, n, r, i) {
                    if (r >= .5)
                        for (let o = 0; o !== i; ++o) t[e + o] = t[n + o]
                },
                _slerp: function(t, e, n, r) {
                    _n.slerpFlat(t, e, t, e, t, n, r)
                },
                _slerpAdditive: function(t, e, n, r, i) {
                    const o = this._workIndex * i;
                    _n.multiplyQuaternionsFlat(t, o, t, e, t, n), _n.slerpFlat(t, e, t, e, t, o, r)
                },
                _lerp: function(t, e, n, r, i) {
                    const o = 1 - r;
                    for (let a = 0; a !== i; ++a) {
                        const i = e + a;
                        t[i] = t[i] * o + t[n + a] * r
                    }
                },
                _lerpAdditive: function(t, e, n, r, i) {
                    for (let o = 0; o !== i; ++o) {
                        const i = e + o;
                        t[i] = t[i] + t[n + o] * r
                    }
                }
            });
            const Hp = "\\[\\]\\.:\\/",
                zp = new RegExp("[" + Hp + "]", "g"),
                jp = "[^" + Hp + "]",
                Gp = "[^" + Hp.replace("\\.", "") + "]",
                Vp = /((?:WC+[\/:])*)/.source.replace("WC", jp),
                Wp = /(WCOD+)?/.source.replace("WCOD", Gp),
                Xp = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", jp),
                qp = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", jp),
                Yp = new RegExp("^" + Vp + Wp + Xp + qp + "$"),
                $p = ["material", "materials", "bones"];

            function Zp(t, e, n) {
                const r = n || Jp.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, r)
            }

            function Jp(t, e, n) {
                this.path = e, this.parsedPath = n || Jp.parseTrackName(e), this.node = Jp.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
            }

            function Kp() {
                this.uuid = ln.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                const t = {};
                this._indicesByUUID = t;
                for (let n = 0, r = arguments.length; n !== r; ++n) t[arguments[n].uuid] = n;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                const e = this;
                this.stats = {
                    objects: {
                        get total() {
                            return e._objects.length
                        },
                        get inUse() {
                            return this.total - e.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return e._bindings.length
                    }
                }
            }
            Object.assign(Zp.prototype, {
                getValue: function(t, e) {
                    this.bind();
                    const n = this._targetGroup.nCachedObjects_,
                        r = this._bindings[n];
                    void 0 !== r && r.getValue(t, e)
                },
                setValue: function(t, e) {
                    const n = this._bindings;
                    for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(t, e)
                },
                bind: function() {
                    const t = this._bindings;
                    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
                },
                unbind: function() {
                    const t = this._bindings;
                    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
                }
            }), Object.assign(Jp, {
                Composite: Zp,
                create: function(t, e, n) {
                    return t && t.isAnimationObjectGroup ? new Jp.Composite(t, e, n) : new Jp(t, e, n)
                },
                sanitizeNodeName: function(t) {
                    return t.replace(/\s/g, "_").replace(zp, "")
                },
                parseTrackName: function(t) {
                    const e = Yp.exec(t);
                    if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                    const n = {
                            nodeName: e[2],
                            objectName: e[3],
                            objectIndex: e[4],
                            propertyName: e[5],
                            propertyIndex: e[6]
                        },
                        r = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== r && -1 !== r) {
                        const t = n.nodeName.substring(r + 1); - 1 !== $p.indexOf(t) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = t)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                    return n
                },
                findNode: function(t, e) {
                    if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                    if (t.skeleton) {
                        const n = t.skeleton.getBoneByName(e);
                        if (void 0 !== n) return n
                    }
                    if (t.children) {
                        const n = function(t) {
                                for (let r = 0; r < t.length; r++) {
                                    const i = t[r];
                                    if (i.name === e || i.uuid === e) return i;
                                    const o = n(i.children);
                                    if (o) return o
                                }
                                return null
                            },
                            r = n(t.children);
                        if (r) return r
                    }
                    return null
                }
            }), Object.assign(Jp.prototype, {
                _getValue_unavailable: function() {},
                _setValue_unavailable: function() {},
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [function(t, e) {
                    t[e] = this.node[this.propertyName]
                }, function(t, e) {
                    const n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) t[e++] = n[r]
                }, function(t, e) {
                    t[e] = this.resolvedProperty[this.propertyIndex]
                }, function(t, e) {
                    this.resolvedProperty.toArray(t, e)
                }],
                SetterByBindingTypeAndVersioning: [
                    [function(t, e) {
                        this.targetObject[this.propertyName] = t[e]
                    }, function(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        const n = this.resolvedProperty;
                        for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++]
                    }, function(t, e) {
                        const n = this.resolvedProperty;
                        for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                        this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        const n = this.resolvedProperty;
                        for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e]
                    }, function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        this.resolvedProperty.fromArray(t, e)
                    }, function(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                    }]
                ],
                getValue: function(t, e) {
                    this.bind(), this.getValue(t, e)
                },
                setValue: function(t, e) {
                    this.bind(), this.setValue(t, e)
                },
                bind: function() {
                    let t = this.node;
                    const e = this.parsedPath,
                        n = e.objectName,
                        r = e.propertyName;
                    let i = e.propertyIndex;
                    if (t || (t = Jp.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                    if (n) {
                        let r = e.objectIndex;
                        switch (n) {
                            case "materials":
                                if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                t = t.skeleton.bones;
                                for (let e = 0; e < t.length; e++)
                                    if (t[e].name === r) {
                                        r = e;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                t = t[n]
                        }
                        if (void 0 !== r) {
                            if (void 0 === t[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                            t = t[r]
                        }
                    }
                    const o = t[r];
                    if (void 0 === o) {
                        const n = e.nodeName;
                        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", t)
                    }
                    let a = this.Versioning.None;
                    this.targetObject = t, void 0 !== t.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                    let s = this.BindingType.Direct;
                    if (void 0 !== i) {
                        if ("morphTargetInfluences" === r) {
                            if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            void 0 !== t.morphTargetDictionary[i] && (i = t.morphTargetDictionary[i])
                        }
                        s = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = i
                    } else void 0 !== o.fromArray && void 0 !== o.toArray ? (s = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (s = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
                    this.getValue = this.GetterByBindingType[s], this.setValue = this.SetterByBindingTypeAndVersioning[s][a]
                },
                unbind: function() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }), Object.assign(Jp.prototype, {
                _getValue_unbound: Jp.prototype.getValue,
                _setValue_unbound: Jp.prototype.setValue
            }), Object.assign(Kp.prototype, {
                isAnimationObjectGroup: !0,
                add: function() {
                    const t = this._objects,
                        e = this._indicesByUUID,
                        n = this._paths,
                        r = this._parsedPaths,
                        i = this._bindings,
                        o = i.length;
                    let a = void 0,
                        s = t.length,
                        c = this.nCachedObjects_;
                    for (let l = 0, u = arguments.length; l !== u; ++l) {
                        const u = arguments[l],
                            h = u.uuid;
                        let d = e[h];
                        if (void 0 === d) {
                            d = s++, e[h] = d, t.push(u);
                            for (let t = 0, e = o; t !== e; ++t) i[t].push(new Jp(u, n[t], r[t]))
                        } else if (d < c) {
                            a = t[d];
                            const s = --c,
                                l = t[s];
                            e[l.uuid] = d, t[d] = l, e[h] = s, t[s] = u;
                            for (let t = 0, e = o; t !== e; ++t) {
                                const e = i[t],
                                    o = e[s];
                                let a = e[d];
                                e[d] = o, void 0 === a && (a = new Jp(u, n[t], r[t])), e[s] = a
                            }
                        } else t[d] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                    }
                    this.nCachedObjects_ = c
                },
                remove: function() {
                    const t = this._objects,
                        e = this._indicesByUUID,
                        n = this._bindings,
                        r = n.length;
                    let i = this.nCachedObjects_;
                    for (let o = 0, a = arguments.length; o !== a; ++o) {
                        const a = arguments[o],
                            s = a.uuid,
                            c = e[s];
                        if (void 0 !== c && c >= i) {
                            const o = i++,
                                l = t[o];
                            e[l.uuid] = c, t[c] = l, e[s] = o, t[o] = a;
                            for (let t = 0, e = r; t !== e; ++t) {
                                const e = n[t],
                                    r = e[o],
                                    i = e[c];
                                e[c] = r, e[o] = i
                            }
                        }
                    }
                    this.nCachedObjects_ = i
                },
                uncache: function() {
                    const t = this._objects,
                        e = this._indicesByUUID,
                        n = this._bindings,
                        r = n.length;
                    let i = this.nCachedObjects_,
                        o = t.length;
                    for (let a = 0, s = arguments.length; a !== s; ++a) {
                        const s = arguments[a],
                            c = s.uuid,
                            l = e[c];
                        if (void 0 !== l)
                            if (delete e[c], l < i) {
                                const a = --i,
                                    s = t[a],
                                    c = --o,
                                    u = t[c];
                                e[s.uuid] = l, t[l] = s, e[u.uuid] = a, t[a] = u, t.pop();
                                for (let t = 0, e = r; t !== e; ++t) {
                                    const e = n[t],
                                        r = e[a],
                                        i = e[c];
                                    e[l] = r, e[a] = i, e.pop()
                                }
                            } else {
                                const i = --o,
                                    a = t[i];
                                i > 0 && (e[a.uuid] = l), t[l] = a, t.pop();
                                for (let t = 0, e = r; t !== e; ++t) {
                                    const e = n[t];
                                    e[l] = e[i], e.pop()
                                }
                            }
                    }
                    this.nCachedObjects_ = i
                },
                subscribe_: function(t, e) {
                    const n = this._bindingsIndicesByPath;
                    let r = n[t];
                    const i = this._bindings;
                    if (void 0 !== r) return i[r];
                    const o = this._paths,
                        a = this._parsedPaths,
                        s = this._objects,
                        c = s.length,
                        l = this.nCachedObjects_,
                        u = new Array(c);
                    r = i.length, n[t] = r, o.push(t), a.push(e), i.push(u);
                    for (let h = l, d = s.length; h !== d; ++h) {
                        const n = s[h];
                        u[h] = new Jp(n, t, e)
                    }
                    return u
                },
                unsubscribe_: function(t) {
                    const e = this._bindingsIndicesByPath,
                        n = e[t];
                    if (void 0 !== n) {
                        const r = this._paths,
                            i = this._parsedPaths,
                            o = this._bindings,
                            a = o.length - 1,
                            s = o[a],
                            c = t[a];
                        e[c] = n, o[n] = s, o.pop(), i[n] = i[a], i.pop(), r[n] = r[a], r.pop()
                    }
                }
            });
            class Qp {
                constructor(t, e, n, r) {
                    this._mixer = t, this._clip = e, this._localRoot = n || null, this.blendMode = r || e.blendMode;
                    const i = e.tracks,
                        o = i.length,
                        a = new Array(o),
                        s = {
                            endingStart: Ne,
                            endingEnd: Ne
                        };
                    for (let c = 0; c !== o; ++c) {
                        const t = i[c].createInterpolant(null);
                        a[c] = t, t.settings = s
                    }
                    this._interpolantSettings = s, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Re, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                }
                play() {
                    return this._mixer._activateAction(this), this
                }
                stop() {
                    return this._mixer._deactivateAction(this), this.reset()
                }
                reset() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                }
                isRunning() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                }
                isScheduled() {
                    return this._mixer._isActiveAction(this)
                }
                startAt(t) {
                    return this._startTime = t, this
                }
                setLoop(t, e) {
                    return this.loop = t, this.repetitions = e, this
                }
                setEffectiveWeight(t) {
                    return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                }
                getEffectiveWeight() {
                    return this._effectiveWeight
                }
                fadeIn(t) {
                    return this._scheduleFading(t, 0, 1)
                }
                fadeOut(t) {
                    return this._scheduleFading(t, 1, 0)
                }
                crossFadeFrom(t, e, n) {
                    if (t.fadeOut(e), this.fadeIn(e), n) {
                        const n = this._clip.duration,
                            r = t._clip.duration,
                            i = r / n,
                            o = n / r;
                        t.warp(1, i, e), this.warp(o, 1, e)
                    }
                    return this
                }
                crossFadeTo(t, e, n) {
                    return t.crossFadeFrom(this, e, n)
                }
                stopFading() {
                    const t = this._weightInterpolant;
                    return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                }
                setEffectiveTimeScale(t) {
                    return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                }
                getEffectiveTimeScale() {
                    return this._effectiveTimeScale
                }
                setDuration(t) {
                    return this.timeScale = this._clip.duration / t, this.stopWarping()
                }
                syncWith(t) {
                    return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                }
                halt(t) {
                    return this.warp(this._effectiveTimeScale, 0, t)
                }
                warp(t, e, n) {
                    const r = this._mixer,
                        i = r.time,
                        o = this.timeScale;
                    let a = this._timeScaleInterpolant;
                    null === a && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a);
                    const s = a.parameterPositions,
                        c = a.sampleValues;
                    return s[0] = i, s[1] = i + n, c[0] = t / o, c[1] = e / o, this
                }
                stopWarping() {
                    const t = this._timeScaleInterpolant;
                    return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                }
                getMixer() {
                    return this._mixer
                }
                getClip() {
                    return this._clip
                }
                getRoot() {
                    return this._localRoot || this._mixer._root
                }
                _update(t, e, n, r) {
                    if (!this.enabled) return void this._updateWeight(t);
                    const i = this._startTime;
                    if (null !== i) {
                        const r = (t - i) * n;
                        if (r < 0 || 0 === n) return;
                        this._startTime = null, e = n * r
                    }
                    e *= this._updateTimeScale(t);
                    const o = this._updateTime(e),
                        a = this._updateWeight(t);
                    if (a > 0) {
                        const t = this._interpolants,
                            e = this._propertyBindings;
                        switch (this.blendMode) {
                            case Be:
                                for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(o), e[n].accumulateAdditive(a);
                                break;
                            case Fe:
                            default:
                                for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(o), e[n].accumulate(r, a)
                        }
                    }
                }
                _updateWeight(t) {
                    let e = 0;
                    if (this.enabled) {
                        e = this.weight;
                        const n = this._weightInterpolant;
                        if (null !== n) {
                            const r = n.evaluate(t)[0];
                            e *= r, t > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = e, e
                }
                _updateTimeScale(t) {
                    let e = 0;
                    if (!this.paused) {
                        e = this.timeScale;
                        const n = this._timeScaleInterpolant;
                        if (null !== n) {
                            const r = n.evaluate(t)[0];
                            e *= r, t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                        }
                    }
                    return this._effectiveTimeScale = e, e
                }
                _updateTime(t) {
                    const e = this._clip.duration,
                        n = this.loop;
                    let r = this.time + t,
                        i = this._loopCount;
                    const o = n === Ce;
                    if (0 === t) return -1 === i ? r : o && 1 === (1 & i) ? e - r : r;
                    if (n === Le) {
                        -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        t: {
                            if (r >= e) r = e;
                            else {
                                if (!(r < 0)) {
                                    this.time = r;
                                    break t
                                }
                                r = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this.time = r,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (-1 === i && (t >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), r >= e || r < 0) {
                            const n = Math.floor(r / e);
                            r -= e * n, i += Math.abs(n);
                            const a = this.repetitions - i;
                            if (a <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = t > 0 ? e : 0, this.time = r, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t > 0 ? 1 : -1
                            });
                            else {
                                if (1 === a) {
                                    const e = t < 0;
                                    this._setEndings(e, !e, o)
                                } else this._setEndings(!1, !1, o);
                                this._loopCount = i, this.time = r, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: n
                                })
                            }
                        } else this.time = r;
                        if (o && 1 === (1 & i)) return e - r
                    }
                    return r
                }
                _setEndings(t, e, n) {
                    const r = this._interpolantSettings;
                    n ? (r.endingStart = De, r.endingEnd = De) : (r.endingStart = t ? this.zeroSlopeAtStart ? De : Ne : ke, r.endingEnd = e ? this.zeroSlopeAtEnd ? De : Ne : ke)
                }
                _scheduleFading(t, e, n) {
                    const r = this._mixer,
                        i = r.time;
                    let o = this._weightInterpolant;
                    null === o && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
                    const a = o.parameterPositions,
                        s = o.sampleValues;
                    return a[0] = i, s[0] = e, a[1] = i + t, s[1] = n, this
                }
            }

            function tf(t) {
                this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }
            tf.prototype = Object.assign(Object.create(an.prototype), {
                constructor: tf,
                _bindAction: function(t, e) {
                    const n = t._localRoot || this._root,
                        r = t._clip.tracks,
                        i = r.length,
                        o = t._propertyBindings,
                        a = t._interpolants,
                        s = n.uuid,
                        c = this._bindingsByRootAndName;
                    let l = c[s];
                    void 0 === l && (l = {}, c[s] = l);
                    for (let u = 0; u !== i; ++u) {
                        const t = r[u],
                            i = t.name;
                        let c = l[i];
                        if (void 0 !== c) o[u] = c;
                        else {
                            if (c = o[u], void 0 !== c) {
                                null === c._cacheIndex && (++c.referenceCount, this._addInactiveBinding(c, s, i));
                                continue
                            }
                            const r = e && e._propertyBindings[u].binding.parsedPath;
                            c = new Up(Jp.create(n, i, r), t.ValueTypeName, t.getValueSize()), ++c.referenceCount, this._addInactiveBinding(c, s, i), o[u] = c
                        }
                        a[u].resultBuffer = c.buffer
                    }
                },
                _activateAction: function(t) {
                    if (!this._isActiveAction(t)) {
                        if (null === t._cacheIndex) {
                            const e = (t._localRoot || this._root).uuid,
                                n = t._clip.uuid,
                                r = this._actionsByClip[n];
                            this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, n, e)
                        }
                        const e = t._propertyBindings;
                        for (let t = 0, n = e.length; t !== n; ++t) {
                            const n = e[t];
                            0 === n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                        }
                        this._lendAction(t)
                    }
                },
                _deactivateAction: function(t) {
                    if (this._isActiveAction(t)) {
                        const e = t._propertyBindings;
                        for (let t = 0, n = e.length; t !== n; ++t) {
                            const n = e[t];
                            0 === --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                        }
                        this._takeBackAction(t)
                    }
                },
                _initMemoryManager: function() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    const t = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return t._actions.length
                            },
                            get inUse() {
                                return t._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return t._bindings.length
                            },
                            get inUse() {
                                return t._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return t._controlInterpolants.length
                            },
                            get inUse() {
                                return t._nActiveControlInterpolants
                            }
                        }
                    }
                },
                _isActiveAction: function(t) {
                    const e = t._cacheIndex;
                    return null !== e && e < this._nActiveActions
                },
                _addInactiveAction: function(t, e, n) {
                    const r = this._actions,
                        i = this._actionsByClip;
                    let o = i[e];
                    if (void 0 === o) o = {
                        knownActions: [t],
                        actionByRoot: {}
                    }, t._byClipCacheIndex = 0, i[e] = o;
                    else {
                        const e = o.knownActions;
                        t._byClipCacheIndex = e.length, e.push(t)
                    }
                    t._cacheIndex = r.length, r.push(t), o.actionByRoot[n] = t
                },
                _removeInactiveAction: function(t) {
                    const e = this._actions,
                        n = e[e.length - 1],
                        r = t._cacheIndex;
                    n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null;
                    const i = t._clip.uuid,
                        o = this._actionsByClip,
                        a = o[i],
                        s = a.knownActions,
                        c = s[s.length - 1],
                        l = t._byClipCacheIndex;
                    c._byClipCacheIndex = l, s[l] = c, s.pop(), t._byClipCacheIndex = null;
                    const u = a.actionByRoot,
                        h = (t._localRoot || this._root).uuid;
                    delete u[h], 0 === s.length && delete o[i], this._removeInactiveBindingsForAction(t)
                },
                _removeInactiveBindingsForAction: function(t) {
                    const e = t._propertyBindings;
                    for (let n = 0, r = e.length; n !== r; ++n) {
                        const t = e[n];
                        0 === --t.referenceCount && this._removeInactiveBinding(t)
                    }
                },
                _lendAction: function(t) {
                    const e = this._actions,
                        n = t._cacheIndex,
                        r = this._nActiveActions++,
                        i = e[r];
                    t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
                },
                _takeBackAction: function(t) {
                    const e = this._actions,
                        n = t._cacheIndex,
                        r = --this._nActiveActions,
                        i = e[r];
                    t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
                },
                _addInactiveBinding: function(t, e, n) {
                    const r = this._bindingsByRootAndName,
                        i = this._bindings;
                    let o = r[e];
                    void 0 === o && (o = {}, r[e] = o), o[n] = t, t._cacheIndex = i.length, i.push(t)
                },
                _removeInactiveBinding: function(t) {
                    const e = this._bindings,
                        n = t.binding,
                        r = n.rootNode.uuid,
                        i = n.path,
                        o = this._bindingsByRootAndName,
                        a = o[r],
                        s = e[e.length - 1],
                        c = t._cacheIndex;
                    s._cacheIndex = c, e[c] = s, e.pop(), delete a[i], 0 === Object.keys(a).length && delete o[r]
                },
                _lendBinding: function(t) {
                    const e = this._bindings,
                        n = t._cacheIndex,
                        r = this._nActiveBindings++,
                        i = e[r];
                    t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
                },
                _takeBackBinding: function(t) {
                    const e = this._bindings,
                        n = t._cacheIndex,
                        r = --this._nActiveBindings,
                        i = e[r];
                    t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
                },
                _lendControlInterpolant: function() {
                    const t = this._controlInterpolants,
                        e = this._nActiveControlInterpolants++;
                    let n = t[e];
                    return void 0 === n && (n = new ed(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
                },
                _takeBackControlInterpolant: function(t) {
                    const e = this._controlInterpolants,
                        n = t.__cacheIndex,
                        r = --this._nActiveControlInterpolants,
                        i = e[r];
                    t.__cacheIndex = r, e[r] = t, i.__cacheIndex = n, e[n] = i
                },
                _controlInterpolantsResultBuffer: new Float32Array(1),
                clipAction: function(t, e, n) {
                    const r = e || this._root,
                        i = r.uuid;
                    let o = "string" === typeof t ? hd.findByName(r, t) : t;
                    const a = null !== o ? o.uuid : t,
                        s = this._actionsByClip[a];
                    let c = null;
                    if (void 0 === n && (n = null !== o ? o.blendMode : Fe), void 0 !== s) {
                        const t = s.actionByRoot[i];
                        if (void 0 !== t && t.blendMode === n) return t;
                        c = s.knownActions[0], null === o && (o = c._clip)
                    }
                    if (null === o) return null;
                    const l = new Qp(this, o, e, n);
                    return this._bindAction(l, c), this._addInactiveAction(l, a, i), l
                },
                existingAction: function(t, e) {
                    const n = e || this._root,
                        r = n.uuid,
                        i = "string" === typeof t ? hd.findByName(n, t) : t,
                        o = i ? i.uuid : t,
                        a = this._actionsByClip[o];
                    return void 0 !== a && a.actionByRoot[r] || null
                },
                stopAllAction: function() {
                    const t = this._actions,
                        e = this._nActiveActions;
                    for (let n = e - 1; n >= 0; --n) t[n].stop();
                    return this
                },
                update: function(t) {
                    t *= this.timeScale;
                    const e = this._actions,
                        n = this._nActiveActions,
                        r = this.time += t,
                        i = Math.sign(t),
                        o = this._accuIndex ^= 1;
                    for (let c = 0; c !== n; ++c) {
                        const n = e[c];
                        n._update(r, t, i, o)
                    }
                    const a = this._bindings,
                        s = this._nActiveBindings;
                    for (let c = 0; c !== s; ++c) a[c].apply(o);
                    return this
                },
                setTime: function(t) {
                    this.time = 0;
                    for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
                    return this.update(t)
                },
                getRoot: function() {
                    return this._root
                },
                uncacheClip: function(t) {
                    const e = this._actions,
                        n = t.uuid,
                        r = this._actionsByClip,
                        i = r[n];
                    if (void 0 !== i) {
                        const t = i.knownActions;
                        for (let n = 0, r = t.length; n !== r; ++n) {
                            const r = t[n];
                            this._deactivateAction(r);
                            const i = r._cacheIndex,
                                o = e[e.length - 1];
                            r._cacheIndex = null, r._byClipCacheIndex = null, o._cacheIndex = i, e[i] = o, e.pop(), this._removeInactiveBindingsForAction(r)
                        }
                        delete r[n]
                    }
                },
                uncacheRoot: function(t) {
                    const e = t.uuid,
                        n = this._actionsByClip;
                    for (const o in n) {
                        const t = n[o].actionByRoot,
                            r = t[e];
                        void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                    }
                    const r = this._bindingsByRootAndName,
                        i = r[e];
                    if (void 0 !== i)
                        for (const o in i) {
                            const t = i[o];
                            t.restoreOriginalState(), this._removeInactiveBinding(t)
                        }
                },
                uncacheAction: function(t, e) {
                    const n = this.existingAction(t, e);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                }
            });
            class ef {
                constructor(t) {
                    "string" === typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
                }
                clone() {
                    return new ef(void 0 === this.value.clone ? this.value : this.value.clone())
                }
            }

            function nf(t, e, n) {
                jl.call(this, t, e), this.meshPerAttribute = n || 1
            }

            function rf(t, e, n, r, i) {
                this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0
            }

            function of (t, e, n, r) {
                this.ray = new qn(t, e), this.near = n || 0, this.far = r || 1 / 0, this.camera = null, this.layers = new or, this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }, Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                        }
                    }
                })
            }

            function af(t, e) {
                return t.distance - e.distance
            }

            function sf(t, e, n, r) {
                if (t.layers.test(e.layers) && t.raycast(e, n), !0 === r) {
                    const r = t.children;
                    for (let t = 0, i = r.length; t < i; t++) sf(r[t], e, n, !0)
                }
            }
            nf.prototype = Object.assign(Object.create(jl.prototype), {
                constructor: nf,
                isInstancedInterleavedBuffer: !0,
                copy: function(t) {
                    return jl.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                },
                clone: function(t) {
                    const e = jl.prototype.clone.call(this, t);
                    return e.meshPerAttribute = this.meshPerAttribute, e
                },
                toJSON: function(t) {
                    const e = jl.prototype.toJSON.call(this, t);
                    return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
                }
            }), Object.defineProperty(rf.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(rf.prototype, {
                isGLBufferAttribute: !0,
                setBuffer: function(t) {
                    return this.buffer = t, this
                },
                setType: function(t, e) {
                    return this.type = t, this.elementSize = e, this
                },
                setItemSize: function(t) {
                    return this.itemSize = t, this
                },
                setCount: function(t) {
                    return this.count = t, this
                }
            }), Object.assign( of .prototype, {
                set: function(t, e) {
                    this.ray.set(t, e)
                },
                setFromCamera: function(t, e) {
                    e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type.")
                },
                intersectObject: function(t, e, n) {
                    const r = n || [];
                    return sf(t, this, r, e), r.sort(af), r
                },
                intersectObjects: function(t, e, n) {
                    const r = n || [];
                    if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), r;
                    for (let i = 0, o = t.length; i < o; i++) sf(t[i], this, r, e);
                    return r.sort(af), r
                }
            });
            class cf {
                constructor(t = 1, e = 0, n = 0) {
                    return this.radius = t, this.phi = e, this.theta = n, this
                }
                set(t, e, n) {
                    return this.radius = t, this.phi = e, this.theta = n, this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
                }
                makeSafe() {
                    const t = 1e-6;
                    return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this
                }
                setFromVector3(t) {
                    return this.setFromCartesianCoords(t.x, t.y, t.z)
                }
                setFromCartesianCoords(t, e, n) {
                    return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(ln.clamp(e / this.radius, -1, 1))), this
                }
            }
            const lf = new un;
            class uf {
                constructor(t, e) {
                    Object.defineProperty(this, "isBox2", {
                        value: !0
                    }), this.min = void 0 !== t ? t : new un(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new un(-1 / 0, -1 / 0)
                }
                set(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                }
                setFromPoints(t) {
                    this.makeEmpty();
                    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                    return this
                }
                setFromCenterAndSize(t, e) {
                    const n = lf.copy(e).multiplyScalar(.5);
                    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                }
                getCenter(t) {
                    return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new un), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(t) {
                    return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new un), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                }
                expandByPoint(t) {
                    return this.min.min(t), this.max.max(t), this
                }
                expandByVector(t) {
                    return this.min.sub(t), this.max.add(t), this
                }
                expandByScalar(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                }
                containsPoint(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                }
                containsBox(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                }
                getParameter(t, e) {
                    return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new un), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                }
                intersectsBox(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                }
                clampPoint(t, e) {
                    return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new un), e.copy(t).clamp(this.min, this.max)
                }
                distanceToPoint(t) {
                    const e = lf.copy(t).clamp(this.min, this.max);
                    return e.sub(t).length()
                }
                intersect(t) {
                    return this.min.max(t.min), this.max.min(t.max), this
                }
                union(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                }
                translate(t) {
                    return this.min.add(t), this.max.add(t), this
                }
                equals(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }
            const hf = new bn,
                df = new bn;
            class pf {
                constructor(t, e) {
                    this.start = void 0 !== t ? t : new bn, this.end = void 0 !== e ? e : new bn
                }
                set(t, e) {
                    return this.start.copy(t), this.end.copy(e), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.start.copy(t.start), this.end.copy(t.end), this
                }
                getCenter(t) {
                    return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new bn), t.addVectors(this.start, this.end).multiplyScalar(.5)
                }
                delta(t) {
                    return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new bn), t.subVectors(this.end, this.start)
                }
                distanceSq() {
                    return this.start.distanceToSquared(this.end)
                }
                distance() {
                    return this.start.distanceTo(this.end)
                }
                at(t, e) {
                    return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new bn), this.delta(e).multiplyScalar(t).add(this.start)
                }
                closestPointToPointParameter(t, e) {
                    hf.subVectors(t, this.start), df.subVectors(this.end, this.start);
                    const n = df.dot(df),
                        r = df.dot(hf);
                    let i = r / n;
                    return e && (i = ln.clamp(i, 0, 1)), i
                }
                closestPointToPoint(t, e, n) {
                    const r = this.closestPointToPointParameter(t, e);
                    return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new bn), this.delta(n).multiplyScalar(r).add(this.start)
                }
                applyMatrix4(t) {
                    return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
                }
                equals(t) {
                    return t.start.equals(this.start) && t.end.equals(this.end)
                }
            }

            function ff(t) {
                _r.call(this), this.material = t, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
            }
            ff.prototype = Object.create(_r.prototype), ff.prototype.constructor = ff, ff.prototype.isImmediateRenderObject = !0;
            const mf = new bn,
                gf = new Yn,
                vf = new Yn;
            class yf extends Ru {
                constructor(t) {
                    const e = _f(t),
                        n = new pi,
                        r = [],
                        i = [],
                        o = new zr(0, 0, 1),
                        a = new zr(0, 1, 0);
                    for (let c = 0; c < e.length; c++) {
                        const t = e[c];
                        t.parent && t.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(o.r, o.g, o.b), i.push(a.r, a.g, a.b))
                    }
                    n.setAttribute("position", new ni(r, 3)), n.setAttribute("color", new ni(i, 3));
                    const s = new bu({
                        vertexColors: !0,
                        depthTest: !1,
                        depthWrite: !1,
                        toneMapped: !1,
                        transparent: !0
                    });
                    super(n, s), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
                }
                updateMatrixWorld(t) {
                    const e = this.bones,
                        n = this.geometry,
                        r = n.getAttribute("position");
                    vf.getInverse(this.root.matrixWorld);
                    for (let i = 0, o = 0; i < e.length; i++) {
                        const t = e[i];
                        t.parent && t.parent.isBone && (gf.multiplyMatrices(vf, t.matrixWorld), mf.setFromMatrixPosition(gf), r.setXYZ(o, mf.x, mf.y, mf.z), gf.multiplyMatrices(vf, t.parent.matrixWorld), mf.setFromMatrixPosition(gf), r.setXYZ(o + 1, mf.x, mf.y, mf.z), o += 2)
                    }
                    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
                }
            }

            function _f(t) {
                const e = [];
                t && t.isBone && e.push(t);
                for (let n = 0; n < t.children.length; n++) e.push.apply(e, _f(t.children[n]));
                return e
            }
            class bf extends Ru {
                constructor(t, e, n, r) {
                    t = t || 10, e = e || 10, n = new zr(void 0 !== n ? n : 4473924), r = new zr(void 0 !== r ? r : 8947848);
                    const i = e / 2,
                        o = t / e,
                        a = t / 2,
                        s = [],
                        c = [];
                    for (let h = 0, d = 0, p = -a; h <= e; h++, p += o) {
                        s.push(-a, 0, p, a, 0, p), s.push(p, 0, -a, p, 0, a);
                        const t = h === i ? n : r;
                        t.toArray(c, d), d += 3, t.toArray(c, d), d += 3, t.toArray(c, d), d += 3, t.toArray(c, d), d += 3
                    }
                    const l = new pi;
                    l.setAttribute("position", new ni(s, 3)), l.setAttribute("color", new ni(c, 3));
                    const u = new bu({
                        vertexColors: !0,
                        toneMapped: !1
                    });
                    super(l, u), this.type = "GridHelper"
                }
            }
            const xf = new bn,
                wf = new bn,
                Mf = new bn;
            class Tf extends _r {
                constructor(t, e, n) {
                    super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
                    let r = new pi;
                    r.setAttribute("position", new ni([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                    const i = new bu({
                        fog: !1,
                        toneMapped: !1
                    });
                    this.lightPlane = new Eu(r, i), this.add(this.lightPlane), r = new pi, r.setAttribute("position", new ni([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Eu(r, i), this.add(this.targetLine), this.update()
                }
                dispose() {
                    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                }
                update() {
                    xf.setFromMatrixPosition(this.light.matrixWorld), wf.setFromMatrixPosition(this.light.target.matrixWorld), Mf.subVectors(wf, xf), this.lightPlane.lookAt(wf), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(wf), this.targetLine.scale.z = Mf.length()
                }
            }
            const Sf = 4,
                Ef = 8,
                Af = (Math.pow(2, Ef), [.125, .215, .35, .446, .526, .582]),
                Lf = Ef - Sf + 1 + Af.length,
                {
                    _lodPlanes: Rf,
                    _sizeLods: Cf,
                    _sigmas: Of
                } = Pf();
            Math.sqrt(5);

            function Pf() {
                const t = [],
                    e = [],
                    n = [];
                let r = Ef;
                for (let i = 0; i < Lf; i++) {
                    const o = Math.pow(2, r);
                    e.push(o);
                    let a = 1 / o;
                    i > Ef - Sf ? a = Af[i - Ef + Sf - 1] : 0 == i && (a = 0), n.push(a);
                    const s = 1 / (o - 1),
                        c = -s / 2,
                        l = 1 + s / 2,
                        u = [c, c, l, c, l, l, c, c, l, l, c, l],
                        h = 6,
                        d = 6,
                        p = 3,
                        f = 2,
                        m = 1,
                        g = new Float32Array(p * d * h),
                        v = new Float32Array(f * d * h),
                        y = new Float32Array(m * d * h);
                    for (let t = 0; t < h; t++) {
                        const e = t % 3 * 2 / 3 - 1,
                            n = t > 2 ? 0 : -1,
                            r = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                        g.set(r, p * d * t), v.set(u, f * d * t);
                        const i = [t, t, t, t, t, t];
                        y.set(i, m * d * t)
                    }
                    const _ = new pi;
                    _.setAttribute("position", new Yr(g, p)), _.setAttribute("uv", new Yr(v, f)), _.setAttribute("faceIndex", new Yr(y, m)), t.push(_), r > Sf && r--
                }
                return {
                    _lodPlanes: t,
                    _sizeLods: e,
                    _sigmas: n
                }
            }

            function If(t) {
                console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Nd.call(this, t), this.type = "catmullrom", this.closed = !0
            }

            function Nf(t) {
                console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Nd.call(this, t), this.type = "catmullrom"
            }

            function Df(t) {
                console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Nd.call(this, t), this.type = "catmullrom"
            }
            Ed.create = function(t, e) {
                return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Ed.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
            }, Object.assign(Qd.prototype, {
                createPointsGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    const e = this.getPoints(t);
                    return this.createGeometry(e)
                },
                createSpacedPointsGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    const e = this.getSpacedPoints(t);
                    return this.createGeometry(e)
                },
                createGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    const e = new Xu;
                    for (let n = 0, r = t.length; n < r; n++) {
                        const r = t[n];
                        e.vertices.push(new bn(r.x, r.y, r.z || 0))
                    }
                    return e
                }
            }), Object.assign(tp.prototype, {
                fromPoints: function(t) {
                    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
                }
            }), If.prototype = Object.create(Nd.prototype), Nf.prototype = Object.create(Nd.prototype), Df.prototype = Object.create(Nd.prototype), Object.assign(Df.prototype, {
                initFromArray: function() {
                    console.error("THREE.Spline: .initFromArray() has been removed.")
                },
                getControlPointsArray: function() {
                    console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                },
                reparametrizeByArcLength: function() {
                    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                }
            }), bf.prototype.setColors = function() {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, yf.prototype.update = function() {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }, Object.assign(vd.prototype, {
                extractUrlBase: function(t) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), vp.extractUrlBase(t)
                }
            }), vd.Handlers = {
                add: function() {
                    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                },
                get: function() {
                    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                }
            }, Object.assign(uf.prototype, {
                center: function(t) {
                    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
                },
                empty: function() {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                size: function(t) {
                    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
                }
            }), Object.assign(Mn.prototype, {
                center: function(t) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
                },
                empty: function() {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                },
                size: function(t) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
                }
            }), Object.assign(Un.prototype, {
                empty: function() {
                    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                }
            }), Ji.prototype.setFromMatrix = function(t) {
                return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
            }, pf.prototype.center = function(t) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, Object.assign(ln, {
                random16: function() {
                    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
                },
                nearestPowerOfTwo: function(t) {
                    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), ln.floorPowerOfTwo(t)
                },
                nextPowerOfTwo: function(t) {
                    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), ln.ceilPowerOfTwo(t)
                }
            }), Object.assign(hn.prototype, {
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                },
                applyToBufferAttribute: function(t) {
                    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }
            }), Object.assign(Yn.prototype, {
                extractPosition: function(t) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
                },
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                },
                getPosition: function() {
                    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new bn).setFromMatrixColumn(this, 3)
                },
                setRotationFromQuaternion: function(t) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
                },
                multiplyToArray: function() {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                multiplyVector4: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                },
                rotateAxis: function(t) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
                },
                crossVector: function(t) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                translate: function() {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function() {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function() {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function() {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function() {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                },
                applyToBufferAttribute: function(t) {
                    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                },
                makeFrustum: function(t, e, n, r, i, o) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, r, n, i, o)
                }
            }), Mr.prototype.isIntersectionLine = function(t) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
            }, _n.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
            }, Object.assign(qn.prototype, {
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                isIntersectionPlane: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                }
            }), Object.assign(Nr.prototype, {
                area: function() {
                    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
                },
                barycoordFromPoint: function(t, e) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
                },
                midpoint: function(t) {
                    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
                },
                normal: function(t) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
                },
                plane: function(t) {
                    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
                }
            }), Object.assign(Nr, {
                barycoordFromPoint: function(t, e, n, r, i) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Nr.getBarycoord(t, e, n, r, i)
                },
                normal: function(t, e, n, r) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Nr.getNormal(t, e, n, r)
                }
            }), Object.assign(ep.prototype, {
                extractAllPoints: function(t) {
                    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
                },
                extrude: function(t) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Oh(this, t)
                },
                makeGeometry: function(t) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Bh(this, t)
                }
            }), Object.assign(un.prototype, {
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                distanceToManhattan: function(t) {
                    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(bn.prototype, {
                setEulerFromRotationMatrix: function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
                },
                getScaleFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
                },
                getColumnFromMatrix: function(t, e) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
                },
                applyProjection: function(t) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
                },
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                distanceToManhattan: function(t) {
                    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(gn.prototype, {
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Xu.prototype, {
                computeTangents: function() {
                    console.error("THREE.Geometry: .computeTangents() has been removed.")
                },
                computeLineDistances: function() {
                    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
                },
                applyMatrix: function(t) {
                    return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
                }
            }), Object.assign(_r.prototype, {
                getChildByName: function(t) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
                },
                renderDepth: function() {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                },
                translate: function(t, e) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
                },
                getWorldRotation: function() {
                    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                },
                applyMatrix: function(t) {
                    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
                }
            }), Object.defineProperties(_r.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function(t) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), Object.assign(Oi.prototype, {
                setDrawMode: function() {
                    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                }
            }), Object.defineProperties(Oi.prototype, {
                drawMode: {
                    get: function() {
                        return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), Ue
                    },
                    set: function() {
                        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                    }
                }
            }), Object.defineProperties(lu.prototype, {
                objects: {
                    get: function() {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                    }
                }
            }), Object.defineProperty(pu.prototype, "useVertexTexture", {
                get: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                },
                set: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                }
            }), uu.prototype.initBones = function() {
                console.error("THREE.SkinnedMesh: initBones() has been removed.")
            }, Object.defineProperty(Ed.prototype, "__arcLengthDivisions", {
                get: function() {
                    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
                },
                set: function(t) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
                }
            }), ji.prototype.setLens = function(t, e) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
            }, Object.defineProperties(np.prototype, {
                onlyShadow: {
                    set: function() {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                    }
                },
                shadowCameraLeft: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                    }
                },
                shadowCameraRight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                    }
                },
                shadowCameraTop: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                    }
                },
                shadowCameraBottom: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                    }
                },
                shadowCameraNear: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                    }
                },
                shadowCameraFar: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                    }
                },
                shadowCameraVisible: {
                    set: function() {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                    }
                },
                shadowDarkness: {
                    set: function() {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                    }
                },
                shadowMapHeight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                    }
                }
            }), Object.defineProperties(Yr.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                },
                dynamic: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === rn
                    },
                    set: function() {
                        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(rn)
                    }
                }
            }), Object.assign(Yr.prototype, {
                setDynamic: function(t) {
                    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? rn : nn), this
                },
                copyIndicesArray: function() {
                    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                },
                setArray: function() {
                    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
                }
            }), Object.assign(pi.prototype, {
                addIndex: function(t) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
                },
                addAttribute: function(t, e) {
                    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Yr(arguments[1], arguments[2])))
                },
                addDrawCall: function(t, e, n) {
                    void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
                },
                clearDrawCalls: function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                },
                computeTangents: function() {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                },
                computeOffsets: function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                },
                removeAttribute: function(t) {
                    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
                },
                applyMatrix: function(t) {
                    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
                }
            }), Object.defineProperties(pi.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), Object.defineProperties(yp.prototype, {
                maxInstancedCount: {
                    get: function() {
                        return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount
                    },
                    set: function(t) {
                        console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = t
                    }
                }
            }), Object.defineProperties( of .prototype, {
                linePrecision: {
                    get: function() {
                        return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold
                    },
                    set: function(t) {
                        console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = t
                    }
                }
            }), Object.defineProperties(jl.prototype, {
                dynamic: {
                    get: function() {
                        return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === rn
                    },
                    set: function(t) {
                        console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t)
                    }
                }
            }), Object.assign(jl.prototype, {
                setDynamic: function(t) {
                    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? rn : nn), this
                },
                setArray: function() {
                    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
                }
            }), Object.assign(Lh.prototype, {
                getArrays: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
                },
                addShapeList: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
                },
                addShape: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
                }
            }), Object.assign(zl.prototype, {
                dispose: function() {
                    console.error("THREE.Scene: .dispose() has been removed.")
                }
            }), Object.defineProperties(ef.prototype, {
                dynamic: {
                    set: function() {
                        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                    }
                },
                onUpdate: {
                    value: function() {
                        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                    }
                }
            }), Object.defineProperties(Vr.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                overdraw: {
                    get: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new zr
                    }
                },
                shading: {
                    get: function() {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function(t) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t === m
                    }
                },
                stencilMask: {
                    get: function() {
                        return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                    },
                    set: function(t) {
                        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
                    }
                }
            }), Object.defineProperties(Wh.prototype, {
                metal: {
                    get: function() {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }), Object.defineProperties(Vh.prototype, {
                transparency: {
                    get: function() {
                        return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission
                    },
                    set: function(t) {
                        console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = t
                    }
                }
            }), Object.defineProperties(Hi.prototype, {
                derivatives: {
                    get: function() {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function(t) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                    }
                }
            }), Object.assign(Ul.prototype, {
                clearTarget: function(t, e, n, r) {
                    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, r)
                },
                animate: function(t) {
                    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
                },
                getCurrentRenderTarget: function() {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                },
                getMaxAnisotropy: function() {
                    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                },
                getPrecision: function() {
                    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                },
                resetGLState: function() {
                    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                },
                supportsFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function(t) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
                },
                initMaterial: function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                },
                addPrePlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                },
                addPostPlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                },
                updateShadowMap: function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                },
                setFaceCulling: function() {
                    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                },
                allocTextureUnit: function() {
                    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
                },
                setTexture: function() {
                    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
                },
                setTexture2D: function() {
                    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
                },
                setTextureCube: function() {
                    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
                },
                getActiveMipMapLevel: function() {
                    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
                }
            }), Object.defineProperties(Ul.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                context: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                    }
                },
                vr: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                    }
                },
                gammaInput: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                    }
                },
                gammaOutput: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? Ge : je
                    }
                },
                toneMappingWhitePoint: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                    }
                }
            }), Object.defineProperties(Cl.prototype, {
                cullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(vn.prototype, {
                wrapS: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                    }
                },
                wrapT: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                    }
                },
                magFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                    }
                },
                minFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                    }
                },
                anisotropy: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                    }
                },
                offset: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                    }
                },
                repeat: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                    }
                },
                format: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                    }
                },
                type: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                    }
                }
            }), Object.defineProperties(Fp.prototype, {
                load: {
                    value: function(t) {
                        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                        const e = this,
                            n = new Cp;
                        return n.load(t, (function(t) {
                            e.setBuffer(t)
                        })), this
                    }
                },
                startTime: {
                    set: function() {
                        console.warn("THREE.Audio: .startTime is now .play( delay ).")
                    }
                }
            }), Bp.prototype.getData = function() {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
            }, Wi.prototype.updateCubeMap = function(t, e) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
            }, Wi.prototype.clear = function(t, e, n, r) {
                return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, r)
            };
            pn.crossOrigin = void 0, pn.loadTexture = function(t, e, n, r) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                const i = new Sd;
                i.setCrossOrigin(this.crossOrigin);
                const o = i.load(t, n, void 0, r);
                return e && (o.mapping = e), o
            }, pn.loadTextureCube = function(t, e, n, r) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                const i = new Md;
                i.setCrossOrigin(this.crossOrigin);
                const o = i.load(t, n, void 0, r);
                return e && (o.mapping = e), o
            }, pn.loadCompressedTexture = function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, pn.loadCompressedTextureCube = function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            };
            "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: r
                }
            }))
        },
        "5c6c": function(t, e) {
            t.exports = function(t, e) {
                return {
                    enumerable: !(1 & t),
                    configurable: !(2 & t),
                    writable: !(4 & t),
                    value: e
                }
            }
        },
        "5f96": function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = r.aTypedArray,
                o = r.exportTypedArrayMethod,
                a = [].join;
            o("join", (function(t) {
                return a.apply(i(this), arguments)
            }))
        },
        "60bd": function(t, e, n) {
            "use strict";
            var r = n("da84"),
                i = n("ebb5"),
                o = n("e260"),
                a = n("b622"),
                s = a("iterator"),
                c = r.Uint8Array,
                l = o.values,
                u = o.keys,
                h = o.entries,
                d = i.aTypedArray,
                p = i.exportTypedArrayMethod,
                f = c && c.prototype[s],
                m = !!f && ("values" == f.name || void 0 == f.name),
                g = function() {
                    return l.call(d(this))
                };
            p("entries", (function() {
                return h.call(d(this))
            })), p("keys", (function() {
                return u.call(d(this))
            })), p("values", g, !m), p(s, g, !m)
        },
        "60da": function(t, e, n) {
            "use strict";
            var r = n("83ab"),
                i = n("d039"),
                o = n("df75"),
                a = n("7418"),
                s = n("d1e7"),
                c = n("7b0b"),
                l = n("44ad"),
                u = Object.assign,
                h = Object.defineProperty;
            t.exports = !u || i((function() {
                if (r && 1 !== u({
                        b: 1
                    }, u(h({}, "a", {
                        enumerable: !0,
                        get: function() {
                            h(this, "b", {
                                value: 3,
                                enumerable: !1
                            })
                        }
                    }), {
                        b: 2
                    })).b) return !0;
                var t = {},
                    e = {},
                    n = Symbol(),
                    i = "abcdefghijklmnopqrst";
                return t[n] = 7, i.split("").forEach((function(t) {
                    e[t] = t
                })), 7 != u({}, t)[n] || o(u({}, e)).join("") != i
            })) ? function(t, e) {
                var n = c(t),
                    i = arguments.length,
                    u = 1,
                    h = a.f,
                    d = s.f;
                while (i > u) {
                    var p, f = l(arguments[u++]),
                        m = h ? o(f).concat(h(f)) : o(f),
                        g = m.length,
                        v = 0;
                    while (g > v) p = m[v++], r && !d.call(f, p) || (n[p] = f[p])
                }
                return n
            } : u
        },
        "621a": function(t, e, n) {
            "use strict";
            var r = n("da84"),
                i = n("83ab"),
                o = n("a981"),
                a = n("9112"),
                s = n("e2cc"),
                c = n("d039"),
                l = n("19aa"),
                u = n("a691"),
                h = n("50c4"),
                d = n("0b25"),
                p = n("77a7"),
                f = n("e163"),
                m = n("d2bb"),
                g = n("241c").f,
                v = n("9bf2").f,
                y = n("81d5"),
                _ = n("d44e"),
                b = n("69f3"),
                x = b.get,
                w = b.set,
                M = "ArrayBuffer",
                T = "DataView",
                S = "prototype",
                E = "Wrong length",
                A = "Wrong index",
                L = r[M],
                R = L,
                C = r[T],
                O = C && C[S],
                P = Object.prototype,
                I = r.RangeError,
                N = p.pack,
                D = p.unpack,
                k = function(t) {
                    return [255 & t]
                },
                F = function(t) {
                    return [255 & t, t >> 8 & 255]
                },
                B = function(t) {
                    return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255]
                },
                U = function(t) {
                    return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0]
                },
                H = function(t) {
                    return N(t, 23, 4)
                },
                z = function(t) {
                    return N(t, 52, 8)
                },
                j = function(t, e) {
                    v(t[S], e, {
                        get: function() {
                            return x(this)[e]
                        }
                    })
                },
                G = function(t, e, n, r) {
                    var i = d(n),
                        o = x(t);
                    if (i + e > o.byteLength) throw I(A);
                    var a = x(o.buffer).bytes,
                        s = i + o.byteOffset,
                        c = a.slice(s, s + e);
                    return r ? c : c.reverse()
                },
                V = function(t, e, n, r, i, o) {
                    var a = d(n),
                        s = x(t);
                    if (a + e > s.byteLength) throw I(A);
                    for (var c = x(s.buffer).bytes, l = a + s.byteOffset, u = r(+i), h = 0; h < e; h++) c[l + h] = u[o ? h : e - h - 1]
                };
            if (o) {
                if (!c((function() {
                        L(1)
                    })) || !c((function() {
                        new L(-1)
                    })) || c((function() {
                        return new L, new L(1.5), new L(NaN), L.name != M
                    }))) {
                    R = function(t) {
                        return l(this, R), new L(d(t))
                    };
                    for (var W, X = R[S] = L[S], q = g(L), Y = 0; q.length > Y;)(W = q[Y++]) in R || a(R, W, L[W]);
                    X.constructor = R
                }
                m && f(O) !== P && m(O, P);
                var $ = new C(new R(2)),
                    Z = O.setInt8;
                $.setInt8(0, 2147483648), $.setInt8(1, 2147483649), !$.getInt8(0) && $.getInt8(1) || s(O, {
                    setInt8: function(t, e) {
                        Z.call(this, t, e << 24 >> 24)
                    },
                    setUint8: function(t, e) {
                        Z.call(this, t, e << 24 >> 24)
                    }
                }, {
                    unsafe: !0
                })
            } else R = function(t) {
                l(this, R, M);
                var e = d(t);
                w(this, {
                    bytes: y.call(new Array(e), 0),
                    byteLength: e
                }), i || (this.byteLength = e)
            }, C = function(t, e, n) {
                l(this, C, T), l(t, R, T);
                var r = x(t).byteLength,
                    o = u(e);
                if (o < 0 || o > r) throw I("Wrong offset");
                if (n = void 0 === n ? r - o : h(n), o + n > r) throw I(E);
                w(this, {
                    buffer: t,
                    byteLength: n,
                    byteOffset: o
                }), i || (this.buffer = t, this.byteLength = n, this.byteOffset = o)
            }, i && (j(R, "byteLength"), j(C, "buffer"), j(C, "byteLength"), j(C, "byteOffset")), s(C[S], {
                getInt8: function(t) {
                    return G(this, 1, t)[0] << 24 >> 24
                },
                getUint8: function(t) {
                    return G(this, 1, t)[0]
                },
                getInt16: function(t) {
                    var e = G(this, 2, t, arguments.length > 1 ? arguments[1] : void 0);
                    return (e[1] << 8 | e[0]) << 16 >> 16
                },
                getUint16: function(t) {
                    var e = G(this, 2, t, arguments.length > 1 ? arguments[1] : void 0);
                    return e[1] << 8 | e[0]
                },
                getInt32: function(t) {
                    return U(G(this, 4, t, arguments.length > 1 ? arguments[1] : void 0))
                },
                getUint32: function(t) {
                    return U(G(this, 4, t, arguments.length > 1 ? arguments[1] : void 0)) >>> 0
                },
                getFloat32: function(t) {
                    return D(G(this, 4, t, arguments.length > 1 ? arguments[1] : void 0), 23)
                },
                getFloat64: function(t) {
                    return D(G(this, 8, t, arguments.length > 1 ? arguments[1] : void 0), 52)
                },
                setInt8: function(t, e) {
                    V(this, 1, t, k, e)
                },
                setUint8: function(t, e) {
                    V(this, 1, t, k, e)
                },
                setInt16: function(t, e) {
                    V(this, 2, t, F, e, arguments.length > 2 ? arguments[2] : void 0)
                },
                setUint16: function(t, e) {
                    V(this, 2, t, F, e, arguments.length > 2 ? arguments[2] : void 0)
                },
                setInt32: function(t, e) {
                    V(this, 4, t, B, e, arguments.length > 2 ? arguments[2] : void 0)
                },
                setUint32: function(t, e) {
                    V(this, 4, t, B, e, arguments.length > 2 ? arguments[2] : void 0)
                },
                setFloat32: function(t, e) {
                    V(this, 4, t, H, e, arguments.length > 2 ? arguments[2] : void 0)
                },
                setFloat64: function(t, e) {
                    V(this, 8, t, z, e, arguments.length > 2 ? arguments[2] : void 0)
                }
            });
            _(R, M), _(C, T), t.exports = {
                ArrayBuffer: R,
                DataView: C
            }
        },
        "649e": function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("b727").some,
                o = r.aTypedArray,
                a = r.exportTypedArrayMethod;
            a("some", (function(t) {
                return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0)
            }))
        },
        6547: function(t, e, n) {
            var r = n("a691"),
                i = n("1d80"),
                o = function(t) {
                    return function(e, n) {
                        var o, a, s = String(i(e)),
                            c = r(n),
                            l = s.length;
                        return c < 0 || c >= l ? t ? "" : void 0 : (o = s.charCodeAt(c), o < 55296 || o > 56319 || c + 1 === l || (a = s.charCodeAt(c + 1)) < 56320 || a > 57343 ? t ? s.charAt(c) : o : t ? s.slice(c, c + 2) : a - 56320 + (o - 55296 << 10) + 65536)
                    }
                };
            t.exports = {
                codeAt: o(!1),
                charAt: o(!0)
            }
        },
        "65f0": function(t, e, n) {
            var r = n("861d"),
                i = n("e8b5"),
                o = n("b622"),
                a = o("species");
            t.exports = function(t, e) {
                var n;
                return i(t) && (n = t.constructor, "function" != typeof n || n !== Array && !i(n.prototype) ? r(n) && (n = n[a], null === n && (n = void 0)) : n = void 0), new(void 0 === n ? Array : n)(0 === e ? 0 : e)
            }
        },
        "69f3": function(t, e, n) {
            var r, i, o, a = n("7f9a"),
                s = n("da84"),
                c = n("861d"),
                l = n("9112"),
                u = n("5135"),
                h = n("f772"),
                d = n("d012"),
                p = s.WeakMap,
                f = function(t) {
                    return o(t) ? i(t) : r(t, {})
                },
                m = function(t) {
                    return function(e) {
                        var n;
                        if (!c(e) || (n = i(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required");
                        return n
                    }
                };
            if (a) {
                var g = new p,
                    v = g.get,
                    y = g.has,
                    _ = g.set;
                r = function(t, e) {
                    return _.call(g, t, e), e
                }, i = function(t) {
                    return v.call(g, t) || {}
                }, o = function(t) {
                    return y.call(g, t)
                }
            } else {
                var b = h("state");
                d[b] = !0, r = function(t, e) {
                    return l(t, b, e), e
                }, i = function(t) {
                    return u(t, b) ? t[b] : {}
                }, o = function(t) {
                    return u(t, b)
                }
            }
            t.exports = {
                set: r,
                get: i,
                has: o,
                enforce: f,
                getterFor: m
            }
        },
        "6b75": function(t, e, n) {
            "use strict";

            function r(t, e) {
                (null == e || e > t.length) && (e = t.length);
                for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
                return r
            }
            n.d(e, "a", (function() {
                return r
            }))
        },
        "6eeb": function(t, e, n) {
            var r = n("da84"),
                i = n("9112"),
                o = n("5135"),
                a = n("ce4e"),
                s = n("8925"),
                c = n("69f3"),
                l = c.get,
                u = c.enforce,
                h = String(String).split("String");
            (t.exports = function(t, e, n, s) {
                var c = !!s && !!s.unsafe,
                    l = !!s && !!s.enumerable,
                    d = !!s && !!s.noTargetGet;
                "function" == typeof n && ("string" != typeof e || o(n, "name") || i(n, "name", e), u(n).source = h.join("string" == typeof e ? e : "")), t !== r ? (c ? !d && t[e] && (l = !0) : delete t[e], l ? t[e] = n : i(t, e, n)) : l ? t[e] = n : a(e, n)
            })(Function.prototype, "toString", (function() {
                return "function" == typeof this && l(this).source || s(this)
            }))
        },
        7156: function(t, e, n) {
            var r = n("861d"),
                i = n("d2bb");
            t.exports = function(t, e, n) {
                var o, a;
                return i && "function" == typeof(o = e.constructor) && o !== n && r(a = o.prototype) && a !== n.prototype && i(t, a), t
            }
        },
        "72f7": function(t, e, n) {
            "use strict";
            var r = n("ebb5").exportTypedArrayMethod,
                i = n("d039"),
                o = n("da84"),
                a = o.Uint8Array,
                s = a && a.prototype || {},
                c = [].toString,
                l = [].join;
            i((function() {
                c.call({})
            })) && (c = function() {
                return l.call(this)
            });
            var u = s.toString != c;
            r("toString", c, u)
        },
        "735e": function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("81d5"),
                o = r.aTypedArray,
                a = r.exportTypedArrayMethod;
            a("fill", (function(t) {
                return i.apply(o(this), arguments)
            }))
        },
        7418: function(t, e) {
            e.f = Object.getOwnPropertySymbols
        },
        "746f": function(t, e, n) {
            var r = n("428f"),
                i = n("5135"),
                o = n("e538"),
                a = n("9bf2").f;
            t.exports = function(t) {
                var e = r.Symbol || (r.Symbol = {});
                i(e, t) || a(e, t, {
                    value: o.f(t)
                })
            }
        },
        "74e8": function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("da84"),
                o = n("83ab"),
                a = n("8aa7"),
                s = n("ebb5"),
                c = n("621a"),
                l = n("19aa"),
                u = n("5c6c"),
                h = n("9112"),
                d = n("50c4"),
                p = n("0b25"),
                f = n("182d"),
                m = n("c04e"),
                g = n("5135"),
                v = n("f5df"),
                y = n("861d"),
                _ = n("7c73"),
                b = n("d2bb"),
                x = n("241c").f,
                w = n("a078"),
                M = n("b727").forEach,
                T = n("2626"),
                S = n("9bf2"),
                E = n("06cf"),
                A = n("69f3"),
                L = n("7156"),
                R = A.get,
                C = A.set,
                O = S.f,
                P = E.f,
                I = Math.round,
                N = i.RangeError,
                D = c.ArrayBuffer,
                k = c.DataView,
                F = s.NATIVE_ARRAY_BUFFER_VIEWS,
                B = s.TYPED_ARRAY_TAG,
                U = s.TypedArray,
                H = s.TypedArrayPrototype,
                z = s.aTypedArrayConstructor,
                j = s.isTypedArray,
                G = "BYTES_PER_ELEMENT",
                V = "Wrong length",
                W = function(t, e) {
                    var n = 0,
                        r = e.length,
                        i = new(z(t))(r);
                    while (r > n) i[n] = e[n++];
                    return i
                },
                X = function(t, e) {
                    O(t, e, {
                        get: function() {
                            return R(this)[e]
                        }
                    })
                },
                q = function(t) {
                    var e;
                    return t instanceof D || "ArrayBuffer" == (e = v(t)) || "SharedArrayBuffer" == e
                },
                Y = function(t, e) {
                    return j(t) && "symbol" != typeof e && e in t && String(+e) == String(e)
                },
                $ = function(t, e) {
                    return Y(t, e = m(e, !0)) ? u(2, t[e]) : P(t, e)
                },
                Z = function(t, e, n) {
                    return !(Y(t, e = m(e, !0)) && y(n) && g(n, "value")) || g(n, "get") || g(n, "set") || n.configurable || g(n, "writable") && !n.writable || g(n, "enumerable") && !n.enumerable ? O(t, e, n) : (t[e] = n.value, t)
                };
            o ? (F || (E.f = $, S.f = Z, X(H, "buffer"), X(H, "byteOffset"), X(H, "byteLength"), X(H, "length")), r({
                target: "Object",
                stat: !0,
                forced: !F
            }, {
                getOwnPropertyDescriptor: $,
                defineProperty: Z
            }), t.exports = function(t, e, n) {
                var o = t.match(/\d+$/)[0] / 8,
                    s = t + (n ? "Clamped" : "") + "Array",
                    c = "get" + t,
                    u = "set" + t,
                    m = i[s],
                    g = m,
                    v = g && g.prototype,
                    S = {},
                    E = function(t, e) {
                        var n = R(t);
                        return n.view[c](e * o + n.byteOffset, !0)
                    },
                    A = function(t, e, r) {
                        var i = R(t);
                        n && (r = (r = I(r)) < 0 ? 0 : r > 255 ? 255 : 255 & r), i.view[u](e * o + i.byteOffset, r, !0)
                    },
                    P = function(t, e) {
                        O(t, e, {
                            get: function() {
                                return E(this, e)
                            },
                            set: function(t) {
                                return A(this, e, t)
                            },
                            enumerable: !0
                        })
                    };
                F ? a && (g = e((function(t, e, n, r) {
                    return l(t, g, s), L(function() {
                        return y(e) ? q(e) ? void 0 !== r ? new m(e, f(n, o), r) : void 0 !== n ? new m(e, f(n, o)) : new m(e) : j(e) ? W(g, e) : w.call(g, e) : new m(p(e))
                    }(), t, g)
                })), b && b(g, U), M(x(m), (function(t) {
                    t in g || h(g, t, m[t])
                })), g.prototype = v) : (g = e((function(t, e, n, r) {
                    l(t, g, s);
                    var i, a, c, u = 0,
                        h = 0;
                    if (y(e)) {
                        if (!q(e)) return j(e) ? W(g, e) : w.call(g, e);
                        i = e, h = f(n, o);
                        var m = e.byteLength;
                        if (void 0 === r) {
                            if (m % o) throw N(V);
                            if (a = m - h, a < 0) throw N(V)
                        } else if (a = d(r) * o, a + h > m) throw N(V);
                        c = a / o
                    } else c = p(e), a = c * o, i = new D(a);
                    C(t, {
                        buffer: i,
                        byteOffset: h,
                        byteLength: a,
                        length: c,
                        view: new k(i)
                    });
                    while (u < c) P(t, u++)
                })), b && b(g, U), v = g.prototype = _(H)), v.constructor !== g && h(v, "constructor", g), B && h(v, B, s), S[s] = g, r({
                    global: !0,
                    forced: g != m,
                    sham: !F
                }, S), G in g || h(g, G, o), G in v || h(v, G, o), T(s)
            }) : t.exports = function() {}
        },
        "77a7": function(t, e) {
            var n = 1 / 0,
                r = Math.abs,
                i = Math.pow,
                o = Math.floor,
                a = Math.log,
                s = Math.LN2,
                c = function(t, e, c) {
                    var l, u, h, d = new Array(c),
                        p = 8 * c - e - 1,
                        f = (1 << p) - 1,
                        m = f >> 1,
                        g = 23 === e ? i(2, -24) - i(2, -77) : 0,
                        v = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0,
                        y = 0;
                    for (t = r(t), t != t || t === n ? (u = t != t ? 1 : 0, l = f) : (l = o(a(t) / s), t * (h = i(2, -l)) < 1 && (l--, h *= 2), t += l + m >= 1 ? g / h : g * i(2, 1 - m), t * h >= 2 && (l++, h /= 2), l + m >= f ? (u = 0, l = f) : l + m >= 1 ? (u = (t * h - 1) * i(2, e), l += m) : (u = t * i(2, m - 1) * i(2, e), l = 0)); e >= 8; d[y++] = 255 & u, u /= 256, e -= 8);
                    for (l = l << e | u, p += e; p > 0; d[y++] = 255 & l, l /= 256, p -= 8);
                    return d[--y] |= 128 * v, d
                },
                l = function(t, e) {
                    var r, o = t.length,
                        a = 8 * o - e - 1,
                        s = (1 << a) - 1,
                        c = s >> 1,
                        l = a - 7,
                        u = o - 1,
                        h = t[u--],
                        d = 127 & h;
                    for (h >>= 7; l > 0; d = 256 * d + t[u], u--, l -= 8);
                    for (r = d & (1 << -l) - 1, d >>= -l, l += e; l > 0; r = 256 * r + t[u], u--, l -= 8);
                    if (0 === d) d = 1 - c;
                    else {
                        if (d === s) return r ? NaN : h ? -n : n;
                        r += i(2, e), d -= c
                    }
                    return (h ? -1 : 1) * r * i(2, d - e)
                };
            t.exports = {
                pack: c,
                unpack: l
            }
        },
        7839: function(t, e) {
            t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
        },
        "7b0b": function(t, e, n) {
            var r = n("1d80");
            t.exports = function(t) {
                return Object(r(t))
            }
        },
        "7b3e": function(t, e, n) {
            "use strict";
            var r, i = n("a3de");
            /**
             * Checks if an event is supported in the current execution environment.
             *
             * NOTE: This will not work correctly for non-generic events such as `change`,
             * `reset`, `load`, `error`, and `select`.
             *
             * Borrows from Modernizr.
             *
             * @param {string} eventNameSuffix Event name, e.g. "click".
             * @param {?boolean} capture Check if the capture phase is supported.
             * @return {boolean} True if the event is supported.
             * @internal
             * @license Modernizr 3.0.0pre (Custom Build) | MIT
             */
            function o(t, e) {
                if (!i.canUseDOM || e && !("addEventListener" in document)) return !1;
                var n = "on" + t,
                    o = n in document;
                if (!o) {
                    var a = document.createElement("div");
                    a.setAttribute(n, "return;"), o = "function" === typeof a[n]
                }
                return !o && r && "wheel" === t && (o = document.implementation.hasFeature("Events.wheel", "3.0")), o
            }
            i.canUseDOM && (r = document.implementation && document.implementation.hasFeature && !0 !== document.implementation.hasFeature("", "")), t.exports = o
        },
        "7c73": function(t, e, n) {
            var r, i = n("825a"),
                o = n("37e8"),
                a = n("7839"),
                s = n("d012"),
                c = n("1be4"),
                l = n("cc12"),
                u = n("f772"),
                h = ">",
                d = "<",
                p = "prototype",
                f = "script",
                m = u("IE_PROTO"),
                g = function() {},
                v = function(t) {
                    return d + f + h + t + d + "/" + f + h
                },
                y = function(t) {
                    t.write(v("")), t.close();
                    var e = t.parentWindow.Object;
                    return t = null, e
                },
                _ = function() {
                    var t, e = l("iframe"),
                        n = "java" + f + ":";
                    return e.style.display = "none", c.appendChild(e), e.src = String(n), t = e.contentWindow.document, t.open(), t.write(v("document.F=Object")), t.close(), t.F
                },
                b = function() {
                    try {
                        r = document.domain && new ActiveXObject("htmlfile")
                    } catch (e) {}
                    b = r ? y(r) : _();
                    var t = a.length;
                    while (t--) delete b[p][a[t]];
                    return b()
                };
            s[m] = !0, t.exports = Object.create || function(t, e) {
                var n;
                return null !== t ? (g[p] = i(t), n = new g, g[p] = null, n[m] = t) : n = b(), void 0 === e ? n : o(n, e)
            }
        },
        "7db0": function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("b727").find,
                o = n("44d2"),
                a = n("ae40"),
                s = "find",
                c = !0,
                l = a(s);
            s in [] && Array(1)[s]((function() {
                c = !1
            })), r({
                target: "Array",
                proto: !0,
                forced: c || !l
            }, {
                find: function(t) {
                    return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
                }
            }), o(s)
        },
        "7dd0": function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("9ed3"),
                o = n("e163"),
                a = n("d2bb"),
                s = n("d44e"),
                c = n("9112"),
                l = n("6eeb"),
                u = n("b622"),
                h = n("c430"),
                d = n("3f8c"),
                p = n("ae93"),
                f = p.IteratorPrototype,
                m = p.BUGGY_SAFARI_ITERATORS,
                g = u("iterator"),
                v = "keys",
                y = "values",
                _ = "entries",
                b = function() {
                    return this
                };
            t.exports = function(t, e, n, u, p, x, w) {
                i(n, e, u);
                var M, T, S, E = function(t) {
                        if (t === p && O) return O;
                        if (!m && t in R) return R[t];
                        switch (t) {
                            case v:
                                return function() {
                                    return new n(this, t)
                                };
                            case y:
                                return function() {
                                    return new n(this, t)
                                };
                            case _:
                                return function() {
                                    return new n(this, t)
                                }
                        }
                        return function() {
                            return new n(this)
                        }
                    },
                    A = e + " Iterator",
                    L = !1,
                    R = t.prototype,
                    C = R[g] || R["@@iterator"] || p && R[p],
                    O = !m && C || E(p),
                    P = "Array" == e && R.entries || C;
                if (P && (M = o(P.call(new t)), f !== Object.prototype && M.next && (h || o(M) === f || (a ? a(M, f) : "function" != typeof M[g] && c(M, g, b)), s(M, A, !0, !0), h && (d[A] = b))), p == y && C && C.name !== y && (L = !0, O = function() {
                        return C.call(this)
                    }), h && !w || R[g] === O || c(R, g, O), d[e] = O, p)
                    if (T = {
                            values: E(y),
                            keys: x ? O : E(v),
                            entries: E(_)
                        }, w)
                        for (S in T)(m || L || !(S in R)) && l(R, S, T[S]);
                    else r({
                        target: e,
                        proto: !0,
                        forced: m || L
                    }, T);
                return T
            }
        },
        "7f9a": function(t, e, n) {
            var r = n("da84"),
                i = n("8925"),
                o = r.WeakMap;
            t.exports = "function" === typeof o && /native code/.test(i(o))
        },
        "81d5": function(t, e, n) {
            "use strict";
            var r = n("7b0b"),
                i = n("23cb"),
                o = n("50c4");
            t.exports = function(t) {
                var e = r(this),
                    n = o(e.length),
                    a = arguments.length,
                    s = i(a > 1 ? arguments[1] : void 0, n),
                    c = a > 2 ? arguments[2] : void 0,
                    l = void 0 === c ? n : i(c, n);
                while (l > s) e[s++] = t;
                return e
            }
        },
        "825a": function(t, e, n) {
            var r = n("861d");
            t.exports = function(t) {
                if (!r(t)) throw TypeError(String(t) + " is not an object");
                return t
            }
        },
        "82f8": function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("4d64").includes,
                o = r.aTypedArray,
                a = r.exportTypedArrayMethod;
            a("includes", (function(t) {
                return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0)
            }))
        },
        "83ab": function(t, e, n) {
            var r = n("d039");
            t.exports = !r((function() {
                return 7 != Object.defineProperty({}, 1, {
                    get: function() {
                        return 7
                    }
                })[1]
            }))
        },
        8418: function(t, e, n) {
            "use strict";
            var r = n("c04e"),
                i = n("9bf2"),
                o = n("5c6c");
            t.exports = function(t, e, n) {
                var a = r(e);
                a in t ? i.f(t, a, o(0, n)) : t[a] = n
            }
        },
        "861d": function(t, e) {
            t.exports = function(t) {
                return "object" === typeof t ? null !== t : "function" === typeof t
            }
        },
        8710: function(t, e, n) {
            "use strict";
            n.d(e, "a", (function() {
                return V
            }));
            var r = n("5a89"),
                i = {},
                o = void 0,
                a = i;
            /** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
            function s(t, e) {
                var n, r = t.split("."),
                    i = a;
                !(r[0] in i) && i.execScript && i.execScript("var " + r[0]);
                for (; r.length && (n = r.shift());) r.length || e === o ? i = i[n] ? i[n] : i[n] = {} : i[n] = e
            }
            var c = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array && "undefined" !== typeof DataView;

            function l(t) {
                var e, n, r, i, o, a, s, l, u, h, d = t.length,
                    p = 0,
                    f = Number.POSITIVE_INFINITY;
                for (l = 0; l < d; ++l) t[l] > p && (p = t[l]), t[l] < f && (f = t[l]);
                for (e = 1 << p, n = new(c ? Uint32Array : Array)(e), r = 1, i = 0, o = 2; r <= p;) {
                    for (l = 0; l < d; ++l)
                        if (t[l] === r) {
                            for (a = 0, s = i, u = 0; u < r; ++u) a = a << 1 | 1 & s, s >>= 1;
                            for (h = r << 16 | l, u = a; u < e; u += o) n[u] = h;
                            ++i
                        }++r, i <<= 1, o <<= 1
                }
                return [n, p, f]
            }

            function u(t, e) {
                switch (this.g = [], this.h = 32768, this.d = this.f = this.a = this.l = 0, this.input = c ? new Uint8Array(t) : t, this.m = !1, this.i = d, this.r = !1, !e && (e = {}) || (e.index && (this.a = e.index), e.bufferSize && (this.h = e.bufferSize), e.bufferType && (this.i = e.bufferType), e.resize && (this.r = e.resize)), this.i) {
                    case h:
                        this.b = 32768, this.c = new(c ? Uint8Array : Array)(32768 + this.h + 258);
                        break;
                    case d:
                        this.b = 0, this.c = new(c ? Uint8Array : Array)(this.h), this.e = this.z, this.n = this.v, this.j = this.w;
                        break;
                    default:
                        throw Error("invalid inflate mode")
                }
            }
            var h = 0,
                d = 1,
                p = {
                    t: h,
                    s: d
                };
            u.prototype.k = function() {
                for (; !this.m;) {
                    var t = P(this, 3);
                    switch (1 & t && (this.m = !0), t >>>= 1, t) {
                        case 0:
                            var e = this.input,
                                n = this.a,
                                r = this.c,
                                i = this.b,
                                a = e.length,
                                s = o,
                                u = o,
                                p = r.length,
                                f = o;
                            if (this.d = this.f = 0, n + 1 >= a) throw Error("invalid uncompressed block header: LEN");
                            if (s = e[n++] | e[n++] << 8, n + 1 >= a) throw Error("invalid uncompressed block header: NLEN");
                            if (u = e[n++] | e[n++] << 8, s === ~u) throw Error("invalid uncompressed block header: length verify");
                            if (n + s > e.length) throw Error("input buffer is broken");
                            switch (this.i) {
                                case h:
                                    for (; i + s > r.length;) {
                                        if (f = p - i, s -= f, c) r.set(e.subarray(n, n + f), i), i += f, n += f;
                                        else
                                            for (; f--;) r[i++] = e[n++];
                                        this.b = i, r = this.e(), i = this.b
                                    }
                                    break;
                                case d:
                                    for (; i + s > r.length;) r = this.e({
                                        p: 2
                                    });
                                    break;
                                default:
                                    throw Error("invalid inflate mode")
                            }
                            if (c) r.set(e.subarray(n, n + s), i), i += s, n += s;
                            else
                                for (; s--;) r[i++] = e[n++];
                            this.a = n, this.b = i, this.c = r;
                            break;
                        case 1:
                            this.j(R, O);
                            break;
                        case 2:
                            var m = P(this, 5) + 257,
                                g = P(this, 5) + 1,
                                y = P(this, 4) + 4,
                                _ = new(c ? Uint8Array : Array)(v.length),
                                b = o,
                                x = o,
                                w = o,
                                M = o,
                                T = o,
                                S = o,
                                E = o,
                                A = o,
                                L = o;
                            for (A = 0; A < y; ++A) _[v[A]] = P(this, 3);
                            if (!c)
                                for (A = y, y = _.length; A < y; ++A) _[v[A]] = 0;
                            for (b = l(_), M = new(c ? Uint8Array : Array)(m + g), A = 0, L = m + g; A < L;) switch (T = I(this, b), T) {
                                case 16:
                                    for (E = 3 + P(this, 2); E--;) M[A++] = S;
                                    break;
                                case 17:
                                    for (E = 3 + P(this, 3); E--;) M[A++] = 0;
                                    S = 0;
                                    break;
                                case 18:
                                    for (E = 11 + P(this, 7); E--;) M[A++] = 0;
                                    S = 0;
                                    break;
                                default:
                                    S = M[A++] = T
                            }
                            x = l(c ? M.subarray(0, m) : M.slice(0, m)), w = l(c ? M.subarray(m) : M.slice(m)), this.j(x, w);
                            break;
                        default:
                            throw Error("unknown BTYPE: " + t)
                    }
                }
                return this.n()
            };
            var f, m, g = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                v = c ? new Uint16Array(g) : g,
                y = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258],
                _ = c ? new Uint16Array(y) : y,
                b = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0],
                x = c ? new Uint8Array(b) : b,
                w = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],
                M = c ? new Uint16Array(w) : w,
                T = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
                S = c ? new Uint8Array(T) : T,
                E = new(c ? Uint8Array : Array)(288);
            for (f = 0, m = E.length; f < m; ++f) E[f] = 143 >= f ? 8 : 255 >= f ? 9 : 279 >= f ? 7 : 8;
            var A, L, R = l(E),
                C = new(c ? Uint8Array : Array)(30);
            for (A = 0, L = C.length; A < L; ++A) C[A] = 5;
            var O = l(C);

            function P(t, e) {
                for (var n, r = t.f, i = t.d, o = t.input, a = t.a, s = o.length; i < e;) {
                    if (a >= s) throw Error("input buffer is broken");
                    r |= o[a++] << i, i += 8
                }
                return n = r & (1 << e) - 1, t.f = r >>> e, t.d = i - e, t.a = a, n
            }

            function I(t, e) {
                for (var n, r, i = t.f, o = t.d, a = t.input, s = t.a, c = a.length, l = e[0], u = e[1]; o < u && !(s >= c);) i |= a[s++] << o, o += 8;
                if (n = l[i & (1 << u) - 1], r = n >>> 16, r > o) throw Error("invalid code length: " + r);
                return t.f = i >> r, t.d = o - r, t.a = s, 65535 & n
            }

            function N(t, e) {
                var n, r;
                switch (this.input = t, this.a = 0, !e && (e = {}) || (e.index && (this.a = e.index), e.verify && (this.A = e.verify)), n = t[this.a++], r = t[this.a++], 15 & n) {
                    case D:
                        this.method = D;
                        break;
                    default:
                        throw Error("unsupported compression method")
                }
                if (0 !== ((n << 8) + r) % 31) throw Error("invalid fcheck flag:" + ((n << 8) + r) % 31);
                if (32 & r) throw Error("fdict flag is not supported");
                this.q = new u(t, {
                    index: this.a,
                    bufferSize: e.bufferSize,
                    bufferType: e.bufferType,
                    resize: e.resize
                })
            }
            u.prototype.j = function(t, e) {
                var n = this.c,
                    r = this.b;
                this.o = t;
                for (var i, o, a, s, c = n.length - 258; 256 !== (i = I(this, t));)
                    if (256 > i) r >= c && (this.b = r, n = this.e(), r = this.b), n[r++] = i;
                    else
                        for (o = i - 257, s = _[o], 0 < x[o] && (s += P(this, x[o])), i = I(this, e), a = M[i], 0 < S[i] && (a += P(this, S[i])), r >= c && (this.b = r, n = this.e(), r = this.b); s--;) n[r] = n[r++ - a];
                for (; 8 <= this.d;) this.d -= 8, this.a--;
                this.b = r
            }, u.prototype.w = function(t, e) {
                var n = this.c,
                    r = this.b;
                this.o = t;
                for (var i, o, a, s, c = n.length; 256 !== (i = I(this, t));)
                    if (256 > i) r >= c && (n = this.e(), c = n.length), n[r++] = i;
                    else
                        for (o = i - 257, s = _[o], 0 < x[o] && (s += P(this, x[o])), i = I(this, e), a = M[i], 0 < S[i] && (a += P(this, S[i])), r + s > c && (n = this.e(), c = n.length); s--;) n[r] = n[r++ - a];
                for (; 8 <= this.d;) this.d -= 8, this.a--;
                this.b = r
            }, u.prototype.e = function() {
                var t, e, n = new(c ? Uint8Array : Array)(this.b - 32768),
                    r = this.b - 32768,
                    i = this.c;
                if (c) n.set(i.subarray(32768, n.length));
                else
                    for (t = 0, e = n.length; t < e; ++t) n[t] = i[t + 32768];
                if (this.g.push(n), this.l += n.length, c) i.set(i.subarray(r, r + 32768));
                else
                    for (t = 0; 32768 > t; ++t) i[t] = i[r + t];
                return this.b = 32768, i
            }, u.prototype.z = function(t) {
                var e, n, r, i, o = this.input.length / this.a + 1 | 0,
                    a = this.input,
                    s = this.c;
                return t && ("number" === typeof t.p && (o = t.p), "number" === typeof t.u && (o += t.u)), 2 > o ? (n = (a.length - this.a) / this.o[2], i = n / 2 * 258 | 0, r = i < s.length ? s.length + i : s.length << 1) : r = s.length * o, c ? (e = new Uint8Array(r), e.set(s)) : e = s, this.c = e
            }, u.prototype.n = function() {
                var t, e, n, r, i, o = 0,
                    a = this.c,
                    s = this.g,
                    l = new(c ? Uint8Array : Array)(this.l + (this.b - 32768));
                if (0 === s.length) return c ? this.c.subarray(32768, this.b) : this.c.slice(32768, this.b);
                for (e = 0, n = s.length; e < n; ++e)
                    for (t = s[e], r = 0, i = t.length; r < i; ++r) l[o++] = t[r];
                for (e = 32768, n = this.b; e < n; ++e) l[o++] = a[e];
                return this.g = [], this.buffer = l
            }, u.prototype.v = function() {
                var t, e = this.b;
                return c ? this.r ? (t = new Uint8Array(e), t.set(this.c.subarray(0, e))) : t = this.c.subarray(0, e) : (this.c.length > e && (this.c.length = e), t = this.c), this.buffer = t
            }, N.prototype.k = function() {
                var t, e, n = this.input;
                if (t = this.q.k(), this.a = this.q.a, this.A) {
                    e = (n[this.a++] << 24 | n[this.a++] << 16 | n[this.a++] << 8 | n[this.a++]) >>> 0;
                    var r = t;
                    if ("string" === typeof r) {
                        var i, o, a = r.split("");
                        for (i = 0, o = a.length; i < o; i++) a[i] = (255 & a[i].charCodeAt(0)) >>> 0;
                        r = a
                    }
                    for (var s, c = 1, l = 0, u = r.length, h = 0; 0 < u;) {
                        s = 1024 < u ? 1024 : u, u -= s;
                        do {
                            c += r[h++], l += c
                        } while (--s);
                        c %= 65521, l %= 65521
                    }
                    if (e !== (l << 16 | c) >>> 0) throw Error("invalid adler-32 checksum")
                }
                return t
            };
            var D = 8;
            s("Zlib.Inflate", N), s("Zlib.Inflate.prototype.decompress", N.prototype.k);
            var k, F, B, U, H = {
                ADAPTIVE: p.s,
                BLOCK: p.t
            };
            if (Object.keys) k = Object.keys(H);
            else
                for (F in k = [], B = 0, H) k[B++] = F;
            for (B = 0, U = k.length; B < U; ++B) F = k[B], s("Zlib.Inflate.BufferType." + F, H[F]);
            var z = i.Zlib.Inflate,
                j = {
                    findSpan: function(t, e, n) {
                        var r = n.length - t - 1;
                        if (e >= n[r]) return r - 1;
                        if (e <= n[t]) return t;
                        var i = t,
                            o = r,
                            a = Math.floor((i + o) / 2);
                        while (e < n[a] || e >= n[a + 1]) e < n[a] ? o = a : i = a, a = Math.floor((i + o) / 2);
                        return a
                    },
                    calcBasisFunctions: function(t, e, n, r) {
                        var i = [],
                            o = [],
                            a = [];
                        i[0] = 1;
                        for (var s = 1; s <= n; ++s) {
                            o[s] = e - r[t + 1 - s], a[s] = r[t + s] - e;
                            for (var c = 0, l = 0; l < s; ++l) {
                                var u = a[l + 1],
                                    h = o[s - l],
                                    d = i[l] / (u + h);
                                i[l] = c + u * d, c = h * d
                            }
                            i[s] = c
                        }
                        return i
                    },
                    calcBSplinePoint: function(t, e, n, i) {
                        for (var o = this.findSpan(t, i, e), a = this.calcBasisFunctions(o, i, t, e), s = new r["Sb"](0, 0, 0, 0), c = 0; c <= t; ++c) {
                            var l = n[o - t + c],
                                u = a[c],
                                h = l.w * u;
                            s.x += l.x * h, s.y += l.y * h, s.z += l.z * h, s.w += l.w * u
                        }
                        return s
                    },
                    calcBasisFunctionDerivatives: function(t, e, n, r, i) {
                        for (var o = [], a = 0; a <= n; ++a) o[a] = 0;
                        var s = [];
                        for (a = 0; a <= r; ++a) s[a] = o.slice(0);
                        var c = [];
                        for (a = 0; a <= n; ++a) c[a] = o.slice(0);
                        c[0][0] = 1;
                        for (var l = o.slice(0), u = o.slice(0), h = 1; h <= n; ++h) {
                            l[h] = e - i[t + 1 - h], u[h] = i[t + h] - e;
                            for (var d = 0, p = 0; p < h; ++p) {
                                var f = u[p + 1],
                                    m = l[h - p];
                                c[h][p] = f + m;
                                var g = c[p][h - 1] / c[h][p];
                                c[p][h] = d + f * g, d = m * g
                            }
                            c[h][h] = d
                        }
                        for (h = 0; h <= n; ++h) s[0][h] = c[h][n];
                        for (p = 0; p <= n; ++p) {
                            var v = 0,
                                y = 1,
                                _ = [];
                            for (a = 0; a <= n; ++a) _[a] = o.slice(0);
                            _[0][0] = 1;
                            for (var b = 1; b <= r; ++b) {
                                var x = 0,
                                    w = p - b,
                                    M = n - b;
                                p >= b && (_[y][0] = _[v][0] / c[M + 1][w], x = _[y][0] * c[w][M]);
                                var T = w >= -1 ? 1 : -w,
                                    S = p - 1 <= M ? b - 1 : n - p;
                                for (h = T; h <= S; ++h) _[y][h] = (_[v][h] - _[v][h - 1]) / c[M + 1][w + h], x += _[y][h] * c[w + h][M];
                                p <= M && (_[y][b] = -_[v][b - 1] / c[M + 1][p], x += _[y][b] * c[p][M]), s[b][p] = x;
                                h = v;
                                v = y, y = h
                            }
                        }
                        for (p = n, b = 1; b <= r; ++b) {
                            for (h = 0; h <= n; ++h) s[b][h] *= p;
                            p *= n - b
                        }
                        return s
                    },
                    calcBSplineDerivatives: function(t, e, n, i, o) {
                        for (var a = o < t ? o : t, s = [], c = this.findSpan(t, i, e), l = this.calcBasisFunctionDerivatives(c, i, t, a, e), u = [], h = 0; h < n.length; ++h) {
                            var d = n[h].clone(),
                                p = d.w;
                            d.x *= p, d.y *= p, d.z *= p, u[h] = d
                        }
                        for (var f = 0; f <= a; ++f) {
                            d = u[c - t].clone().multiplyScalar(l[f][0]);
                            for (var m = 1; m <= t; ++m) d.add(u[c - t + m].clone().multiplyScalar(l[f][m]));
                            s[f] = d
                        }
                        for (f = a + 1; f <= o + 1; ++f) s[f] = new r["Sb"](0, 0, 0);
                        return s
                    },
                    calcKoverI: function(t, e) {
                        for (var n = 1, r = 2; r <= t; ++r) n *= r;
                        var i = 1;
                        for (r = 2; r <= e; ++r) i *= r;
                        for (r = 2; r <= t - e; ++r) i *= r;
                        return n / i
                    },
                    calcRationalCurveDerivatives: function(t) {
                        for (var e = t.length, n = [], i = [], o = 0; o < e; ++o) {
                            var a = t[o];
                            n[o] = new r["Rb"](a.x, a.y, a.z), i[o] = a.w
                        }
                        for (var s = [], c = 0; c < e; ++c) {
                            var l = n[c].clone();
                            for (o = 1; o <= c; ++o) l.sub(s[c - o].clone().multiplyScalar(this.calcKoverI(c, o) * i[o]));
                            s[c] = l.divideScalar(i[0])
                        }
                        return s
                    },
                    calcNURBSDerivatives: function(t, e, n, r, i) {
                        var o = this.calcBSplineDerivatives(t, e, n, r, i);
                        return this.calcRationalCurveDerivatives(o)
                    },
                    calcSurfacePoint: function(t, e, n, i, o, a, s, c) {
                        for (var l = this.findSpan(t, a, n), u = this.findSpan(e, s, i), h = this.calcBasisFunctions(l, a, t, n), d = this.calcBasisFunctions(u, s, e, i), p = [], f = 0; f <= e; ++f) {
                            p[f] = new r["Sb"](0, 0, 0, 0);
                            for (var m = 0; m <= t; ++m) {
                                var g = o[l - t + m][u - e + f].clone(),
                                    v = g.w;
                                g.x *= v, g.y *= v, g.z *= v, p[f].add(g.multiplyScalar(h[m]))
                            }
                        }
                        var y = new r["Sb"](0, 0, 0, 0);
                        for (f = 0; f <= e; ++f) y.add(p[f].multiplyScalar(d[f]));
                        y.divideScalar(y.w), c.set(y.x, y.y, y.z)
                    }
                },
                G = function(t, e, n, i, o) {
                    r["k"].call(this), this.degree = t, this.knots = e, this.controlPoints = [], this.startKnot = i || 0, this.endKnot = o || this.knots.length - 1;
                    for (var a = 0; a < n.length; ++a) {
                        var s = n[a];
                        this.controlPoints[a] = new r["Sb"](s.x, s.y, s.z, s.w)
                    }
                };
            G.prototype = Object.create(r["k"].prototype), G.prototype.constructor = G, G.prototype.getPoint = function(t, e) {
                var n = e || new r["Rb"],
                    i = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]),
                    o = j.calcBSplinePoint(this.degree, this.knots, this.controlPoints, i);
                return 1 != o.w && o.divideScalar(o.w), n.set(o.x, o.y, o.z)
            }, G.prototype.getTangent = function(t, e) {
                var n = e || new r["Rb"],
                    i = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]),
                    o = j.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, i, 1);
                return n.copy(o[1]).normalize(), n
            };
            var V = function() {
                var t, e, n;

                function i(t) {
                    r["M"].call(this, t)
                }

                function o(t, e) {
                    this.textureLoader = t, this.manager = e
                }

                function a() {}

                function s() {}

                function c() {}

                function l() {}

                function u(t, e) {
                    this.dv = new DataView(t), this.offset = 0, this.littleEndian = void 0 === e || e
                }

                function h() {}

                function d(t) {
                    var e = "Kaydara FBX Binary  \0";
                    return t.byteLength >= e.length && e === M(t, 0, e.length)
                }

                function p(t) {
                    var e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"],
                        n = 0;

                    function r(e) {
                        var r = t[e - 1];
                        return t = t.slice(n + e), n++, r
                    }
                    for (var i = 0; i < e.length; ++i) {
                        var o = r(1);
                        if (o === e[i]) return !1
                    }
                    return !0
                }

                function f(t) {
                    var e = /FBXVersion: (\d+)/,
                        n = t.match(e);
                    if (n) {
                        var r = parseInt(n[1]);
                        return r
                    }
                    throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")
                }

                function m(t) {
                    return t / 46186158e3
                }
                i.prototype = Object.assign(Object.create(r["M"].prototype), {
                    constructor: i,
                    load: function(t, e, n, i) {
                        var o = this,
                            a = "" === o.path ? r["N"].extractUrlBase(t) : o.path,
                            s = new r["t"](this.manager);
                        s.setPath(o.path), s.setResponseType("arraybuffer"), s.setRequestHeader(o.requestHeader), s.setWithCredentials(o.withCredentials), s.load(t, (function(n) {
                            try {
                                e(o.parse(n, a))
                            } catch (r) {
                                i ? i(r) : console.error(r), o.manager.itemError(t)
                            }
                        }), n, i)
                    },
                    parse: function(e, n) {
                        if (d(e)) t = (new l).parse(e);
                        else {
                            var i = M(e);
                            if (!p(i)) throw new Error("THREE.FBXLoader: Unknown format.");
                            if (f(i) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + f(i));
                            t = (new c).parse(i)
                        }
                        var a = new r["Jb"](this.manager).setPath(this.resourcePath || n).setCrossOrigin(this.crossOrigin);
                        return new o(a, this.manager).parse(t)
                    }
                }), o.prototype = {
                    constructor: o,
                    parse: function() {
                        e = this.parseConnections();
                        var t = this.parseImages(),
                            r = this.parseTextures(t),
                            i = this.parseMaterials(r),
                            o = this.parseDeformers(),
                            s = (new a).parse(o);
                        return this.parseScene(o, s, i), n
                    },
                    parseConnections: function() {
                        var e = new Map;
                        if ("Connections" in t) {
                            var n = t.Connections.connections;
                            n.forEach((function(t) {
                                var n = t[0],
                                    r = t[1],
                                    i = t[2];
                                e.has(n) || e.set(n, {
                                    parents: [],
                                    children: []
                                });
                                var o = {
                                    ID: r,
                                    relationship: i
                                };
                                e.get(n).parents.push(o), e.has(r) || e.set(r, {
                                    parents: [],
                                    children: []
                                });
                                var a = {
                                    ID: n,
                                    relationship: i
                                };
                                e.get(r).children.push(a)
                            }))
                        }
                        return e
                    },
                    parseImages: function() {
                        var e = {},
                            n = {};
                        if ("Video" in t.Objects) {
                            var r = t.Objects.Video;
                            for (var i in r) {
                                var o = r[i],
                                    a = parseInt(i);
                                if (e[a] = o.RelativeFilename || o.Filename, "Content" in o) {
                                    var s = o.Content instanceof ArrayBuffer && o.Content.byteLength > 0,
                                        c = "string" === typeof o.Content && "" !== o.Content;
                                    if (s || c) {
                                        var l = this.parseImage(r[i]);
                                        n[o.RelativeFilename || o.Filename] = l
                                    }
                                }
                            }
                        }
                        for (var a in e) {
                            var u = e[a];
                            void 0 !== n[u] ? e[a] = n[u] : e[a] = e[a].split("\\").pop()
                        }
                        return e
                    },
                    parseImage: function(t) {
                        var e, n = t.Content,
                            r = t.RelativeFilename || t.Filename,
                            i = r.slice(r.lastIndexOf(".") + 1).toLowerCase();
                        switch (i) {
                            case "bmp":
                                e = "image/bmp";
                                break;
                            case "jpg":
                            case "jpeg":
                                e = "image/jpeg";
                                break;
                            case "png":
                                e = "image/png";
                                break;
                            case "tif":
                                e = "image/tiff";
                                break;
                            case "tga":
                                null === this.manager.getHandler(".tga") && console.warn("FBXLoader: TGA loader not found, skipping ", r), e = "image/tga";
                                break;
                            default:
                                return void console.warn('FBXLoader: Image type "' + i + '" is not supported.')
                        }
                        if ("string" === typeof n) return "data:" + e + ";base64," + n;
                        var o = new Uint8Array(n);
                        return window.URL.createObjectURL(new Blob([o], {
                            type: e
                        }))
                    },
                    parseTextures: function(e) {
                        var n = new Map;
                        if ("Texture" in t.Objects) {
                            var r = t.Objects.Texture;
                            for (var i in r) {
                                var o = this.parseTexture(r[i], e);
                                n.set(parseInt(i), o)
                            }
                        }
                        return n
                    },
                    parseTexture: function(t, e) {
                        var n = this.loadTexture(t, e);
                        n.ID = t.id, n.name = t.attrName;
                        var i = t.WrapModeU,
                            o = t.WrapModeV,
                            a = void 0 !== i ? i.value : 0,
                            s = void 0 !== o ? o.value : 0;
                        if (n.wrapS = 0 === a ? r["xb"] : r["h"], n.wrapT = 0 === s ? r["xb"] : r["h"], "Scaling" in t) {
                            var c = t.Scaling.value;
                            n.repeat.x = c[0], n.repeat.y = c[1]
                        }
                        return n
                    },
                    loadTexture: function(t, n) {
                        var i, o, a = this.textureLoader.path,
                            s = e.get(t.id).children;
                        void 0 !== s && s.length > 0 && void 0 !== n[s[0].ID] && (i = n[s[0].ID], 0 !== i.indexOf("blob:") && 0 !== i.indexOf("data:") || this.textureLoader.setPath(void 0));
                        var c = t.FileName.slice(-3).toLowerCase();
                        if ("tga" === c) {
                            var l = this.manager.getHandler(".tga");
                            null === l ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", t.RelativeFilename), o = new r["Ib"]) : o = l.load(i)
                        } else "psd" === c ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", t.RelativeFilename), o = new r["Ib"]) : o = this.textureLoader.load(i);
                        return this.textureLoader.setPath(a), o
                    },
                    parseMaterials: function(e) {
                        var n = new Map;
                        if ("Material" in t.Objects) {
                            var r = t.Objects.Material;
                            for (var i in r) {
                                var o = this.parseMaterial(r[i], e);
                                null !== o && n.set(parseInt(i), o)
                            }
                        }
                        return n
                    },
                    parseMaterial: function(t, n) {
                        var i = t.id,
                            o = t.attrName,
                            a = t.ShadingModel;
                        if ("object" === typeof a && (a = a.value), !e.has(i)) return null;
                        var s, c = this.parseParameters(t, n, i);
                        switch (a.toLowerCase()) {
                            case "phong":
                                s = new r["W"];
                                break;
                            case "lambert":
                                s = new r["V"];
                                break;
                            default:
                                console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', a), s = new r["W"];
                                break
                        }
                        return s.setValues(c), s.name = o, s
                    },
                    parseParameters: function(t, n, i) {
                        var o = {};
                        t.BumpFactor && (o.bumpScale = t.BumpFactor.value), t.Diffuse ? o.color = (new r["j"]).fromArray(t.Diffuse.value) : t.DiffuseColor && "Color" === t.DiffuseColor.type && (o.color = (new r["j"]).fromArray(t.DiffuseColor.value)), t.DisplacementFactor && (o.displacementScale = t.DisplacementFactor.value), t.Emissive ? o.emissive = (new r["j"]).fromArray(t.Emissive.value) : t.EmissiveColor && "Color" === t.EmissiveColor.type && (o.emissive = (new r["j"]).fromArray(t.EmissiveColor.value)), t.EmissiveFactor && (o.emissiveIntensity = parseFloat(t.EmissiveFactor.value)), t.Opacity && (o.opacity = parseFloat(t.Opacity.value)), o.opacity < 1 && (o.transparent = !0), t.ReflectionFactor && (o.reflectivity = t.ReflectionFactor.value), t.Shininess && (o.shininess = t.Shininess.value), t.Specular ? o.specular = (new r["j"]).fromArray(t.Specular.value) : t.SpecularColor && "Color" === t.SpecularColor.type && (o.specular = (new r["j"]).fromArray(t.SpecularColor.value));
                        var a = this;
                        return e.get(i).children.forEach((function(t) {
                            var e = t.relationship;
                            switch (e) {
                                case "Bump":
                                    o.bumpMap = a.getTexture(n, t.ID);
                                    break;
                                case "Maya|TEX_ao_map":
                                    o.aoMap = a.getTexture(n, t.ID);
                                    break;
                                case "DiffuseColor":
                                case "Maya|TEX_color_map":
                                    o.map = a.getTexture(n, t.ID), o.map.encoding = r["Wb"];
                                    break;
                                case "DisplacementColor":
                                    o.displacementMap = a.getTexture(n, t.ID);
                                    break;
                                case "EmissiveColor":
                                    o.emissiveMap = a.getTexture(n, t.ID), o.emissiveMap.encoding = r["Wb"];
                                    break;
                                case "NormalMap":
                                case "Maya|TEX_normal_map":
                                    o.normalMap = a.getTexture(n, t.ID);
                                    break;
                                case "ReflectionColor":
                                    o.envMap = a.getTexture(n, t.ID), o.envMap.mapping = r["q"], o.envMap.encoding = r["Wb"];
                                    break;
                                case "SpecularColor":
                                    o.specularMap = a.getTexture(n, t.ID), o.specularMap.encoding = r["Wb"];
                                    break;
                                case "TransparentColor":
                                case "TransparencyFactor":
                                    o.alphaMap = a.getTexture(n, t.ID), o.transparent = !0;
                                    break;
                                case "AmbientColor":
                                case "ShininessExponent":
                                case "SpecularFactor":
                                case "VectorDisplacementColor":
                                default:
                                    console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", e);
                                    break
                            }
                        })), o
                    },
                    getTexture: function(n, r) {
                        return "LayeredTexture" in t.Objects && r in t.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), r = e.get(r).children[0].ID), n.get(r)
                    },
                    parseDeformers: function() {
                        var n = {},
                            r = {};
                        if ("Deformer" in t.Objects) {
                            var i = t.Objects.Deformer;
                            for (var o in i) {
                                var a = i[o],
                                    s = e.get(parseInt(o));
                                if ("Skin" === a.attrType) {
                                    var c = this.parseSkeleton(s, i);
                                    c.ID = o, s.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), c.geometryID = s.parents[0].ID, n[o] = c
                                } else if ("BlendShape" === a.attrType) {
                                    var l = {
                                        id: o
                                    };
                                    l.rawTargets = this.parseMorphTargets(s, i), l.id = o, s.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), r[o] = l
                                }
                            }
                        }
                        return {
                            skeletons: n,
                            morphTargets: r
                        }
                    },
                    parseSkeleton: function(t, e) {
                        var n = [];
                        return t.children.forEach((function(t) {
                            var i = e[t.ID];
                            if ("Cluster" === i.attrType) {
                                var o = {
                                    ID: t.ID,
                                    indices: [],
                                    weights: [],
                                    transformLink: (new r["S"]).fromArray(i.TransformLink.a)
                                };
                                "Indexes" in i && (o.indices = i.Indexes.a, o.weights = i.Weights.a), n.push(o)
                            }
                        })), {
                            rawBones: n,
                            bones: []
                        }
                    },
                    parseMorphTargets: function(t, n) {
                        for (var r = [], i = 0; i < t.children.length; i++) {
                            var o = t.children[i],
                                a = n[o.ID],
                                s = {
                                    name: a.attrName,
                                    initialWeight: a.DeformPercent,
                                    id: a.id,
                                    fullWeights: a.FullWeights.a
                                };
                            if ("BlendShapeChannel" !== a.attrType) return;
                            s.geoID = e.get(parseInt(o.ID)).children.filter((function(t) {
                                return void 0 === t.relationship
                            }))[0].ID, r.push(s)
                        }
                        return r
                    },
                    parseScene: function(i, o, a) {
                        n = new r["x"];
                        var c = this.parseModels(i.skeletons, o, a),
                            l = t.Objects.Model,
                            u = this;
                        c.forEach((function(t) {
                            var r = l[t.ID];
                            u.setLookAtProperties(t, r);
                            var i = e.get(t.ID).parents;
                            i.forEach((function(e) {
                                var n = c.get(e.ID);
                                void 0 !== n && n.add(t)
                            })), null === t.parent && n.add(t)
                        })), this.bindSkeleton(i.skeletons, o, c), this.createAmbientLight(), this.setupMorphMaterials(), n.traverse((function(t) {
                            if (t.userData.transformData) {
                                t.parent && (t.userData.transformData.parentMatrixWorld = t.parent.matrix);
                                var e = b(t.userData.transformData);
                                t.applyMatrix4(e)
                            }
                        }));
                        var h = (new s).parse();
                        1 === n.children.length && n.children[0].isGroup && (n.children[0].animations = h, n = n.children[0]), n.animations = h
                    },
                    parseModels: function(n, i, o) {
                        var a = new Map,
                            s = t.Objects.Model;
                        for (var c in s) {
                            var l = parseInt(c),
                                u = s[c],
                                h = e.get(l),
                                d = this.buildSkeleton(h, n, l, u.attrName);
                            if (!d) {
                                switch (u.attrType) {
                                    case "Camera":
                                        d = this.createCamera(h);
                                        break;
                                    case "Light":
                                        d = this.createLight(h);
                                        break;
                                    case "Mesh":
                                        d = this.createMesh(h, i, o);
                                        break;
                                    case "NurbsCurve":
                                        d = this.createCurve(h, i);
                                        break;
                                    case "LimbNode":
                                    case "Root":
                                        d = new r["c"];
                                        break;
                                    case "Null":
                                    default:
                                        d = new r["x"];
                                        break
                                }
                                d.name = u.attrName ? r["ob"].sanitizeNodeName(u.attrName) : "", d.ID = l
                            }
                            this.getTransformData(d, u), a.set(l, d)
                        }
                        return a
                    },
                    buildSkeleton: function(t, e, n, i) {
                        var o = null;
                        return t.parents.forEach((function(t) {
                            for (var a in e) {
                                var s = e[a];
                                s.rawBones.forEach((function(e, a) {
                                    if (e.ID === t.ID) {
                                        var c = o;
                                        o = new r["c"], o.matrixWorld.copy(e.transformLink), o.name = i ? r["ob"].sanitizeNodeName(i) : "", o.ID = n, s.bones[a] = o, null !== c && o.add(c)
                                    }
                                }))
                            }
                        })), o
                    },
                    createCamera: function(e) {
                        var n, i;
                        if (e.children.forEach((function(e) {
                                var n = t.Objects.NodeAttribute[e.ID];
                                void 0 !== n && (i = n)
                            })), void 0 === i) n = new r["fb"];
                        else {
                            var o = 0;
                            void 0 !== i.CameraProjectionType && 1 === i.CameraProjectionType.value && (o = 1);
                            var a = 1;
                            void 0 !== i.NearPlane && (a = i.NearPlane.value / 1e3);
                            var s = 1e3;
                            void 0 !== i.FarPlane && (s = i.FarPlane.value / 1e3);
                            var c = window.innerWidth,
                                l = window.innerHeight;
                            void 0 !== i.AspectWidth && void 0 !== i.AspectHeight && (c = i.AspectWidth.value, l = i.AspectHeight.value);
                            var u = c / l,
                                h = 45;
                            void 0 !== i.FieldOfView && (h = i.FieldOfView.value);
                            var d = i.FocalLength ? i.FocalLength.value : null;
                            switch (o) {
                                case 0:
                                    n = new r["ib"](h, u, a, s), null !== d && n.setFocalLength(d);
                                    break;
                                case 1:
                                    n = new r["gb"](-c / 2, c / 2, l / 2, -l / 2, a, s);
                                    break;
                                default:
                                    console.warn("THREE.FBXLoader: Unknown camera type " + o + "."), n = new r["fb"];
                                    break
                            }
                        }
                        return n
                    },
                    createLight: function(e) {
                        var n, i;
                        if (e.children.forEach((function(e) {
                                var n = t.Objects.NodeAttribute[e.ID];
                                void 0 !== n && (i = n)
                            })), void 0 === i) n = new r["fb"];
                        else {
                            var o;
                            o = void 0 === i.LightType ? 0 : i.LightType.value;
                            var a = 16777215;
                            void 0 !== i.Color && (a = (new r["j"]).fromArray(i.Color.value));
                            var s = void 0 === i.Intensity ? 1 : i.Intensity.value / 100;
                            void 0 !== i.CastLightOnObject && 0 === i.CastLightOnObject.value && (s = 0);
                            var c = 0;
                            void 0 !== i.FarAttenuationEnd && (c = void 0 !== i.EnableFarAttenuation && 0 === i.EnableFarAttenuation.value ? 0 : i.FarAttenuationEnd.value);
                            var l = 1;
                            switch (o) {
                                case 0:
                                    n = new r["lb"](a, s, c, l);
                                    break;
                                case 1:
                                    n = new r["m"](a, s);
                                    break;
                                case 2:
                                    var u = Math.PI / 3;
                                    void 0 !== i.InnerAngle && (u = r["Q"].degToRad(i.InnerAngle.value));
                                    var h = 0;
                                    void 0 !== i.OuterAngle && (h = r["Q"].degToRad(i.OuterAngle.value), h = Math.max(h, 1)), n = new r["Fb"](a, s, c, u, h, l);
                                    break;
                                default:
                                    console.warn("THREE.FBXLoader: Unknown light type " + i.LightType.value + ", defaulting to a PointLight."), n = new r["lb"](a, s);
                                    break
                            }
                            void 0 !== i.CastShadows && 1 === i.CastShadows.value && (n.castShadow = !0)
                        }
                        return n
                    },
                    createMesh: function(t, e, n) {
                        var i, o = null,
                            a = null,
                            s = [];
                        return t.children.forEach((function(t) {
                            e.has(t.ID) && (o = e.get(t.ID)), n.has(t.ID) && s.push(n.get(t.ID))
                        })), s.length > 1 ? a = s : s.length > 0 ? a = s[0] : (a = new r["W"]({
                            color: 13421772
                        }), s.push(a)), "color" in o.attributes && s.forEach((function(t) {
                            t.vertexColors = !0
                        })), o.FBX_Deformer ? (s.forEach((function(t) {
                            t.skinning = !0
                        })), i = new r["Bb"](o, a), i.normalizeSkinWeights()) : i = new r["T"](o, a), i
                    },
                    createCurve: function(t, e) {
                        var n = t.children.reduce((function(t, n) {
                                return e.has(n.ID) && (t = e.get(n.ID)), t
                            }), null),
                            i = new r["G"]({
                                color: 3342591,
                                linewidth: 1
                            });
                        return new r["F"](n, i)
                    },
                    getTransformData: function(t, e) {
                        var n = {};
                        "InheritType" in e && (n.inheritType = parseInt(e.InheritType.value)), n.eulerOrder = "RotationOrder" in e ? x(e.RotationOrder.value) : "ZYX", "Lcl_Translation" in e && (n.translation = e.Lcl_Translation.value), "PreRotation" in e && (n.preRotation = e.PreRotation.value), "Lcl_Rotation" in e && (n.rotation = e.Lcl_Rotation.value), "PostRotation" in e && (n.postRotation = e.PostRotation.value), "Lcl_Scaling" in e && (n.scale = e.Lcl_Scaling.value), "ScalingOffset" in e && (n.scalingOffset = e.ScalingOffset.value), "ScalingPivot" in e && (n.scalingPivot = e.ScalingPivot.value), "RotationOffset" in e && (n.rotationOffset = e.RotationOffset.value), "RotationPivot" in e && (n.rotationPivot = e.RotationPivot.value), t.userData.transformData = n
                    },
                    setLookAtProperties: function(i, o) {
                        if ("LookAtProperty" in o) {
                            var a = e.get(i.ID).children;
                            a.forEach((function(e) {
                                if ("LookAtProperty" === e.relationship) {
                                    var o = t.Objects.Model[e.ID];
                                    if ("Lcl_Translation" in o) {
                                        var a = o.Lcl_Translation.value;
                                        void 0 !== i.target ? (i.target.position.fromArray(a), n.add(i.target)) : i.lookAt((new r["Rb"]).fromArray(a))
                                    }
                                }
                            }))
                        }
                    },
                    bindSkeleton: function(t, n, i) {
                        var o = this.parsePoseNodes();
                        for (var a in t) {
                            var s = t[a],
                                c = e.get(parseInt(s.ID)).parents;
                            c.forEach((function(t) {
                                if (n.has(t.ID)) {
                                    var a = t.ID,
                                        c = e.get(a);
                                    c.parents.forEach((function(t) {
                                        if (i.has(t.ID)) {
                                            var e = i.get(t.ID);
                                            e.bind(new r["Ab"](s.bones), o[t.ID])
                                        }
                                    }))
                                }
                            }))
                        }
                    },
                    parsePoseNodes: function() {
                        var e = {};
                        if ("Pose" in t.Objects) {
                            var n = t.Objects.Pose;
                            for (var i in n)
                                if ("BindPose" === n[i].attrType) {
                                    var o = n[i].PoseNode;
                                    Array.isArray(o) ? o.forEach((function(t) {
                                        e[t.Node] = (new r["S"]).fromArray(t.Matrix.a)
                                    })) : e[o.Node] = (new r["S"]).fromArray(o.Matrix.a)
                                }
                        }
                        return e
                    },
                    createAmbientLight: function() {
                        if ("GlobalSettings" in t && "AmbientColor" in t.GlobalSettings) {
                            var e = t.GlobalSettings.AmbientColor.value,
                                i = e[0],
                                o = e[1],
                                a = e[2];
                            if (0 !== i || 0 !== o || 0 !== a) {
                                var s = new r["j"](i, o, a);
                                n.add(new r["a"](s, 1))
                            }
                        }
                    },
                    setupMorphMaterials: function() {
                        var t = this;
                        n.traverse((function(e) {
                            e.isMesh && e.geometry.morphAttributes.position && e.geometry.morphAttributes.position.length && (Array.isArray(e.material) ? e.material.forEach((function(n, r) {
                                t.setupMorphMaterial(e, n, r)
                            })) : t.setupMorphMaterial(e, e.material))
                        }))
                    },
                    setupMorphMaterial: function(t, e, r) {
                        var i = t.uuid,
                            o = e.uuid,
                            a = !1;
                        if (n.traverse((function(t) {
                                t.isMesh && (Array.isArray(t.material) ? t.material.forEach((function(e) {
                                    e.uuid === o && t.uuid !== i && (a = !0)
                                })) : t.material.uuid === o && t.uuid !== i && (a = !0))
                            })), !0 === a) {
                            var s = e.clone();
                            s.morphTargets = !0, void 0 === r ? t.material = s : t.material[r] = s
                        } else e.morphTargets = !0
                    }
                }, a.prototype = {
                    constructor: a,
                    parse: function(n) {
                        var r = new Map;
                        if ("Geometry" in t.Objects) {
                            var i = t.Objects.Geometry;
                            for (var o in i) {
                                var a = e.get(parseInt(o)),
                                    s = this.parseGeometry(a, i[o], n);
                                r.set(parseInt(o), s)
                            }
                        }
                        return r
                    },
                    parseGeometry: function(t, e, n) {
                        switch (e.attrType) {
                            case "Mesh":
                                return this.parseMeshGeometry(t, e, n);
                            case "NurbsCurve":
                                return this.parseNurbsGeometry(e)
                        }
                    },
                    parseMeshGeometry: function(e, n, r) {
                        var i = r.skeletons,
                            o = [],
                            a = e.parents.map((function(e) {
                                return t.Objects.Model[e.ID]
                            }));
                        if (0 !== a.length) {
                            var s = e.children.reduce((function(t, e) {
                                return void 0 !== i[e.ID] && (t = i[e.ID]), t
                            }), null);
                            e.children.forEach((function(t) {
                                void 0 !== r.morphTargets[t.ID] && o.push(r.morphTargets[t.ID])
                            }));
                            var c = a[0],
                                l = {};
                            "RotationOrder" in c && (l.eulerOrder = x(c.RotationOrder.value)), "InheritType" in c && (l.inheritType = parseInt(c.InheritType.value)), "GeometricTranslation" in c && (l.translation = c.GeometricTranslation.value), "GeometricRotation" in c && (l.rotation = c.GeometricRotation.value), "GeometricScaling" in c && (l.scale = c.GeometricScaling.value);
                            var u = b(l);
                            return this.genGeometry(n, s, o, u)
                        }
                    },
                    genGeometry: function(t, e, n, i) {
                        var o = new r["f"];
                        t.attrName && (o.name = t.attrName);
                        var a = this.parseGeoNode(t, e),
                            s = this.genBuffers(a),
                            c = new r["u"](s.vertex, 3);
                        if (c.applyMatrix4(i), o.setAttribute("position", c), s.colors.length > 0 && o.setAttribute("color", new r["u"](s.colors, 3)), e && (o.setAttribute("skinIndex", new r["Nb"](s.weightsIndices, 4)), o.setAttribute("skinWeight", new r["u"](s.vertexWeights, 4)), o.FBX_Deformer = e), s.normal.length > 0) {
                            var l = (new r["R"]).getNormalMatrix(i),
                                u = new r["u"](s.normal, 3);
                            u.applyNormalMatrix(l), o.setAttribute("normal", u)
                        }
                        if (s.uvs.forEach((function(t, e) {
                                var n = "uv" + (e + 1).toString();
                                0 === e && (n = "uv"), o.setAttribute(n, new r["u"](s.uvs[e], 2))
                            })), a.material && "AllSame" !== a.material.mappingType) {
                            var h = s.materialIndex[0],
                                d = 0;
                            if (s.materialIndex.forEach((function(t, e) {
                                    t !== h && (o.addGroup(d, e - d, h), h = t, d = e)
                                })), o.groups.length > 0) {
                                var p = o.groups[o.groups.length - 1],
                                    f = p.start + p.count;
                                f !== s.materialIndex.length && o.addGroup(f, s.materialIndex.length - f, h)
                            }
                            0 === o.groups.length && o.addGroup(0, s.materialIndex.length, s.materialIndex[0])
                        }
                        return this.addMorphTargets(o, t, n, i), o
                    },
                    parseGeoNode: function(t, e) {
                        var n = {};
                        if (n.vertexPositions = void 0 !== t.Vertices ? t.Vertices.a : [], n.vertexIndices = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [], t.LayerElementColor && (n.color = this.parseVertexColors(t.LayerElementColor[0])), t.LayerElementMaterial && (n.material = this.parseMaterialIndices(t.LayerElementMaterial[0])), t.LayerElementNormal && (n.normal = this.parseNormals(t.LayerElementNormal[0])), t.LayerElementUV) {
                            n.uv = [];
                            var r = 0;
                            while (t.LayerElementUV[r]) t.LayerElementUV[r].UV && n.uv.push(this.parseUVs(t.LayerElementUV[r])), r++
                        }
                        return n.weightTable = {}, null !== e && (n.skeleton = e, e.rawBones.forEach((function(t, e) {
                            t.indices.forEach((function(r, i) {
                                void 0 === n.weightTable[r] && (n.weightTable[r] = []), n.weightTable[r].push({
                                    id: e,
                                    weight: t.weights[i]
                                })
                            }))
                        }))), n
                    },
                    genBuffers: function(t) {
                        var e = {
                                vertex: [],
                                normal: [],
                                colors: [],
                                uvs: [],
                                materialIndex: [],
                                vertexWeights: [],
                                weightsIndices: []
                            },
                            n = 0,
                            r = 0,
                            i = !1,
                            o = [],
                            a = [],
                            s = [],
                            c = [],
                            l = [],
                            u = [],
                            h = this;
                        return t.vertexIndices.forEach((function(d, p) {
                            var f = !1;
                            d < 0 && (d ^= -1, f = !0);
                            var m = [],
                                g = [];
                            if (o.push(3 * d, 3 * d + 1, 3 * d + 2), t.color) {
                                var y = v(p, n, d, t.color);
                                s.push(y[0], y[1], y[2])
                            }
                            if (t.skeleton) {
                                if (void 0 !== t.weightTable[d] && t.weightTable[d].forEach((function(t) {
                                        g.push(t.weight), m.push(t.id)
                                    })), g.length > 4) {
                                    i || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), i = !0);
                                    var _ = [0, 0, 0, 0],
                                        b = [0, 0, 0, 0];
                                    g.forEach((function(t, e) {
                                        var n = t,
                                            r = m[e];
                                        b.forEach((function(t, e, i) {
                                            if (n > t) {
                                                i[e] = n, n = t;
                                                var o = _[e];
                                                _[e] = r, r = o
                                            }
                                        }))
                                    })), m = _, g = b
                                }
                                while (g.length < 4) g.push(0), m.push(0);
                                for (var x = 0; x < 4; ++x) l.push(g[x]), u.push(m[x])
                            }
                            if (t.normal) {
                                y = v(p, n, d, t.normal);
                                a.push(y[0], y[1], y[2])
                            }
                            if (t.material && "AllSame" !== t.material.mappingType) var w = v(p, n, d, t.material)[0];
                            t.uv && t.uv.forEach((function(t, e) {
                                var r = v(p, n, d, t);
                                void 0 === c[e] && (c[e] = []), c[e].push(r[0]), c[e].push(r[1])
                            })), r++, f && (h.genFace(e, t, o, w, a, s, c, l, u, r), n++, r = 0, o = [], a = [], s = [], c = [], l = [], u = [])
                        })), e
                    },
                    genFace: function(t, e, n, r, i, o, a, s, c, l) {
                        for (var u = 2; u < l; u++) t.vertex.push(e.vertexPositions[n[0]]), t.vertex.push(e.vertexPositions[n[1]]), t.vertex.push(e.vertexPositions[n[2]]), t.vertex.push(e.vertexPositions[n[3 * (u - 1)]]), t.vertex.push(e.vertexPositions[n[3 * (u - 1) + 1]]), t.vertex.push(e.vertexPositions[n[3 * (u - 1) + 2]]), t.vertex.push(e.vertexPositions[n[3 * u]]), t.vertex.push(e.vertexPositions[n[3 * u + 1]]), t.vertex.push(e.vertexPositions[n[3 * u + 2]]), e.skeleton && (t.vertexWeights.push(s[0]), t.vertexWeights.push(s[1]), t.vertexWeights.push(s[2]), t.vertexWeights.push(s[3]), t.vertexWeights.push(s[4 * (u - 1)]), t.vertexWeights.push(s[4 * (u - 1) + 1]), t.vertexWeights.push(s[4 * (u - 1) + 2]), t.vertexWeights.push(s[4 * (u - 1) + 3]), t.vertexWeights.push(s[4 * u]), t.vertexWeights.push(s[4 * u + 1]), t.vertexWeights.push(s[4 * u + 2]), t.vertexWeights.push(s[4 * u + 3]), t.weightsIndices.push(c[0]), t.weightsIndices.push(c[1]), t.weightsIndices.push(c[2]), t.weightsIndices.push(c[3]), t.weightsIndices.push(c[4 * (u - 1)]), t.weightsIndices.push(c[4 * (u - 1) + 1]), t.weightsIndices.push(c[4 * (u - 1) + 2]), t.weightsIndices.push(c[4 * (u - 1) + 3]), t.weightsIndices.push(c[4 * u]), t.weightsIndices.push(c[4 * u + 1]), t.weightsIndices.push(c[4 * u + 2]), t.weightsIndices.push(c[4 * u + 3])), e.color && (t.colors.push(o[0]), t.colors.push(o[1]), t.colors.push(o[2]), t.colors.push(o[3 * (u - 1)]), t.colors.push(o[3 * (u - 1) + 1]), t.colors.push(o[3 * (u - 1) + 2]), t.colors.push(o[3 * u]), t.colors.push(o[3 * u + 1]), t.colors.push(o[3 * u + 2])), e.material && "AllSame" !== e.material.mappingType && (t.materialIndex.push(r), t.materialIndex.push(r), t.materialIndex.push(r)), e.normal && (t.normal.push(i[0]), t.normal.push(i[1]), t.normal.push(i[2]), t.normal.push(i[3 * (u - 1)]), t.normal.push(i[3 * (u - 1) + 1]), t.normal.push(i[3 * (u - 1) + 2]), t.normal.push(i[3 * u]), t.normal.push(i[3 * u + 1]), t.normal.push(i[3 * u + 2])), e.uv && e.uv.forEach((function(e, n) {
                            void 0 === t.uvs[n] && (t.uvs[n] = []), t.uvs[n].push(a[n][0]), t.uvs[n].push(a[n][1]), t.uvs[n].push(a[n][2 * (u - 1)]), t.uvs[n].push(a[n][2 * (u - 1) + 1]), t.uvs[n].push(a[n][2 * u]), t.uvs[n].push(a[n][2 * u + 1])
                        }))
                    },
                    addMorphTargets: function(e, n, r, i) {
                        if (0 !== r.length) {
                            e.morphTargetsRelative = !0, e.morphAttributes.position = [];
                            var o = this;
                            r.forEach((function(r) {
                                r.rawTargets.forEach((function(r) {
                                    var a = t.Objects.Geometry[r.geoID];
                                    void 0 !== a && o.genMorphGeometry(e, n, a, i, r.name)
                                }))
                            }))
                        }
                    },
                    genMorphGeometry: function(t, e, n, i, o) {
                        for (var a = void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : [], s = void 0 !== n.Vertices ? n.Vertices.a : [], c = void 0 !== n.Indexes ? n.Indexes.a : [], l = 3 * t.attributes.position.count, u = new Float32Array(l), h = 0; h < c.length; h++) {
                            var d = 3 * c[h];
                            u[d] = s[3 * h], u[d + 1] = s[3 * h + 1], u[d + 2] = s[3 * h + 2]
                        }
                        var p = {
                                vertexIndices: a,
                                vertexPositions: u
                            },
                            f = this.genBuffers(p),
                            m = new r["u"](f.vertex, 3);
                        m.name = o || n.attrName, m.applyMatrix4(i), t.morphAttributes.position.push(m)
                    },
                    parseNormals: function(t) {
                        var e = t.MappingInformationType,
                            n = t.ReferenceInformationType,
                            r = t.Normals.a,
                            i = [];
                        return "IndexToDirect" === n && ("NormalIndex" in t ? i = t.NormalIndex.a : "NormalsIndex" in t && (i = t.NormalsIndex.a)), {
                            dataSize: 3,
                            buffer: r,
                            indices: i,
                            mappingType: e,
                            referenceType: n
                        }
                    },
                    parseUVs: function(t) {
                        var e = t.MappingInformationType,
                            n = t.ReferenceInformationType,
                            r = t.UV.a,
                            i = [];
                        return "IndexToDirect" === n && (i = t.UVIndex.a), {
                            dataSize: 2,
                            buffer: r,
                            indices: i,
                            mappingType: e,
                            referenceType: n
                        }
                    },
                    parseVertexColors: function(t) {
                        var e = t.MappingInformationType,
                            n = t.ReferenceInformationType,
                            r = t.Colors.a,
                            i = [];
                        return "IndexToDirect" === n && (i = t.ColorIndex.a), {
                            dataSize: 4,
                            buffer: r,
                            indices: i,
                            mappingType: e,
                            referenceType: n
                        }
                    },
                    parseMaterialIndices: function(t) {
                        var e = t.MappingInformationType,
                            n = t.ReferenceInformationType;
                        if ("NoMappingInformation" === e) return {
                            dataSize: 1,
                            buffer: [0],
                            indices: [0],
                            mappingType: "AllSame",
                            referenceType: n
                        };
                        for (var r = t.Materials.a, i = [], o = 0; o < r.length; ++o) i.push(o);
                        return {
                            dataSize: 1,
                            buffer: r,
                            indices: i,
                            mappingType: e,
                            referenceType: n
                        }
                    },
                    parseNurbsGeometry: function(t) {
                        if (void 0 === G) return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new r["f"];
                        var e = parseInt(t.Order);
                        if (isNaN(e)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", t.Order, t.id), new r["f"];
                        for (var n, i, o = e - 1, a = t.KnotVector.a, s = [], c = t.Points.a, l = 0, u = c.length; l < u; l += 4) s.push((new r["Sb"]).fromArray(c, l));
                        if ("Closed" === t.Form) s.push(s[0]);
                        else if ("Periodic" === t.Form) {
                            n = o, i = a.length - 1 - n;
                            for (l = 0; l < o; ++l) s.push(s[l])
                        }
                        var h = new G(o, a, s, n, i),
                            d = h.getPoints(7 * s.length),
                            p = new Float32Array(3 * d.length);
                        d.forEach((function(t, e) {
                            t.toArray(p, 3 * e)
                        }));
                        var f = new r["f"];
                        return f.setAttribute("position", new r["e"](p, 3)), f
                    }
                }, s.prototype = {
                    constructor: s,
                    parse: function() {
                        var t = [],
                            e = this.parseClips();
                        if (void 0 !== e)
                            for (var n in e) {
                                var r = e[n],
                                    i = this.addClip(r);
                                t.push(i)
                            }
                        return t
                    },
                    parseClips: function() {
                        if (void 0 !== t.Objects.AnimationCurve) {
                            var e = this.parseAnimationCurveNodes();
                            this.parseAnimationCurves(e);
                            var n = this.parseAnimationLayers(e),
                                r = this.parseAnimStacks(n);
                            return r
                        }
                    },
                    parseAnimationCurveNodes: function() {
                        var e = t.Objects.AnimationCurveNode,
                            n = new Map;
                        for (var r in e) {
                            var i = e[r];
                            if (null !== i.attrName.match(/S|R|T|DeformPercent/)) {
                                var o = {
                                    id: i.id,
                                    attr: i.attrName,
                                    curves: {}
                                };
                                n.set(o.id, o)
                            }
                        }
                        return n
                    },
                    parseAnimationCurves: function(n) {
                        var r = t.Objects.AnimationCurve;
                        for (var i in r) {
                            var o = {
                                    id: r[i].id,
                                    times: r[i].KeyTime.a.map(m),
                                    values: r[i].KeyValueFloat.a
                                },
                                a = e.get(o.id);
                            if (void 0 !== a) {
                                var s = a.parents[0].ID,
                                    c = a.parents[0].relationship;
                                c.match(/X/) ? n.get(s).curves["x"] = o : c.match(/Y/) ? n.get(s).curves["y"] = o : c.match(/Z/) ? n.get(s).curves["z"] = o : c.match(/d|DeformPercent/) && n.has(s) && (n.get(s).curves["morph"] = o)
                            }
                        }
                    },
                    parseAnimationLayers: function(i) {
                        var o = t.Objects.AnimationLayer,
                            a = new Map;
                        for (var s in o) {
                            var c = [],
                                l = e.get(parseInt(s));
                            if (void 0 !== l) {
                                var u = l.children;
                                u.forEach((function(o, a) {
                                    if (i.has(o.ID)) {
                                        var s = i.get(o.ID);
                                        if (void 0 !== s.curves.x || void 0 !== s.curves.y || void 0 !== s.curves.z) {
                                            if (void 0 === c[a]) {
                                                var l = e.get(o.ID).parents.filter((function(t) {
                                                    return void 0 !== t.relationship
                                                }))[0].ID;
                                                if (void 0 !== l) {
                                                    var u = t.Objects.Model[l.toString()];
                                                    if (void 0 === u) return void console.warn("THREE.FBXLoader: Encountered a unused curve.", o);
                                                    var h = {
                                                        modelName: u.attrName ? r["ob"].sanitizeNodeName(u.attrName) : "",
                                                        ID: u.id,
                                                        initialPosition: [0, 0, 0],
                                                        initialRotation: [0, 0, 0],
                                                        initialScale: [1, 1, 1]
                                                    };
                                                    n.traverse((function(t) {
                                                        t.ID === u.id && (h.transform = t.matrix, t.userData.transformData && (h.eulerOrder = t.userData.transformData.eulerOrder))
                                                    })), h.transform || (h.transform = new r["S"]), "PreRotation" in u && (h.preRotation = u.PreRotation.value), "PostRotation" in u && (h.postRotation = u.PostRotation.value), c[a] = h
                                                }
                                            }
                                            c[a] && (c[a][s.attr] = s)
                                        } else if (void 0 !== s.curves.morph) {
                                            if (void 0 === c[a]) {
                                                var d = e.get(o.ID).parents.filter((function(t) {
                                                        return void 0 !== t.relationship
                                                    }))[0].ID,
                                                    p = e.get(d).parents[0].ID,
                                                    f = e.get(p).parents[0].ID;
                                                l = e.get(f).parents[0].ID, u = t.Objects.Model[l], h = {
                                                    modelName: u.attrName ? r["ob"].sanitizeNodeName(u.attrName) : "",
                                                    morphName: t.Objects.Deformer[d].attrName
                                                };
                                                c[a] = h
                                            }
                                            c[a][s.attr] = s
                                        }
                                    }
                                })), a.set(parseInt(s), c)
                            }
                        }
                        return a
                    },
                    parseAnimStacks: function(n) {
                        var r = t.Objects.AnimationStack,
                            i = {};
                        for (var o in r) {
                            var a = e.get(parseInt(o)).children;
                            a.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
                            var s = n.get(a[0].ID);
                            i[o] = {
                                name: r[o].attrName,
                                layer: s
                            }
                        }
                        return i
                    },
                    addClip: function(t) {
                        var e = [],
                            n = this;
                        return t.layer.forEach((function(t) {
                            e = e.concat(n.generateTracks(t))
                        })), new r["b"](t.name, -1, e)
                    },
                    generateTracks: function(t) {
                        var e = [],
                            n = new r["Rb"],
                            i = new r["pb"],
                            o = new r["Rb"];
                        if (t.transform && t.transform.decompose(n, i, o), n = n.toArray(), i = (new r["r"]).setFromQuaternion(i, t.eulerOrder).toArray(), o = o.toArray(), void 0 !== t.T && Object.keys(t.T.curves).length > 0) {
                            var a = this.generateVectorTrack(t.modelName, t.T.curves, n, "position");
                            void 0 !== a && e.push(a)
                        }
                        if (void 0 !== t.R && Object.keys(t.R.curves).length > 0) {
                            var s = this.generateRotationTrack(t.modelName, t.R.curves, i, t.preRotation, t.postRotation, t.eulerOrder);
                            void 0 !== s && e.push(s)
                        }
                        if (void 0 !== t.S && Object.keys(t.S.curves).length > 0) {
                            var c = this.generateVectorTrack(t.modelName, t.S.curves, o, "scale");
                            void 0 !== c && e.push(c)
                        }
                        if (void 0 !== t.DeformPercent) {
                            var l = this.generateMorphTrack(t);
                            void 0 !== l && e.push(l)
                        }
                        return e
                    },
                    generateVectorTrack: function(t, e, n, i) {
                        var o = this.getTimesForAllAxes(e),
                            a = this.getKeyframeTrackValues(o, e, n);
                        return new r["Tb"](t + "." + i, o, a)
                    },
                    generateRotationTrack: function(t, e, n, i, o, a) {
                        void 0 !== e.x && (this.interpolateRotations(e.x), e.x.values = e.x.values.map(r["Q"].degToRad)), void 0 !== e.y && (this.interpolateRotations(e.y), e.y.values = e.y.values.map(r["Q"].degToRad)), void 0 !== e.z && (this.interpolateRotations(e.z), e.z.values = e.z.values.map(r["Q"].degToRad));
                        var s = this.getTimesForAllAxes(e),
                            c = this.getKeyframeTrackValues(s, e, n);
                        void 0 !== i && (i = i.map(r["Q"].degToRad), i.push(a), i = (new r["r"]).fromArray(i), i = (new r["pb"]).setFromEuler(i)), void 0 !== o && (o = o.map(r["Q"].degToRad), o.push(a), o = (new r["r"]).fromArray(o), o = (new r["pb"]).setFromEuler(o).inverse());
                        for (var l = new r["pb"], u = new r["r"], h = [], d = 0; d < c.length; d += 3) u.set(c[d], c[d + 1], c[d + 2], a), l.setFromEuler(u), void 0 !== i && l.premultiply(i), void 0 !== o && l.multiply(o), l.toArray(h, d / 3 * 4);
                        return new r["qb"](t + ".quaternion", s, h)
                    },
                    generateMorphTrack: function(t) {
                        var e = t.DeformPercent.curves.morph,
                            i = e.values.map((function(t) {
                                return t / 100
                            })),
                            o = n.getObjectByName(t.modelName).morphTargetDictionary[t.morphName];
                        return new r["eb"](t.modelName + ".morphTargetInfluences[" + o + "]", e.times, i)
                    },
                    getTimesForAllAxes: function(t) {
                        var e = [];
                        return void 0 !== t.x && (e = e.concat(t.x.times)), void 0 !== t.y && (e = e.concat(t.y.times)), void 0 !== t.z && (e = e.concat(t.z.times)), e = e.sort((function(t, e) {
                            return t - e
                        })).filter((function(t, e, n) {
                            return n.indexOf(t) == e
                        })), e
                    },
                    getKeyframeTrackValues: function(t, e, n) {
                        var r = n,
                            i = [],
                            o = -1,
                            a = -1,
                            s = -1;
                        return t.forEach((function(t) {
                            if (e.x && (o = e.x.times.indexOf(t)), e.y && (a = e.y.times.indexOf(t)), e.z && (s = e.z.times.indexOf(t)), -1 !== o) {
                                var n = e.x.values[o];
                                i.push(n), r[0] = n
                            } else i.push(r[0]);
                            if (-1 !== a) {
                                var c = e.y.values[a];
                                i.push(c), r[1] = c
                            } else i.push(r[1]);
                            if (-1 !== s) {
                                var l = e.z.values[s];
                                i.push(l), r[2] = l
                            } else i.push(r[2])
                        })), i
                    },
                    interpolateRotations: function(t) {
                        for (var e = 1; e < t.values.length; e++) {
                            var n = t.values[e - 1],
                                r = t.values[e] - n,
                                i = Math.abs(r);
                            if (i >= 180) {
                                var o = i / 180,
                                    a = r / o,
                                    s = n + a,
                                    c = t.times[e - 1],
                                    l = t.times[e] - c,
                                    u = l / o,
                                    h = c + u,
                                    d = [],
                                    p = [];
                                while (h < t.times[e]) d.push(h), h += u, p.push(s), s += a;
                                t.times = E(t.times, e, d), t.values = E(t.values, e, p)
                            }
                        }
                    }
                }, c.prototype = {
                    constructor: c,
                    getPrevNode: function() {
                        return this.nodeStack[this.currentIndent - 2]
                    },
                    getCurrentNode: function() {
                        return this.nodeStack[this.currentIndent - 1]
                    },
                    getCurrentProp: function() {
                        return this.currentProp
                    },
                    pushStack: function(t) {
                        this.nodeStack.push(t), this.currentIndent += 1
                    },
                    popStack: function() {
                        this.nodeStack.pop(), this.currentIndent -= 1
                    },
                    setCurrentProp: function(t, e) {
                        this.currentProp = t, this.currentPropName = e
                    },
                    parse: function(t) {
                        this.currentIndent = 0, this.allNodes = new h, this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
                        var e = this,
                            n = t.split(/[\r\n]+/);
                        return n.forEach((function(t, r) {
                            var i = t.match(/^[\s\t]*;/),
                                o = t.match(/^[\s\t]*$/);
                            if (!i && !o) {
                                var a = t.match("^\\t{" + e.currentIndent + "}(\\w+):(.*){", ""),
                                    s = t.match("^\\t{" + e.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"),
                                    c = t.match("^\\t{" + (e.currentIndent - 1) + "}}");
                                a ? e.parseNodeBegin(t, a) : s ? e.parseNodeProperty(t, s, n[++r]) : c ? e.popStack() : t.match(/^[^\s\t}]/) && e.parseNodePropertyContinued(t)
                            }
                        })), this.allNodes
                    },
                    parseNodeBegin: function(t, e) {
                        var n = e[1].trim().replace(/^"/, "").replace(/"$/, ""),
                            r = e[2].split(",").map((function(t) {
                                return t.trim().replace(/^"/, "").replace(/"$/, "")
                            })),
                            i = {
                                name: n
                            },
                            o = this.parseNodeAttr(r),
                            a = this.getCurrentNode();
                        0 === this.currentIndent ? this.allNodes.add(n, i) : n in a ? ("PoseNode" === n ? a.PoseNode.push(i) : void 0 !== a[n].id && (a[n] = {}, a[n][a[n].id] = a[n]), "" !== o.id && (a[n][o.id] = i)) : "number" === typeof o.id ? (a[n] = {}, a[n][o.id] = i) : "Properties70" !== n && (a[n] = "PoseNode" === n ? [i] : i), "number" === typeof o.id && (i.id = o.id), "" !== o.name && (i.attrName = o.name), "" !== o.type && (i.attrType = o.type), this.pushStack(i)
                    },
                    parseNodeAttr: function(t) {
                        var e = t[0];
                        "" !== t[0] && (e = parseInt(t[0]), isNaN(e) && (e = t[0]));
                        var n = "",
                            r = "";
                        return t.length > 1 && (n = t[1].replace(/^(\w+)::/, ""), r = t[2]), {
                            id: e,
                            name: n,
                            type: r
                        }
                    },
                    parseNodeProperty: function(t, e, n) {
                        var r = e[1].replace(/^"/, "").replace(/"$/, "").trim(),
                            i = e[2].replace(/^"/, "").replace(/"$/, "").trim();
                        "Content" === r && "," === i && (i = n.replace(/"/g, "").replace(/,$/, "").trim());
                        var o = this.getCurrentNode(),
                            a = o.name;
                        if ("Properties70" !== a) {
                            if ("C" === r) {
                                var s = i.split(",").slice(1),
                                    c = parseInt(s[0]),
                                    l = parseInt(s[1]),
                                    u = i.split(",").slice(3);
                                u = u.map((function(t) {
                                    return t.trim().replace(/^"/, "")
                                })), r = "connections", i = [c, l], T(i, u), void 0 === o[r] && (o[r] = [])
                            }
                            "Node" === r && (o.id = i), r in o && Array.isArray(o[r]) ? o[r].push(i) : "a" !== r ? o[r] = i : o.a = i, this.setCurrentProp(o, r), "a" === r && "," !== i.slice(-1) && (o.a = w(i))
                        } else this.parseNodeSpecialProperty(t, r, i)
                    },
                    parseNodePropertyContinued: function(t) {
                        var e = this.getCurrentNode();
                        e.a += t, "," !== t.slice(-1) && (e.a = w(e.a))
                    },
                    parseNodeSpecialProperty: function(t, e, n) {
                        var r = n.split('",').map((function(t) {
                                return t.trim().replace(/^\"/, "").replace(/\s/, "_")
                            })),
                            i = r[0],
                            o = r[1],
                            a = r[2],
                            s = r[3],
                            c = r[4];
                        switch (o) {
                            case "int":
                            case "enum":
                            case "bool":
                            case "ULongLong":
                            case "double":
                            case "Number":
                            case "FieldOfView":
                                c = parseFloat(c);
                                break;
                            case "Color":
                            case "ColorRGB":
                            case "Vector3D":
                            case "Lcl_Translation":
                            case "Lcl_Rotation":
                            case "Lcl_Scaling":
                                c = w(c);
                                break
                        }
                        this.getPrevNode()[i] = {
                            type: o,
                            type2: a,
                            flag: s,
                            value: c
                        }, this.setCurrentProp(this.getPrevNode(), i)
                    }
                }, l.prototype = {
                    constructor: l,
                    parse: function(t) {
                        var e = new u(t);
                        e.skip(23);
                        var n = e.getUint32();
                        if (n < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
                        var r = new h;
                        while (!this.endOfContent(e)) {
                            var i = this.parseNode(e, n);
                            null !== i && r.add(i.name, i)
                        }
                        return r
                    },
                    endOfContent: function(t) {
                        return t.size() % 16 === 0 ? (t.getOffset() + 160 + 16 & -16) >= t.size() : t.getOffset() + 160 + 16 >= t.size()
                    },
                    parseNode: function(t, e) {
                        var n = {},
                            r = e >= 7500 ? t.getUint64() : t.getUint32(),
                            i = e >= 7500 ? t.getUint64() : t.getUint32();
                        e >= 7500 ? t.getUint64() : t.getUint32();
                        var o = t.getUint8(),
                            a = t.getString(o);
                        if (0 === r) return null;
                        for (var s = [], c = 0; c < i; c++) s.push(this.parseProperty(t));
                        var l = s.length > 0 ? s[0] : "",
                            u = s.length > 1 ? s[1] : "",
                            h = s.length > 2 ? s[2] : "";
                        n.singleProperty = 1 === i && t.getOffset() === r;
                        while (r > t.getOffset()) {
                            var d = this.parseNode(t, e);
                            null !== d && this.parseSubNode(a, n, d)
                        }
                        return n.propertyList = s, "number" === typeof l && (n.id = l), "" !== u && (n.attrName = u), "" !== h && (n.attrType = h), "" !== a && (n.name = a), n
                    },
                    parseSubNode: function(t, e, n) {
                        if (!0 === n.singleProperty) {
                            var r = n.propertyList[0];
                            Array.isArray(r) ? (e[n.name] = n, n.a = r) : e[n.name] = r
                        } else if ("Connections" === t && "C" === n.name) {
                            var i = [];
                            n.propertyList.forEach((function(t, e) {
                                0 !== e && i.push(t)
                            })), void 0 === e.connections && (e.connections = []), e.connections.push(i)
                        } else if ("Properties70" === n.name) {
                            var o = Object.keys(n);
                            o.forEach((function(t) {
                                e[t] = n[t]
                            }))
                        } else if ("Properties70" === t && "P" === n.name) {
                            var a, s = n.propertyList[0],
                                c = n.propertyList[1],
                                l = n.propertyList[2],
                                u = n.propertyList[3];
                            0 === s.indexOf("Lcl ") && (s = s.replace("Lcl ", "Lcl_")), 0 === c.indexOf("Lcl ") && (c = c.replace("Lcl ", "Lcl_")), a = "Color" === c || "ColorRGB" === c || "Vector" === c || "Vector3D" === c || 0 === c.indexOf("Lcl_") ? [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : n.propertyList[4], e[s] = {
                                type: c,
                                type2: l,
                                flag: u,
                                value: a
                            }
                        } else void 0 === e[n.name] ? "number" === typeof n.id ? (e[n.name] = {}, e[n.name][n.id] = n) : e[n.name] = n : "PoseNode" === n.name ? (Array.isArray(e[n.name]) || (e[n.name] = [e[n.name]]), e[n.name].push(n)) : void 0 === e[n.name][n.id] && (e[n.name][n.id] = n)
                    },
                    parseProperty: function(t) {
                        var e = t.getString(1);
                        switch (e) {
                            case "C":
                                return t.getBoolean();
                            case "D":
                                return t.getFloat64();
                            case "F":
                                return t.getFloat32();
                            case "I":
                                return t.getInt32();
                            case "L":
                                return t.getInt64();
                            case "R":
                                var n = t.getUint32();
                                return t.getArrayBuffer(n);
                            case "S":
                                n = t.getUint32();
                                return t.getString(n);
                            case "Y":
                                return t.getInt16();
                            case "b":
                            case "c":
                            case "d":
                            case "f":
                            case "i":
                            case "l":
                                var r = t.getUint32(),
                                    i = t.getUint32(),
                                    o = t.getUint32();
                                if (0 === i) switch (e) {
                                    case "b":
                                    case "c":
                                        return t.getBooleanArray(r);
                                    case "d":
                                        return t.getFloat64Array(r);
                                    case "f":
                                        return t.getFloat32Array(r);
                                    case "i":
                                        return t.getInt32Array(r);
                                    case "l":
                                        return t.getInt64Array(r)
                                }
                                "undefined" === typeof z && console.error("THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js");
                                var a = new z(new Uint8Array(t.getArrayBuffer(o))),
                                    s = new u(a.decompress().buffer);
                                switch (e) {
                                    case "b":
                                    case "c":
                                        return s.getBooleanArray(r);
                                    case "d":
                                        return s.getFloat64Array(r);
                                    case "f":
                                        return s.getFloat32Array(r);
                                    case "i":
                                        return s.getInt32Array(r);
                                    case "l":
                                        return s.getInt64Array(r)
                                }
                            default:
                                throw new Error("THREE.FBXLoader: Unknown property type " + e)
                        }
                    }
                }, u.prototype = {
                    constructor: u,
                    getOffset: function() {
                        return this.offset
                    },
                    size: function() {
                        return this.dv.buffer.byteLength
                    },
                    skip: function(t) {
                        this.offset += t
                    },
                    getBoolean: function() {
                        return 1 === (1 & this.getUint8())
                    },
                    getBooleanArray: function(t) {
                        for (var e = [], n = 0; n < t; n++) e.push(this.getBoolean());
                        return e
                    },
                    getUint8: function() {
                        var t = this.dv.getUint8(this.offset);
                        return this.offset += 1, t
                    },
                    getInt16: function() {
                        var t = this.dv.getInt16(this.offset, this.littleEndian);
                        return this.offset += 2, t
                    },
                    getInt32: function() {
                        var t = this.dv.getInt32(this.offset, this.littleEndian);
                        return this.offset += 4, t
                    },
                    getInt32Array: function(t) {
                        for (var e = [], n = 0; n < t; n++) e.push(this.getInt32());
                        return e
                    },
                    getUint32: function() {
                        var t = this.dv.getUint32(this.offset, this.littleEndian);
                        return this.offset += 4, t
                    },
                    getInt64: function() {
                        var t, e;
                        return this.littleEndian ? (t = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), t = this.getUint32()), 2147483648 & e ? (e = 4294967295 & ~e, t = 4294967295 & ~t, 4294967295 === t && (e = e + 1 & 4294967295), t = t + 1 & 4294967295, -(4294967296 * e + t)) : 4294967296 * e + t
                    },
                    getInt64Array: function(t) {
                        for (var e = [], n = 0; n < t; n++) e.push(this.getInt64());
                        return e
                    },
                    getUint64: function() {
                        var t, e;
                        return this.littleEndian ? (t = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), t = this.getUint32()), 4294967296 * e + t
                    },
                    getFloat32: function() {
                        var t = this.dv.getFloat32(this.offset, this.littleEndian);
                        return this.offset += 4, t
                    },
                    getFloat32Array: function(t) {
                        for (var e = [], n = 0; n < t; n++) e.push(this.getFloat32());
                        return e
                    },
                    getFloat64: function() {
                        var t = this.dv.getFloat64(this.offset, this.littleEndian);
                        return this.offset += 8, t
                    },
                    getFloat64Array: function(t) {
                        for (var e = [], n = 0; n < t; n++) e.push(this.getFloat64());
                        return e
                    },
                    getArrayBuffer: function(t) {
                        var e = this.dv.buffer.slice(this.offset, this.offset + t);
                        return this.offset += t, e
                    },
                    getString: function(t) {
                        for (var e = [], n = 0; n < t; n++) e[n] = this.getUint8();
                        var i = e.indexOf(0);
                        return i >= 0 && (e = e.slice(0, i)), r["N"].decodeText(new Uint8Array(e))
                    }
                }, h.prototype = {
                    constructor: h,
                    add: function(t, e) {
                        this[t] = e
                    }
                };
                var g = [];

                function v(t, e, n, r) {
                    var i;
                    switch (r.mappingType) {
                        case "ByPolygonVertex":
                            i = t;
                            break;
                        case "ByPolygon":
                            i = e;
                            break;
                        case "ByVertice":
                            i = n;
                            break;
                        case "AllSame":
                            i = r.indices[0];
                            break;
                        default:
                            console.warn("THREE.FBXLoader: unknown attribute mapping type " + r.mappingType)
                    }
                    "IndexToDirect" === r.referenceType && (i = r.indices[i]);
                    var o = i * r.dataSize,
                        a = o + r.dataSize;
                    return S(g, r.buffer, o, a)
                }
                var y = new r["r"],
                    _ = new r["Rb"];

                function b(t) {
                    var e = new r["S"],
                        n = new r["S"],
                        i = new r["S"],
                        o = new r["S"],
                        a = new r["S"],
                        s = new r["S"],
                        c = new r["S"],
                        l = new r["S"],
                        u = new r["S"],
                        h = new r["S"],
                        d = new r["S"],
                        p = t.inheritType ? t.inheritType : 0;
                    if (t.translation && e.setPosition(_.fromArray(t.translation)), t.preRotation) {
                        var f = t.preRotation.map(r["Q"].degToRad);
                        f.push(t.eulerOrder), n.makeRotationFromEuler(y.fromArray(f))
                    }
                    if (t.rotation) {
                        f = t.rotation.map(r["Q"].degToRad);
                        f.push(t.eulerOrder), i.makeRotationFromEuler(y.fromArray(f))
                    }
                    if (t.postRotation) {
                        f = t.postRotation.map(r["Q"].degToRad);
                        f.push(t.eulerOrder), o.makeRotationFromEuler(y.fromArray(f))
                    }
                    t.scale && a.scale(_.fromArray(t.scale)), t.scalingOffset && c.setPosition(_.fromArray(t.scalingOffset)), t.scalingPivot && s.setPosition(_.fromArray(t.scalingPivot)), t.rotationOffset && l.setPosition(_.fromArray(t.rotationOffset)), t.rotationPivot && u.setPosition(_.fromArray(t.rotationPivot)), t.parentMatrixWorld && (h = t.parentMatrixWorld);
                    var m = n.multiply(i).multiply(o),
                        g = new r["S"];
                    h.extractRotation(g);
                    var v = new r["S"];
                    v.copyPosition(h);
                    var b = new r["S"];
                    b.getInverse(g).multiply(h);
                    var x = new r["S"];
                    if (0 === p) x.copy(g).multiply(m).multiply(b).multiply(a);
                    else if (1 === p) x.copy(g).multiply(b).multiply(m).multiply(a);
                    else {
                        var w = (new r["S"]).getInverse(a),
                            M = (new r["S"]).multiply(b).multiply(w);
                        x.copy(g).multiply(m).multiply(M).multiply(a)
                    }
                    var T = (new r["S"]).getInverse(u),
                        S = (new r["S"]).getInverse(s),
                        E = new r["S"];
                    E.copy(e).multiply(l).multiply(u).multiply(n).multiply(i).multiply(o).multiply(T).multiply(c).multiply(s).multiply(a).multiply(S);
                    var A = (new r["S"]).copyPosition(E),
                        L = (new r["S"]).copy(h).multiply(A);
                    return d.copyPosition(L), E = (new r["S"]).multiply(d).multiply(x), E
                }

                function x(t) {
                    t = t || 0;
                    var e = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
                    return 6 === t ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[t]
                }

                function w(t) {
                    var e = t.split(",").map((function(t) {
                        return parseFloat(t)
                    }));
                    return e
                }

                function M(t, e, n) {
                    return void 0 === e && (e = 0), void 0 === n && (n = t.byteLength), r["N"].decodeText(new Uint8Array(t, e, n))
                }

                function T(t, e) {
                    for (var n = 0, r = t.length, i = e.length; n < i; n++, r++) t[r] = e[n]
                }

                function S(t, e, n, r) {
                    for (var i = n, o = 0; i < r; i++, o++) t[o] = e[i];
                    return t
                }

                function E(t, e, n) {
                    return t.slice(0, e).concat(n).concat(t.slice(e))
                }
                return i
            }()
        },
        8925: function(t, e, n) {
            var r = n("c6cd"),
                i = Function.toString;
            "function" != typeof r.inspectSource && (r.inspectSource = function(t) {
                return i.call(t)
            }), t.exports = r.inspectSource
        },
        8992: function(t, e, n) {
            "use strict";

            function r(t) {
                if (t && "undefined" !== typeof window) {
                    var e = document.createElement("style");
                    return e.setAttribute("type", "text/css"), e.innerHTML = t, document.head.appendChild(e), t
                }
            }

            function i(t, e) {
                var n = t.__state.conversionName.toString(),
                    r = Math.round(t.r),
                    i = Math.round(t.g),
                    o = Math.round(t.b),
                    a = t.a,
                    s = Math.round(t.h),
                    c = t.s.toFixed(1),
                    l = t.v.toFixed(1);
                if (e || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) {
                    var u = t.hex.toString(16);
                    while (u.length < 6) u = "0" + u;
                    return "#" + u
                }
                return "CSS_RGB" === n ? "rgb(" + r + "," + i + "," + o + ")" : "CSS_RGBA" === n ? "rgba(" + r + "," + i + "," + o + "," + a + ")" : "HEX" === n ? "0x" + t.hex.toString(16) : "RGB_ARRAY" === n ? "[" + r + "," + i + "," + o + "]" : "RGBA_ARRAY" === n ? "[" + r + "," + i + "," + o + "," + a + "]" : "RGB_OBJ" === n ? "{r:" + r + ",g:" + i + ",b:" + o + "}" : "RGBA_OBJ" === n ? "{r:" + r + ",g:" + i + ",b:" + o + ",a:" + a + "}" : "HSV_OBJ" === n ? "{h:" + s + ",s:" + c + ",v:" + l + "}" : "HSVA_OBJ" === n ? "{h:" + s + ",s:" + c + ",v:" + l + ",a:" + a + "}" : "unknown format"
            }
            n.d(e, "a", (function() {
                return wt
            }));
            var o = Array.prototype.forEach,
                a = Array.prototype.slice,
                s = {
                    BREAK: {},
                    extend: function(t) {
                        return this.each(a.call(arguments, 1), (function(e) {
                            var n = this.isObject(e) ? Object.keys(e) : [];
                            n.forEach(function(n) {
                                this.isUndefined(e[n]) || (t[n] = e[n])
                            }.bind(this))
                        }), this), t
                    },
                    defaults: function(t) {
                        return this.each(a.call(arguments, 1), (function(e) {
                            var n = this.isObject(e) ? Object.keys(e) : [];
                            n.forEach(function(n) {
                                this.isUndefined(t[n]) && (t[n] = e[n])
                            }.bind(this))
                        }), this), t
                    },
                    compose: function() {
                        var t = a.call(arguments);
                        return function() {
                            for (var e = a.call(arguments), n = t.length - 1; n >= 0; n--) e = [t[n].apply(this, e)];
                            return e[0]
                        }
                    },
                    each: function(t, e, n) {
                        if (t)
                            if (o && t.forEach && t.forEach === o) t.forEach(e, n);
                            else if (t.length === t.length + 0) {
                            var r = void 0,
                                i = void 0;
                            for (r = 0, i = t.length; r < i; r++)
                                if (r in t && e.call(n, t[r], r) === this.BREAK) return
                        } else
                            for (var a in t)
                                if (e.call(n, t[a], a) === this.BREAK) return
                    },
                    defer: function(t) {
                        setTimeout(t, 0)
                    },
                    debounce: function(t, e, n) {
                        var r = void 0;
                        return function() {
                            var i = this,
                                o = arguments;

                            function a() {
                                r = null, n || t.apply(i, o)
                            }
                            var s = n || !r;
                            clearTimeout(r), r = setTimeout(a, e), s && t.apply(i, o)
                        }
                    },
                    toArray: function(t) {
                        return t.toArray ? t.toArray() : a.call(t)
                    },
                    isUndefined: function(t) {
                        return void 0 === t
                    },
                    isNull: function(t) {
                        return null === t
                    },
                    isNaN: function(t) {
                        function e(e) {
                            return t.apply(this, arguments)
                        }
                        return e.toString = function() {
                            return t.toString()
                        }, e
                    }((function(t) {
                        return isNaN(t)
                    })),
                    isArray: Array.isArray || function(t) {
                        return t.constructor === Array
                    },
                    isObject: function(t) {
                        return t === Object(t)
                    },
                    isNumber: function(t) {
                        return t === t + 0
                    },
                    isString: function(t) {
                        return t === t + ""
                    },
                    isBoolean: function(t) {
                        return !1 === t || !0 === t
                    },
                    isFunction: function(t) {
                        return t instanceof Function
                    }
                },
                c = [{
                    litmus: s.isString,
                    conversions: {
                        THREE_CHAR_HEX: {
                            read: function(t) {
                                var e = t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                                return null !== e && {
                                    space: "HEX",
                                    hex: parseInt("0x" + e[1].toString() + e[1].toString() + e[2].toString() + e[2].toString() + e[3].toString() + e[3].toString(), 0)
                                }
                            },
                            write: i
                        },
                        SIX_CHAR_HEX: {
                            read: function(t) {
                                var e = t.match(/^#([A-F0-9]{6})$/i);
                                return null !== e && {
                                    space: "HEX",
                                    hex: parseInt("0x" + e[1].toString(), 0)
                                }
                            },
                            write: i
                        },
                        CSS_RGB: {
                            read: function(t) {
                                var e = t.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                                return null !== e && {
                                    space: "RGB",
                                    r: parseFloat(e[1]),
                                    g: parseFloat(e[2]),
                                    b: parseFloat(e[3])
                                }
                            },
                            write: i
                        },
                        CSS_RGBA: {
                            read: function(t) {
                                var e = t.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                                return null !== e && {
                                    space: "RGB",
                                    r: parseFloat(e[1]),
                                    g: parseFloat(e[2]),
                                    b: parseFloat(e[3]),
                                    a: parseFloat(e[4])
                                }
                            },
                            write: i
                        }
                    }
                }, {
                    litmus: s.isNumber,
                    conversions: {
                        HEX: {
                            read: function(t) {
                                return {
                                    space: "HEX",
                                    hex: t,
                                    conversionName: "HEX"
                                }
                            },
                            write: function(t) {
                                return t.hex
                            }
                        }
                    }
                }, {
                    litmus: s.isArray,
                    conversions: {
                        RGB_ARRAY: {
                            read: function(t) {
                                return 3 === t.length && {
                                    space: "RGB",
                                    r: t[0],
                                    g: t[1],
                                    b: t[2]
                                }
                            },
                            write: function(t) {
                                return [t.r, t.g, t.b]
                            }
                        },
                        RGBA_ARRAY: {
                            read: function(t) {
                                return 4 === t.length && {
                                    space: "RGB",
                                    r: t[0],
                                    g: t[1],
                                    b: t[2],
                                    a: t[3]
                                }
                            },
                            write: function(t) {
                                return [t.r, t.g, t.b, t.a]
                            }
                        }
                    }
                }, {
                    litmus: s.isObject,
                    conversions: {
                        RGBA_OBJ: {
                            read: function(t) {
                                return !!(s.isNumber(t.r) && s.isNumber(t.g) && s.isNumber(t.b) && s.isNumber(t.a)) && {
                                    space: "RGB",
                                    r: t.r,
                                    g: t.g,
                                    b: t.b,
                                    a: t.a
                                }
                            },
                            write: function(t) {
                                return {
                                    r: t.r,
                                    g: t.g,
                                    b: t.b,
                                    a: t.a
                                }
                            }
                        },
                        RGB_OBJ: {
                            read: function(t) {
                                return !!(s.isNumber(t.r) && s.isNumber(t.g) && s.isNumber(t.b)) && {
                                    space: "RGB",
                                    r: t.r,
                                    g: t.g,
                                    b: t.b
                                }
                            },
                            write: function(t) {
                                return {
                                    r: t.r,
                                    g: t.g,
                                    b: t.b
                                }
                            }
                        },
                        HSVA_OBJ: {
                            read: function(t) {
                                return !!(s.isNumber(t.h) && s.isNumber(t.s) && s.isNumber(t.v) && s.isNumber(t.a)) && {
                                    space: "HSV",
                                    h: t.h,
                                    s: t.s,
                                    v: t.v,
                                    a: t.a
                                }
                            },
                            write: function(t) {
                                return {
                                    h: t.h,
                                    s: t.s,
                                    v: t.v,
                                    a: t.a
                                }
                            }
                        },
                        HSV_OBJ: {
                            read: function(t) {
                                return !!(s.isNumber(t.h) && s.isNumber(t.s) && s.isNumber(t.v)) && {
                                    space: "HSV",
                                    h: t.h,
                                    s: t.s,
                                    v: t.v
                                }
                            },
                            write: function(t) {
                                return {
                                    h: t.h,
                                    s: t.s,
                                    v: t.v
                                }
                            }
                        }
                    }
                }],
                l = void 0,
                u = void 0,
                h = function() {
                    u = !1;
                    var t = arguments.length > 1 ? s.toArray(arguments) : arguments[0];
                    return s.each(c, (function(e) {
                        if (e.litmus(t)) return s.each(e.conversions, (function(e, n) {
                            if (l = e.read(t), !1 === u && !1 !== l) return u = l, l.conversionName = n, l.conversion = e, s.BREAK
                        })), s.BREAK
                    })), u
                },
                d = void 0,
                p = {
                    hsv_to_rgb: function(t, e, n) {
                        var r = Math.floor(t / 60) % 6,
                            i = t / 60 - Math.floor(t / 60),
                            o = n * (1 - e),
                            a = n * (1 - i * e),
                            s = n * (1 - (1 - i) * e),
                            c = [
                                [n, s, o],
                                [a, n, o],
                                [o, n, s],
                                [o, a, n],
                                [s, o, n],
                                [n, o, a]
                            ][r];
                        return {
                            r: 255 * c[0],
                            g: 255 * c[1],
                            b: 255 * c[2]
                        }
                    },
                    rgb_to_hsv: function(t, e, n) {
                        var r = Math.min(t, e, n),
                            i = Math.max(t, e, n),
                            o = i - r,
                            a = void 0,
                            s = void 0;
                        return 0 === i ? {
                            h: NaN,
                            s: 0,
                            v: 0
                        } : (s = o / i, a = t === i ? (e - n) / o : e === i ? 2 + (n - t) / o : 4 + (t - e) / o, a /= 6, a < 0 && (a += 1), {
                            h: 360 * a,
                            s: s,
                            v: i / 255
                        })
                    },
                    rgb_to_hex: function(t, e, n) {
                        var r = this.hex_with_component(0, 2, t);
                        return r = this.hex_with_component(r, 1, e), r = this.hex_with_component(r, 0, n), r
                    },
                    component_from_hex: function(t, e) {
                        return t >> 8 * e & 255
                    },
                    hex_with_component: function(t, e, n) {
                        return n << (d = 8 * e) | t & ~(255 << d)
                    }
                },
                f = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(t) {
                    return typeof t
                } : function(t) {
                    return t && "function" === typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                },
                m = function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                },
                g = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var r = e[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
                        }
                    }
                    return function(e, n, r) {
                        return n && t(e.prototype, n), r && t(e, r), e
                    }
                }(),
                v = function t(e, n, r) {
                    null === e && (e = Function.prototype);
                    var i = Object.getOwnPropertyDescriptor(e, n);
                    if (void 0 === i) {
                        var o = Object.getPrototypeOf(e);
                        return null === o ? void 0 : t(o, n, r)
                    }
                    if ("value" in i) return i.value;
                    var a = i.get;
                    return void 0 !== a ? a.call(r) : void 0
                },
                y = function(t, e) {
                    if ("function" !== typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                },
                _ = function(t, e) {
                    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !e || "object" !== typeof e && "function" !== typeof e ? t : e
                },
                b = function() {
                    function t() {
                        if (m(this, t), this.__state = h.apply(this, arguments), !1 === this.__state) throw new Error("Failed to interpret color arguments");
                        this.__state.a = this.__state.a || 1
                    }
                    return g(t, [{
                        key: "toString",
                        value: function() {
                            return i(this)
                        }
                    }, {
                        key: "toHexString",
                        value: function() {
                            return i(this, !0)
                        }
                    }, {
                        key: "toOriginal",
                        value: function() {
                            return this.__state.conversion.write(this)
                        }
                    }]), t
                }();

            function x(t, e, n) {
                Object.defineProperty(t, e, {
                    get: function() {
                        return "RGB" === this.__state.space || b.recalculateRGB(this, e, n), this.__state[e]
                    },
                    set: function(t) {
                        "RGB" !== this.__state.space && (b.recalculateRGB(this, e, n), this.__state.space = "RGB"), this.__state[e] = t
                    }
                })
            }

            function w(t, e) {
                Object.defineProperty(t, e, {
                    get: function() {
                        return "HSV" === this.__state.space || b.recalculateHSV(this), this.__state[e]
                    },
                    set: function(t) {
                        "HSV" !== this.__state.space && (b.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e] = t
                    }
                })
            }
            b.recalculateRGB = function(t, e, n) {
                if ("HEX" === t.__state.space) t.__state[e] = p.component_from_hex(t.__state.hex, n);
                else {
                    if ("HSV" !== t.__state.space) throw new Error("Corrupted color state");
                    s.extend(t.__state, p.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v))
                }
            }, b.recalculateHSV = function(t) {
                var e = p.rgb_to_hsv(t.r, t.g, t.b);
                s.extend(t.__state, {
                    s: e.s,
                    v: e.v
                }), s.isNaN(e.h) ? s.isUndefined(t.__state.h) && (t.__state.h = 0) : t.__state.h = e.h
            }, b.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], x(b.prototype, "r", 2), x(b.prototype, "g", 1), x(b.prototype, "b", 0), w(b.prototype, "h"), w(b.prototype, "s"), w(b.prototype, "v"), Object.defineProperty(b.prototype, "a", {
                get: function() {
                    return this.__state.a
                },
                set: function(t) {
                    this.__state.a = t
                }
            }), Object.defineProperty(b.prototype, "hex", {
                get: function() {
                    return "HEX" !== this.__state.space && (this.__state.hex = p.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex
                },
                set: function(t) {
                    this.__state.space = "HEX", this.__state.hex = t
                }
            });
            var M = function() {
                    function t(e, n) {
                        m(this, t), this.initialValue = e[n], this.domElement = document.createElement("div"), this.object = e, this.property = n, this.__onChange = void 0, this.__onFinishChange = void 0
                    }
                    return g(t, [{
                        key: "onChange",
                        value: function(t) {
                            return this.__onChange = t, this
                        }
                    }, {
                        key: "onFinishChange",
                        value: function(t) {
                            return this.__onFinishChange = t, this
                        }
                    }, {
                        key: "setValue",
                        value: function(t) {
                            return this.object[this.property] = t, this.__onChange && this.__onChange.call(this, t), this.updateDisplay(), this
                        }
                    }, {
                        key: "getValue",
                        value: function() {
                            return this.object[this.property]
                        }
                    }, {
                        key: "updateDisplay",
                        value: function() {
                            return this
                        }
                    }, {
                        key: "isModified",
                        value: function() {
                            return this.initialValue !== this.getValue()
                        }
                    }]), t
                }(),
                T = {
                    HTMLEvents: ["change"],
                    MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
                    KeyboardEvents: ["keydown"]
                },
                S = {};
            s.each(T, (function(t, e) {
                s.each(t, (function(t) {
                    S[t] = e
                }))
            }));
            var E = /(\d+(\.\d+)?)px/;

            function A(t) {
                if ("0" === t || s.isUndefined(t)) return 0;
                var e = t.match(E);
                return s.isNull(e) ? 0 : parseFloat(e[1])
            }
            var L = {
                    makeSelectable: function(t, e) {
                        void 0 !== t && void 0 !== t.style && (t.onselectstart = e ? function() {
                            return !1
                        } : function() {}, t.style.MozUserSelect = e ? "auto" : "none", t.style.KhtmlUserSelect = e ? "auto" : "none", t.unselectable = e ? "on" : "off")
                    },
                    makeFullscreen: function(t, e, n) {
                        var r = n,
                            i = e;
                        s.isUndefined(i) && (i = !0), s.isUndefined(r) && (r = !0), t.style.position = "absolute", i && (t.style.left = 0, t.style.right = 0), r && (t.style.top = 0, t.style.bottom = 0)
                    },
                    fakeEvent: function(t, e, n, r) {
                        var i = n || {},
                            o = S[e];
                        if (!o) throw new Error("Event type " + e + " not supported.");
                        var a = document.createEvent(o);
                        switch (o) {
                            case "MouseEvents":
                                var c = i.x || i.clientX || 0,
                                    l = i.y || i.clientY || 0;
                                a.initMouseEvent(e, i.bubbles || !1, i.cancelable || !0, window, i.clickCount || 1, 0, 0, c, l, !1, !1, !1, !1, 0, null);
                                break;
                            case "KeyboardEvents":
                                var u = a.initKeyboardEvent || a.initKeyEvent;
                                s.defaults(i, {
                                    cancelable: !0,
                                    ctrlKey: !1,
                                    altKey: !1,
                                    shiftKey: !1,
                                    metaKey: !1,
                                    keyCode: void 0,
                                    charCode: void 0
                                }), u(e, i.bubbles || !1, i.cancelable, window, i.ctrlKey, i.altKey, i.shiftKey, i.metaKey, i.keyCode, i.charCode);
                                break;
                            default:
                                a.initEvent(e, i.bubbles || !1, i.cancelable || !0);
                                break
                        }
                        s.defaults(a, r), t.dispatchEvent(a)
                    },
                    bind: function(t, e, n, r) {
                        var i = r || !1;
                        return t.addEventListener ? t.addEventListener(e, n, i) : t.attachEvent && t.attachEvent("on" + e, n), L
                    },
                    unbind: function(t, e, n, r) {
                        var i = r || !1;
                        return t.removeEventListener ? t.removeEventListener(e, n, i) : t.detachEvent && t.detachEvent("on" + e, n), L
                    },
                    addClass: function(t, e) {
                        if (void 0 === t.className) t.className = e;
                        else if (t.className !== e) {
                            var n = t.className.split(/ +/); - 1 === n.indexOf(e) && (n.push(e), t.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
                        }
                        return L
                    },
                    removeClass: function(t, e) {
                        if (e)
                            if (t.className === e) t.removeAttribute("class");
                            else {
                                var n = t.className.split(/ +/),
                                    r = n.indexOf(e); - 1 !== r && (n.splice(r, 1), t.className = n.join(" "))
                            }
                        else t.className = void 0;
                        return L
                    },
                    hasClass: function(t, e) {
                        return new RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(t.className) || !1
                    },
                    getWidth: function(t) {
                        var e = getComputedStyle(t);
                        return A(e["border-left-width"]) + A(e["border-right-width"]) + A(e["padding-left"]) + A(e["padding-right"]) + A(e.width)
                    },
                    getHeight: function(t) {
                        var e = getComputedStyle(t);
                        return A(e["border-top-width"]) + A(e["border-bottom-width"]) + A(e["padding-top"]) + A(e["padding-bottom"]) + A(e.height)
                    },
                    getOffset: function(t) {
                        var e = t,
                            n = {
                                left: 0,
                                top: 0
                            };
                        if (e.offsetParent)
                            do {
                                n.left += e.offsetLeft, n.top += e.offsetTop, e = e.offsetParent
                            } while (e);
                        return n
                    },
                    isActive: function(t) {
                        return t === document.activeElement && (t.type || t.href)
                    }
                },
                R = function(t) {
                    function e(t, n) {
                        m(this, e);
                        var r = _(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
                            i = r;

                        function o() {
                            i.setValue(!i.__prev)
                        }
                        return r.__prev = r.getValue(), r.__checkbox = document.createElement("input"), r.__checkbox.setAttribute("type", "checkbox"), L.bind(r.__checkbox, "change", o, !1), r.domElement.appendChild(r.__checkbox), r.updateDisplay(), r
                    }
                    return y(e, t), g(e, [{
                        key: "setValue",
                        value: function(t) {
                            var n = v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
                            return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), n
                        }
                    }, {
                        key: "updateDisplay",
                        value: function() {
                            return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                        }
                    }]), e
                }(M),
                C = function(t) {
                    function e(t, n, r) {
                        m(this, e);
                        var i = _(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
                            o = r,
                            a = i;
                        if (i.__select = document.createElement("select"), s.isArray(o)) {
                            var c = {};
                            s.each(o, (function(t) {
                                c[t] = t
                            })), o = c
                        }
                        return s.each(o, (function(t, e) {
                            var n = document.createElement("option");
                            n.innerHTML = e, n.setAttribute("value", t), a.__select.appendChild(n)
                        })), i.updateDisplay(), L.bind(i.__select, "change", (function() {
                            var t = this.options[this.selectedIndex].value;
                            a.setValue(t)
                        })), i.domElement.appendChild(i.__select), i
                    }
                    return y(e, t), g(e, [{
                        key: "setValue",
                        value: function(t) {
                            var n = v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
                            return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), n
                        }
                    }, {
                        key: "updateDisplay",
                        value: function() {
                            return L.isActive(this.__select) ? this : (this.__select.value = this.getValue(), v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this))
                        }
                    }]), e
                }(M),
                O = function(t) {
                    function e(t, n) {
                        m(this, e);
                        var r = _(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
                            i = r;

                        function o() {
                            i.setValue(i.__input.value)
                        }

                        function a() {
                            i.__onFinishChange && i.__onFinishChange.call(i, i.getValue())
                        }
                        return r.__input = document.createElement("input"), r.__input.setAttribute("type", "text"), L.bind(r.__input, "keyup", o), L.bind(r.__input, "change", o), L.bind(r.__input, "blur", a), L.bind(r.__input, "keydown", (function(t) {
                            13 === t.keyCode && this.blur()
                        })), r.updateDisplay(), r.domElement.appendChild(r.__input), r
                    }
                    return y(e, t), g(e, [{
                        key: "updateDisplay",
                        value: function() {
                            return L.isActive(this.__input) || (this.__input.value = this.getValue()), v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                        }
                    }]), e
                }(M);

            function P(t) {
                var e = t.toString();
                return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0
            }
            var I = function(t) {
                function e(t, n, r) {
                    m(this, e);
                    var i = _(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
                        o = r || {};
                    return i.__min = o.min, i.__max = o.max, i.__step = o.step, s.isUndefined(i.__step) ? 0 === i.initialValue ? i.__impliedStep = 1 : i.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(i.initialValue)) / Math.LN10)) / 10 : i.__impliedStep = i.__step, i.__precision = P(i.__impliedStep), i
                }
                return y(e, t), g(e, [{
                    key: "setValue",
                    value: function(t) {
                        var n = t;
                        return void 0 !== this.__min && n < this.__min ? n = this.__min : void 0 !== this.__max && n > this.__max && (n = this.__max), void 0 !== this.__step && n % this.__step !== 0 && (n = Math.round(n / this.__step) * this.__step), v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, n)
                    }
                }, {
                    key: "min",
                    value: function(t) {
                        return this.__min = t, this
                    }
                }, {
                    key: "max",
                    value: function(t) {
                        return this.__max = t, this
                    }
                }, {
                    key: "step",
                    value: function(t) {
                        return this.__step = t, this.__impliedStep = t, this.__precision = P(t), this
                    }
                }]), e
            }(M);

            function N(t, e) {
                var n = Math.pow(10, e);
                return Math.round(t * n) / n
            }
            var D = function(t) {
                function e(t, n, r) {
                    m(this, e);
                    var i = _(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, r));
                    i.__truncationSuspended = !1;
                    var o = i,
                        a = void 0;

                    function c() {
                        var t = parseFloat(o.__input.value);
                        s.isNaN(t) || o.setValue(t)
                    }

                    function l() {
                        o.__onFinishChange && o.__onFinishChange.call(o, o.getValue())
                    }

                    function u() {
                        l()
                    }

                    function h(t) {
                        var e = a - t.clientY;
                        o.setValue(o.getValue() + e * o.__impliedStep), a = t.clientY
                    }

                    function d() {
                        L.unbind(window, "mousemove", h), L.unbind(window, "mouseup", d), l()
                    }

                    function p(t) {
                        L.bind(window, "mousemove", h), L.bind(window, "mouseup", d), a = t.clientY
                    }
                    return i.__input = document.createElement("input"), i.__input.setAttribute("type", "text"), L.bind(i.__input, "change", c), L.bind(i.__input, "blur", u), L.bind(i.__input, "mousedown", p), L.bind(i.__input, "keydown", (function(t) {
                        13 === t.keyCode && (o.__truncationSuspended = !0, this.blur(), o.__truncationSuspended = !1, l())
                    })), i.updateDisplay(), i.domElement.appendChild(i.__input), i
                }
                return y(e, t), g(e, [{
                    key: "updateDisplay",
                    value: function() {
                        return this.__input.value = this.__truncationSuspended ? this.getValue() : N(this.getValue(), this.__precision), v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                    }
                }]), e
            }(I);

            function k(t, e, n, r, i) {
                return r + (t - e) / (n - e) * (i - r)
            }
            var F = function(t) {
                    function e(t, n, r, i, o) {
                        m(this, e);
                        var a = _(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, {
                                min: r,
                                max: i,
                                step: o
                            })),
                            s = a;

                        function c(t) {
                            document.activeElement.blur(), L.bind(window, "mousemove", l), L.bind(window, "mouseup", u), l(t)
                        }

                        function l(t) {
                            t.preventDefault();
                            var e = s.__background.getBoundingClientRect();
                            return s.setValue(k(t.clientX, e.left, e.right, s.__min, s.__max)), !1
                        }

                        function u() {
                            L.unbind(window, "mousemove", l), L.unbind(window, "mouseup", u), s.__onFinishChange && s.__onFinishChange.call(s, s.getValue())
                        }

                        function h(t) {
                            1 === t.touches.length && (L.bind(window, "touchmove", d), L.bind(window, "touchend", p), d(t))
                        }

                        function d(t) {
                            var e = t.touches[0].clientX,
                                n = s.__background.getBoundingClientRect();
                            s.setValue(k(e, n.left, n.right, s.__min, s.__max))
                        }

                        function p() {
                            L.unbind(window, "touchmove", d), L.unbind(window, "touchend", p), s.__onFinishChange && s.__onFinishChange.call(s, s.getValue())
                        }
                        return a.__background = document.createElement("div"), a.__foreground = document.createElement("div"), L.bind(a.__background, "mousedown", c), L.bind(a.__background, "touchstart", h), L.addClass(a.__background, "slider"), L.addClass(a.__foreground, "slider-fg"), a.updateDisplay(), a.__background.appendChild(a.__foreground), a.domElement.appendChild(a.__background), a
                    }
                    return y(e, t), g(e, [{
                        key: "updateDisplay",
                        value: function() {
                            var t = (this.getValue() - this.__min) / (this.__max - this.__min);
                            return this.__foreground.style.width = 100 * t + "%", v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                        }
                    }]), e
                }(I),
                B = function(t) {
                    function e(t, n, r) {
                        m(this, e);
                        var i = _(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
                            o = i;
                        return i.__button = document.createElement("div"), i.__button.innerHTML = void 0 === r ? "Fire" : r, L.bind(i.__button, "click", (function(t) {
                            return t.preventDefault(), o.fire(), !1
                        })), L.addClass(i.__button, "button"), i.domElement.appendChild(i.__button), i
                    }
                    return y(e, t), g(e, [{
                        key: "fire",
                        value: function() {
                            this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue())
                        }
                    }]), e
                }(M),
                U = function(t) {
                    function e(t, n) {
                        m(this, e);
                        var r = _(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
                        r.__color = new b(r.getValue()), r.__temp = new b(0);
                        var i = r;
                        r.domElement = document.createElement("div"), L.makeSelectable(r.domElement, !1), r.__selector = document.createElement("div"), r.__selector.className = "selector", r.__saturation_field = document.createElement("div"), r.__saturation_field.className = "saturation-field", r.__field_knob = document.createElement("div"), r.__field_knob.className = "field-knob", r.__field_knob_border = "2px solid ", r.__hue_knob = document.createElement("div"), r.__hue_knob.className = "hue-knob", r.__hue_field = document.createElement("div"), r.__hue_field.className = "hue-field", r.__input = document.createElement("input"), r.__input.type = "text", r.__input_textShadow = "0 1px 1px ", L.bind(r.__input, "keydown", (function(t) {
                            13 === t.keyCode && d.call(this)
                        })), L.bind(r.__input, "blur", d), L.bind(r.__selector, "mousedown", (function() {
                            L.addClass(this, "drag").bind(window, "mouseup", (function() {
                                L.removeClass(i.__selector, "drag")
                            }))
                        })), L.bind(r.__selector, "touchstart", (function() {
                            L.addClass(this, "drag").bind(window, "touchend", (function() {
                                L.removeClass(i.__selector, "drag")
                            }))
                        }));
                        var o = document.createElement("div");

                        function a(t) {
                            f(t), L.bind(window, "mousemove", f), L.bind(window, "touchmove", f), L.bind(window, "mouseup", l), L.bind(window, "touchend", l)
                        }

                        function c(t) {
                            g(t), L.bind(window, "mousemove", g), L.bind(window, "touchmove", g), L.bind(window, "mouseup", u), L.bind(window, "touchend", u)
                        }

                        function l() {
                            L.unbind(window, "mousemove", f), L.unbind(window, "touchmove", f), L.unbind(window, "mouseup", l), L.unbind(window, "touchend", l), p()
                        }

                        function u() {
                            L.unbind(window, "mousemove", g), L.unbind(window, "touchmove", g), L.unbind(window, "mouseup", u), L.unbind(window, "touchend", u), p()
                        }

                        function d() {
                            var t = h(this.value);
                            !1 !== t ? (i.__color.__state = t, i.setValue(i.__color.toOriginal())) : this.value = i.__color.toString()
                        }

                        function p() {
                            i.__onFinishChange && i.__onFinishChange.call(i, i.__color.toOriginal())
                        }

                        function f(t) {
                            -1 === t.type.indexOf("touch") && t.preventDefault();
                            var e = i.__saturation_field.getBoundingClientRect(),
                                n = t.touches && t.touches[0] || t,
                                r = n.clientX,
                                o = n.clientY,
                                a = (r - e.left) / (e.right - e.left),
                                s = 1 - (o - e.top) / (e.bottom - e.top);
                            return s > 1 ? s = 1 : s < 0 && (s = 0), a > 1 ? a = 1 : a < 0 && (a = 0), i.__color.v = s, i.__color.s = a, i.setValue(i.__color.toOriginal()), !1
                        }

                        function g(t) {
                            -1 === t.type.indexOf("touch") && t.preventDefault();
                            var e = i.__hue_field.getBoundingClientRect(),
                                n = t.touches && t.touches[0] || t,
                                r = n.clientY,
                                o = 1 - (r - e.top) / (e.bottom - e.top);
                            return o > 1 ? o = 1 : o < 0 && (o = 0), i.__color.h = 360 * o, i.setValue(i.__color.toOriginal()), !1
                        }
                        return s.extend(r.__selector.style, {
                            width: "122px",
                            height: "102px",
                            padding: "3px",
                            backgroundColor: "#222",
                            boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
                        }), s.extend(r.__field_knob.style, {
                            position: "absolute",
                            width: "12px",
                            height: "12px",
                            border: r.__field_knob_border + (r.__color.v < .5 ? "#fff" : "#000"),
                            boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                            borderRadius: "12px",
                            zIndex: 1
                        }), s.extend(r.__hue_knob.style, {
                            position: "absolute",
                            width: "15px",
                            height: "2px",
                            borderRight: "4px solid #fff",
                            zIndex: 1
                        }), s.extend(r.__saturation_field.style, {
                            width: "100px",
                            height: "100px",
                            border: "1px solid #555",
                            marginRight: "3px",
                            display: "inline-block",
                            cursor: "pointer"
                        }), s.extend(o.style, {
                            width: "100%",
                            height: "100%",
                            background: "none"
                        }), z(o, "top", "rgba(0,0,0,0)", "#000"), s.extend(r.__hue_field.style, {
                            width: "15px",
                            height: "100px",
                            border: "1px solid #555",
                            cursor: "ns-resize",
                            position: "absolute",
                            top: "3px",
                            right: "3px"
                        }), j(r.__hue_field), s.extend(r.__input.style, {
                            outline: "none",
                            textAlign: "center",
                            color: "#fff",
                            border: 0,
                            fontWeight: "bold",
                            textShadow: r.__input_textShadow + "rgba(0,0,0,0.7)"
                        }), L.bind(r.__saturation_field, "mousedown", a), L.bind(r.__saturation_field, "touchstart", a), L.bind(r.__field_knob, "mousedown", a), L.bind(r.__field_knob, "touchstart", a), L.bind(r.__hue_field, "mousedown", c), L.bind(r.__hue_field, "touchstart", c), r.__saturation_field.appendChild(o), r.__selector.appendChild(r.__field_knob), r.__selector.appendChild(r.__saturation_field), r.__selector.appendChild(r.__hue_field), r.__hue_field.appendChild(r.__hue_knob), r.domElement.appendChild(r.__input), r.domElement.appendChild(r.__selector), r.updateDisplay(), r
                    }
                    return y(e, t), g(e, [{
                        key: "updateDisplay",
                        value: function() {
                            var t = h(this.getValue());
                            if (!1 !== t) {
                                var e = !1;
                                s.each(b.COMPONENTS, (function(n) {
                                    if (!s.isUndefined(t[n]) && !s.isUndefined(this.__color.__state[n]) && t[n] !== this.__color.__state[n]) return e = !0, {}
                                }), this), e && s.extend(this.__color.__state, t)
                            }
                            s.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
                            var n = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0,
                                r = 255 - n;
                            s.extend(this.__field_knob.style, {
                                marginLeft: 100 * this.__color.s - 7 + "px",
                                marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                                backgroundColor: this.__temp.toHexString(),
                                border: this.__field_knob_border + "rgb(" + n + "," + n + "," + n + ")"
                            }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, z(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), s.extend(this.__input.style, {
                                backgroundColor: this.__color.toHexString(),
                                color: "rgb(" + n + "," + n + "," + n + ")",
                                textShadow: this.__input_textShadow + "rgba(" + r + "," + r + "," + r + ",.7)"
                            })
                        }
                    }]), e
                }(M),
                H = ["-moz-", "-o-", "-webkit-", "-ms-", ""];

            function z(t, e, n, r) {
                t.style.background = "", s.each(H, (function(i) {
                    t.style.cssText += "background: " + i + "linear-gradient(" + e + ", " + n + " 0%, " + r + " 100%); "
                }))
            }

            function j(t) {
                t.style.background = "", t.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", t.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"
            }
            var G = {
                    load: function(t, e) {
                        var n = e || document,
                            r = n.createElement("link");
                        r.type = "text/css", r.rel = "stylesheet", r.href = t, n.getElementsByTagName("head")[0].appendChild(r)
                    },
                    inject: function(t, e) {
                        var n = e || document,
                            r = document.createElement("style");
                        r.type = "text/css", r.innerHTML = t;
                        var i = n.getElementsByTagName("head")[0];
                        try {
                            i.appendChild(r)
                        } catch (o) {}
                    }
                },
                V = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>',
                W = function(t, e) {
                    var n = t[e];
                    return s.isArray(arguments[2]) || s.isObject(arguments[2]) ? new C(t, e, arguments[2]) : s.isNumber(n) ? s.isNumber(arguments[2]) && s.isNumber(arguments[3]) ? s.isNumber(arguments[4]) ? new F(t, e, arguments[2], arguments[3], arguments[4]) : new F(t, e, arguments[2], arguments[3]) : s.isNumber(arguments[4]) ? new D(t, e, {
                        min: arguments[2],
                        max: arguments[3],
                        step: arguments[4]
                    }) : new D(t, e, {
                        min: arguments[2],
                        max: arguments[3]
                    }) : s.isString(n) ? new O(t, e) : s.isFunction(n) ? new B(t, e, "") : s.isBoolean(n) ? new R(t, e) : null
                };

            function X(t) {
                setTimeout(t, 1e3 / 60)
            }
            var q = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || X,
                Y = function() {
                    function t() {
                        m(this, t), this.backgroundElement = document.createElement("div"), s.extend(this.backgroundElement.style, {
                            backgroundColor: "rgba(0,0,0,0.8)",
                            top: 0,
                            left: 0,
                            display: "none",
                            zIndex: "1000",
                            opacity: 0,
                            WebkitTransition: "opacity 0.2s linear",
                            transition: "opacity 0.2s linear"
                        }), L.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), s.extend(this.domElement.style, {
                            position: "fixed",
                            display: "none",
                            zIndex: "1001",
                            opacity: 0,
                            WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
                            transition: "transform 0.2s ease-out, opacity 0.2s linear"
                        }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
                        var e = this;
                        L.bind(this.backgroundElement, "click", (function() {
                            e.hide()
                        }))
                    }
                    return g(t, [{
                        key: "show",
                        value: function() {
                            var t = this;
                            this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), s.defer((function() {
                                t.backgroundElement.style.opacity = 1, t.domElement.style.opacity = 1, t.domElement.style.webkitTransform = "scale(1)"
                            }))
                        }
                    }, {
                        key: "hide",
                        value: function() {
                            var t = this,
                                e = function e() {
                                    t.domElement.style.display = "none", t.backgroundElement.style.display = "none", L.unbind(t.domElement, "webkitTransitionEnd", e), L.unbind(t.domElement, "transitionend", e), L.unbind(t.domElement, "oTransitionEnd", e)
                                };
                            L.bind(this.domElement, "webkitTransitionEnd", e), L.bind(this.domElement, "transitionend", e), L.bind(this.domElement, "oTransitionEnd", e), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)"
                        }
                    }, {
                        key: "layout",
                        value: function() {
                            this.domElement.style.left = window.innerWidth / 2 - L.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - L.getHeight(this.domElement) / 2 + "px"
                        }
                    }]), t
                }(),
                $ = r(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");
            G.inject($);
            var Z = "dg",
                J = 72,
                K = 20,
                Q = "Default",
                tt = function() {
                    try {
                        return !!window.localStorage
                    } catch (t) {
                        return !1
                    }
                }(),
                et = void 0,
                nt = !0,
                rt = void 0,
                it = !1,
                ot = [],
                at = function t(e) {
                    var n = this,
                        r = e || {};
                    this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), L.addClass(this.domElement, Z), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], r = s.defaults(r, {
                        closeOnTop: !1,
                        autoPlace: !0,
                        width: t.DEFAULT_WIDTH
                    }), r = s.defaults(r, {
                        resizable: r.autoPlace,
                        hideable: r.autoPlace
                    }), s.isUndefined(r.load) ? r.load = {
                        preset: Q
                    } : r.preset && (r.load.preset = r.preset), s.isUndefined(r.parent) && r.hideable && ot.push(this), r.resizable = s.isUndefined(r.parent) && r.resizable, r.autoPlace && s.isUndefined(r.scrollable) && (r.scrollable = !0);
                    var i = tt && "true" === localStorage.getItem(pt(this, "isLocal")),
                        o = void 0,
                        a = void 0;
                    if (Object.defineProperties(this, {
                            parent: {
                                get: function() {
                                    return r.parent
                                }
                            },
                            scrollable: {
                                get: function() {
                                    return r.scrollable
                                }
                            },
                            autoPlace: {
                                get: function() {
                                    return r.autoPlace
                                }
                            },
                            closeOnTop: {
                                get: function() {
                                    return r.closeOnTop
                                }
                            },
                            preset: {
                                get: function() {
                                    return n.parent ? n.getRoot().preset : r.load.preset
                                },
                                set: function(t) {
                                    n.parent ? n.getRoot().preset = t : r.load.preset = t, bt(this), n.revert()
                                }
                            },
                            width: {
                                get: function() {
                                    return r.width
                                },
                                set: function(t) {
                                    r.width = t, yt(n, t)
                                }
                            },
                            name: {
                                get: function() {
                                    return r.name
                                },
                                set: function(t) {
                                    r.name = t, a && (a.innerHTML = r.name)
                                }
                            },
                            closed: {
                                get: function() {
                                    return r.closed
                                },
                                set: function(e) {
                                    r.closed = e, r.closed ? L.addClass(n.__ul, t.CLASS_CLOSED) : L.removeClass(n.__ul, t.CLASS_CLOSED), this.onResize(), n.__closeButton && (n.__closeButton.innerHTML = e ? t.TEXT_OPEN : t.TEXT_CLOSED)
                                }
                            },
                            load: {
                                get: function() {
                                    return r.load
                                }
                            },
                            useLocalStorage: {
                                get: function() {
                                    return i
                                },
                                set: function(t) {
                                    tt && (i = t, t ? L.bind(window, "unload", o) : L.unbind(window, "unload", o), localStorage.setItem(pt(n, "isLocal"), t))
                                }
                            }
                        }), s.isUndefined(r.parent)) {
                        if (this.closed = r.closed || !1, L.addClass(this.domElement, t.CLASS_MAIN), L.makeSelectable(this.domElement, !1), tt && i) {
                            n.useLocalStorage = !0;
                            var c = localStorage.getItem(pt(this, "gui"));
                            c && (r.load = JSON.parse(c))
                        }
                        this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = t.TEXT_CLOSED, L.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON), r.closeOnTop ? (L.addClass(this.__closeButton, t.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (L.addClass(this.__closeButton, t.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), L.bind(this.__closeButton, "click", (function() {
                            n.closed = !n.closed
                        }))
                    } else {
                        void 0 === r.closed && (r.closed = !0);
                        var l = document.createTextNode(r.name);
                        L.addClass(l, "controller-name"), a = st(n, l);
                        var u = function(t) {
                            return t.preventDefault(), n.closed = !n.closed, !1
                        };
                        L.addClass(this.__ul, t.CLASS_CLOSED), L.addClass(a, "title"), L.bind(a, "click", u), r.closed || (this.closed = !1)
                    }

                    function h() {
                        var t = n.getRoot();
                        t.width += 1, s.defer((function() {
                            t.width -= 1
                        }))
                    }
                    r.autoPlace && (s.isUndefined(r.parent) && (nt && (rt = document.createElement("div"), L.addClass(rt, Z), L.addClass(rt, t.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(rt), nt = !1), rt.appendChild(this.domElement), L.addClass(this.domElement, t.CLASS_AUTO_PLACE)), this.parent || yt(n, r.width)), this.__resizeHandler = function() {
                        n.onResizeDebounced()
                    }, L.bind(window, "resize", this.__resizeHandler), L.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), L.bind(this.__ul, "transitionend", this.__resizeHandler), L.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), r.resizable && vt(this), o = function() {
                        tt && "true" === localStorage.getItem(pt(n, "isLocal")) && localStorage.setItem(pt(n, "gui"), JSON.stringify(n.getSaveObject()))
                    }, this.saveToLocalStorageIfPossible = o, r.parent || h()
                };

            function st(t, e, n) {
                var r = document.createElement("li");
                return e && r.appendChild(e), n ? t.__ul.insertBefore(r, n) : t.__ul.appendChild(r), t.onResize(), r
            }

            function ct(t) {
                L.unbind(window, "resize", t.__resizeHandler), t.saveToLocalStorageIfPossible && L.unbind(window, "unload", t.saveToLocalStorageIfPossible)
            }

            function lt(t, e) {
                var n = t.__preset_select[t.__preset_select.selectedIndex];
                n.innerHTML = e ? n.value + "*" : n.value
            }

            function ut(t, e, n) {
                if (n.__li = e, n.__gui = t, s.extend(n, {
                        options: function(e) {
                            if (arguments.length > 1) {
                                var r = n.__li.nextElementSibling;
                                return n.remove(), dt(t, n.object, n.property, {
                                    before: r,
                                    factoryArgs: [s.toArray(arguments)]
                                })
                            }
                            if (s.isArray(e) || s.isObject(e)) {
                                var i = n.__li.nextElementSibling;
                                return n.remove(), dt(t, n.object, n.property, {
                                    before: i,
                                    factoryArgs: [e]
                                })
                            }
                        },
                        name: function(t) {
                            return n.__li.firstElementChild.firstElementChild.innerHTML = t, n
                        },
                        listen: function() {
                            return n.__gui.listen(n), n
                        },
                        remove: function() {
                            return n.__gui.remove(n), n
                        }
                    }), n instanceof F) {
                    var r = new D(n.object, n.property, {
                        min: n.__min,
                        max: n.__max,
                        step: n.__step
                    });
                    s.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], (function(t) {
                        var e = n[t],
                            i = r[t];
                        n[t] = r[t] = function() {
                            var t = Array.prototype.slice.call(arguments);
                            return i.apply(r, t), e.apply(n, t)
                        }
                    })), L.addClass(e, "has-slider"), n.domElement.insertBefore(r.domElement, n.domElement.firstElementChild)
                } else if (n instanceof D) {
                    var i = function(e) {
                        if (s.isNumber(n.__min) && s.isNumber(n.__max)) {
                            var r = n.__li.firstElementChild.firstElementChild.innerHTML,
                                i = n.__gui.__listening.indexOf(n) > -1;
                            n.remove();
                            var o = dt(t, n.object, n.property, {
                                before: n.__li.nextElementSibling,
                                factoryArgs: [n.__min, n.__max, n.__step]
                            });
                            return o.name(r), i && o.listen(), o
                        }
                        return e
                    };
                    n.min = s.compose(i, n.min), n.max = s.compose(i, n.max)
                } else n instanceof R ? (L.bind(e, "click", (function() {
                    L.fakeEvent(n.__checkbox, "click")
                })), L.bind(n.__checkbox, "click", (function(t) {
                    t.stopPropagation()
                }))) : n instanceof B ? (L.bind(e, "click", (function() {
                    L.fakeEvent(n.__button, "click")
                })), L.bind(e, "mouseover", (function() {
                    L.addClass(n.__button, "hover")
                })), L.bind(e, "mouseout", (function() {
                    L.removeClass(n.__button, "hover")
                }))) : n instanceof U && (L.addClass(e, "color"), n.updateDisplay = s.compose((function(t) {
                    return e.style.borderLeftColor = n.__color.toString(), t
                }), n.updateDisplay), n.updateDisplay());
                n.setValue = s.compose((function(e) {
                    return t.getRoot().__preset_select && n.isModified() && lt(t.getRoot(), !0), e
                }), n.setValue)
            }

            function ht(t, e) {
                var n = t.getRoot(),
                    r = n.__rememberedObjects.indexOf(e.object);
                if (-1 !== r) {
                    var i = n.__rememberedObjectIndecesToControllers[r];
                    if (void 0 === i && (i = {}, n.__rememberedObjectIndecesToControllers[r] = i), i[e.property] = e, n.load && n.load.remembered) {
                        var o = n.load.remembered,
                            a = void 0;
                        if (o[t.preset]) a = o[t.preset];
                        else {
                            if (!o[Q]) return;
                            a = o[Q]
                        }
                        if (a[r] && void 0 !== a[r][e.property]) {
                            var s = a[r][e.property];
                            e.initialValue = s, e.setValue(s)
                        }
                    }
                }
            }

            function dt(t, e, n, r) {
                if (void 0 === e[n]) throw new Error('Object "' + e + '" has no property "' + n + '"');
                var i = void 0;
                if (r.color) i = new U(e, n);
                else {
                    var o = [e, n].concat(r.factoryArgs);
                    i = W.apply(t, o)
                }
                r.before instanceof M && (r.before = r.before.__li), ht(t, i), L.addClass(i.domElement, "c");
                var a = document.createElement("span");
                L.addClass(a, "property-name"), a.innerHTML = i.property;
                var s = document.createElement("div");
                s.appendChild(a), s.appendChild(i.domElement);
                var c = st(t, s, r.before);
                return L.addClass(c, at.CLASS_CONTROLLER_ROW), i instanceof U ? L.addClass(c, "color") : L.addClass(c, f(i.getValue())), ut(t, c, i), t.__controllers.push(i), i
            }

            function pt(t, e) {
                return document.location.href + "." + e
            }

            function ft(t, e, n) {
                var r = document.createElement("option");
                r.innerHTML = e, r.value = e, t.__preset_select.appendChild(r), n && (t.__preset_select.selectedIndex = t.__preset_select.length - 1)
            }

            function mt(t, e) {
                e.style.display = t.useLocalStorage ? "block" : "none"
            }

            function gt(t) {
                var e = t.__save_row = document.createElement("li");
                L.addClass(t.domElement, "has-save"), t.__ul.insertBefore(e, t.__ul.firstChild), L.addClass(e, "save-row");
                var n = document.createElement("span");
                n.innerHTML = "&nbsp;", L.addClass(n, "button gears");
                var r = document.createElement("span");
                r.innerHTML = "Save", L.addClass(r, "button"), L.addClass(r, "save");
                var i = document.createElement("span");
                i.innerHTML = "New", L.addClass(i, "button"), L.addClass(i, "save-as");
                var o = document.createElement("span");
                o.innerHTML = "Revert", L.addClass(o, "button"), L.addClass(o, "revert");
                var a = t.__preset_select = document.createElement("select");
                if (t.load && t.load.remembered ? s.each(t.load.remembered, (function(e, n) {
                        ft(t, n, n === t.preset)
                    })) : ft(t, Q, !1), L.bind(a, "change", (function() {
                        for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].innerHTML = t.__preset_select[e].value;
                        t.preset = this.value
                    })), e.appendChild(a), e.appendChild(n), e.appendChild(r), e.appendChild(i), e.appendChild(o), tt) {
                    var c = document.getElementById("dg-local-explain"),
                        l = document.getElementById("dg-local-storage"),
                        u = document.getElementById("dg-save-locally");
                    u.style.display = "block", "true" === localStorage.getItem(pt(t, "isLocal")) && l.setAttribute("checked", "checked"), mt(t, c), L.bind(l, "change", (function() {
                        t.useLocalStorage = !t.useLocalStorage, mt(t, c)
                    }))
                }
                var h = document.getElementById("dg-new-constructor");
                L.bind(h, "keydown", (function(t) {
                    !t.metaKey || 67 !== t.which && 67 !== t.keyCode || et.hide()
                })), L.bind(n, "click", (function() {
                    h.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2), et.show(), h.focus(), h.select()
                })), L.bind(r, "click", (function() {
                    t.save()
                })), L.bind(i, "click", (function() {
                    var e = prompt("Enter a new preset name.");
                    e && t.saveAs(e)
                })), L.bind(o, "click", (function() {
                    t.revert()
                }))
            }

            function vt(t) {
                var e = void 0;

                function n(n) {
                    return n.preventDefault(), t.width += e - n.clientX, t.onResize(), e = n.clientX, !1
                }

                function r() {
                    L.removeClass(t.__closeButton, at.CLASS_DRAG), L.unbind(window, "mousemove", n), L.unbind(window, "mouseup", r)
                }

                function i(i) {
                    return i.preventDefault(), e = i.clientX, L.addClass(t.__closeButton, at.CLASS_DRAG), L.bind(window, "mousemove", n), L.bind(window, "mouseup", r), !1
                }
                t.__resize_handle = document.createElement("div"), s.extend(t.__resize_handle.style, {
                    width: "6px",
                    marginLeft: "-3px",
                    height: "200px",
                    cursor: "ew-resize",
                    position: "absolute"
                }), L.bind(t.__resize_handle, "mousedown", i), L.bind(t.__closeButton, "mousedown", i), t.domElement.insertBefore(t.__resize_handle, t.domElement.firstElementChild)
            }

            function yt(t, e) {
                t.domElement.style.width = e + "px", t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"), t.__closeButton && (t.__closeButton.style.width = e + "px")
            }

            function _t(t, e) {
                var n = {};
                return s.each(t.__rememberedObjects, (function(r, i) {
                    var o = {},
                        a = t.__rememberedObjectIndecesToControllers[i];
                    s.each(a, (function(t, n) {
                        o[n] = e ? t.initialValue : t.getValue()
                    })), n[i] = o
                })), n
            }

            function bt(t) {
                for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].value === t.preset && (t.__preset_select.selectedIndex = e)
            }

            function xt(t) {
                0 !== t.length && q.call(window, (function() {
                    xt(t)
                })), s.each(t, (function(t) {
                    t.updateDisplay()
                }))
            }
            at.toggleHide = function() {
                it = !it, s.each(ot, (function(t) {
                    t.domElement.style.display = it ? "none" : ""
                }))
            }, at.CLASS_AUTO_PLACE = "a", at.CLASS_AUTO_PLACE_CONTAINER = "ac", at.CLASS_MAIN = "main", at.CLASS_CONTROLLER_ROW = "cr", at.CLASS_TOO_TALL = "taller-than-window", at.CLASS_CLOSED = "closed", at.CLASS_CLOSE_BUTTON = "close-button", at.CLASS_CLOSE_TOP = "close-top", at.CLASS_CLOSE_BOTTOM = "close-bottom", at.CLASS_DRAG = "drag", at.DEFAULT_WIDTH = 245, at.TEXT_CLOSED = "Close Controls", at.TEXT_OPEN = "Open Controls", at._keydownHandler = function(t) {
                "text" === document.activeElement.type || t.which !== J && t.keyCode !== J || at.toggleHide()
            }, L.bind(window, "keydown", at._keydownHandler, !1), s.extend(at.prototype, {
                add: function(t, e) {
                    return dt(this, t, e, {
                        factoryArgs: Array.prototype.slice.call(arguments, 2)
                    })
                },
                addColor: function(t, e) {
                    return dt(this, t, e, {
                        color: !0
                    })
                },
                remove: function(t) {
                    this.__ul.removeChild(t.__li), this.__controllers.splice(this.__controllers.indexOf(t), 1);
                    var e = this;
                    s.defer((function() {
                        e.onResize()
                    }))
                },
                destroy: function() {
                    if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
                    this.autoPlace && rt.removeChild(this.domElement);
                    var t = this;
                    s.each(this.__folders, (function(e) {
                        t.removeFolder(e)
                    })), L.unbind(window, "keydown", at._keydownHandler, !1), ct(this)
                },
                addFolder: function(t) {
                    if (void 0 !== this.__folders[t]) throw new Error('You already have a folder in this GUI by the name "' + t + '"');
                    var e = {
                        name: t,
                        parent: this
                    };
                    e.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[t] && (e.closed = this.load.folders[t].closed, e.load = this.load.folders[t]);
                    var n = new at(e);
                    this.__folders[t] = n;
                    var r = st(this, n.domElement);
                    return L.addClass(r, "folder"), n
                },
                removeFolder: function(t) {
                    this.__ul.removeChild(t.domElement.parentElement), delete this.__folders[t.name], this.load && this.load.folders && this.load.folders[t.name] && delete this.load.folders[t.name], ct(t);
                    var e = this;
                    s.each(t.__folders, (function(e) {
                        t.removeFolder(e)
                    })), s.defer((function() {
                        e.onResize()
                    }))
                },
                open: function() {
                    this.closed = !1
                },
                close: function() {
                    this.closed = !0
                },
                hide: function() {
                    this.domElement.style.display = "none"
                },
                show: function() {
                    this.domElement.style.display = ""
                },
                onResize: function() {
                    var t = this.getRoot();
                    if (t.scrollable) {
                        var e = L.getOffset(t.__ul).top,
                            n = 0;
                        s.each(t.__ul.childNodes, (function(e) {
                            t.autoPlace && e === t.__save_row || (n += L.getHeight(e))
                        })), window.innerHeight - e - K < n ? (L.addClass(t.domElement, at.CLASS_TOO_TALL), t.__ul.style.height = window.innerHeight - e - K + "px") : (L.removeClass(t.domElement, at.CLASS_TOO_TALL), t.__ul.style.height = "auto")
                    }
                    t.__resize_handle && s.defer((function() {
                        t.__resize_handle.style.height = t.__ul.offsetHeight + "px"
                    })), t.__closeButton && (t.__closeButton.style.width = t.width + "px")
                },
                onResizeDebounced: s.debounce((function() {
                    this.onResize()
                }), 50),
                remember: function() {
                    if (s.isUndefined(et) && (et = new Y, et.domElement.innerHTML = V), this.parent) throw new Error("You can only call remember on a top level GUI.");
                    var t = this;
                    s.each(Array.prototype.slice.call(arguments), (function(e) {
                        0 === t.__rememberedObjects.length && gt(t), -1 === t.__rememberedObjects.indexOf(e) && t.__rememberedObjects.push(e)
                    })), this.autoPlace && yt(this, this.width)
                },
                getRoot: function() {
                    var t = this;
                    while (t.parent) t = t.parent;
                    return t
                },
                getSaveObject: function() {
                    var t = this.load;
                    return t.closed = this.closed, this.__rememberedObjects.length > 0 && (t.preset = this.preset, t.remembered || (t.remembered = {}), t.remembered[this.preset] = _t(this)), t.folders = {}, s.each(this.__folders, (function(e, n) {
                        t.folders[n] = e.getSaveObject()
                    })), t
                },
                save: function() {
                    this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = _t(this), lt(this, !1), this.saveToLocalStorageIfPossible()
                },
                saveAs: function(t) {
                    this.load.remembered || (this.load.remembered = {}, this.load.remembered[Q] = _t(this, !0)), this.load.remembered[t] = _t(this), this.preset = t, ft(this, t, !0), this.saveToLocalStorageIfPossible()
                },
                revert: function(t) {
                    s.each(this.__controllers, (function(e) {
                        this.getRoot().load.remembered ? ht(t || this.getRoot(), e) : e.setValue(e.initialValue), e.__onFinishChange && e.__onFinishChange.call(e, e.getValue())
                    }), this), s.each(this.__folders, (function(t) {
                        t.revert(t)
                    })), t || lt(this.getRoot(), !1)
                },
                listen: function(t) {
                    var e = 0 === this.__listening.length;
                    this.__listening.push(t), e && xt(this.__listening)
                },
                updateDisplay: function() {
                    s.each(this.__controllers, (function(t) {
                        t.updateDisplay()
                    })), s.each(this.__folders, (function(t) {
                        t.updateDisplay()
                    }))
                }
            });
            var wt = at
        },
        "8aa5": function(t, e, n) {
            "use strict";
            var r = n("6547").charAt;
            t.exports = function(t, e, n) {
                return e + (n ? r(t, e).length : 1)
            }
        },
        "8aa7": function(t, e, n) {
            var r = n("da84"),
                i = n("d039"),
                o = n("1c7e"),
                a = n("ebb5").NATIVE_ARRAY_BUFFER_VIEWS,
                s = r.ArrayBuffer,
                c = r.Int8Array;
            t.exports = !a || !i((function() {
                c(1)
            })) || !i((function() {
                new c(-1)
            })) || !o((function(t) {
                new c, new c(null), new c(1.5), new c(t)
            }), !0) || i((function() {
                return 1 !== new c(new s(2), 1, void 0).length
            }))
        },
        "8c4f": function(t, e, n) {
            "use strict";
            /*!
             * vue-router v3.3.4
             * (c) 2020 Evan You
             * @license MIT
             */
            function r(t, e) {
                0
            }

            function i(t) {
                return Object.prototype.toString.call(t).indexOf("Error") > -1
            }

            function o(t, e) {
                return i(t) && t._isRouter && (null == e || t.type === e)
            }

            function a(t, e) {
                for (var n in e) t[n] = e[n];
                return t
            }
            var s = {
                name: "RouterView",
                functional: !0,
                props: {
                    name: {
                        type: String,
                        default: "default"
                    }
                },
                render: function(t, e) {
                    var n = e.props,
                        r = e.children,
                        i = e.parent,
                        o = e.data;
                    o.routerView = !0;
                    var s = i.$createElement,
                        l = n.name,
                        u = i.$route,
                        h = i._routerViewCache || (i._routerViewCache = {}),
                        d = 0,
                        p = !1;
                    while (i && i._routerRoot !== i) {
                        var f = i.$vnode ? i.$vnode.data : {};
                        f.routerView && d++, f.keepAlive && i._directInactive && i._inactive && (p = !0), i = i.$parent
                    }
                    if (o.routerViewDepth = d, p) {
                        var m = h[l],
                            g = m && m.component;
                        return g ? (m.configProps && c(g, o, m.route, m.configProps), s(g, o, r)) : s()
                    }
                    var v = u.matched[d],
                        y = v && v.components[l];
                    if (!v || !y) return h[l] = null, s();
                    h[l] = {
                        component: y
                    }, o.registerRouteInstance = function(t, e) {
                        var n = v.instances[l];
                        (e && n !== t || !e && n === t) && (v.instances[l] = e)
                    }, (o.hook || (o.hook = {})).prepatch = function(t, e) {
                        v.instances[l] = e.componentInstance
                    }, o.hook.init = function(t) {
                        t.data.keepAlive && t.componentInstance && t.componentInstance !== v.instances[l] && (v.instances[l] = t.componentInstance)
                    };
                    var _ = v.props && v.props[l];
                    return _ && (a(h[l], {
                        route: u,
                        configProps: _
                    }), c(y, o, u, _)), s(y, o, r)
                }
            };

            function c(t, e, n, r) {
                var i = e.props = l(n, r);
                if (i) {
                    i = e.props = a({}, i);
                    var o = e.attrs = e.attrs || {};
                    for (var s in i) t.props && s in t.props || (o[s] = i[s], delete i[s])
                }
            }

            function l(t, e) {
                switch (typeof e) {
                    case "undefined":
                        return;
                    case "object":
                        return e;
                    case "function":
                        return e(t);
                    case "boolean":
                        return e ? t.params : void 0;
                    default:
                        0
                }
            }
            var u = /[!'()*]/g,
                h = function(t) {
                    return "%" + t.charCodeAt(0).toString(16)
                },
                d = /%2C/g,
                p = function(t) {
                    return encodeURIComponent(t).replace(u, h).replace(d, ",")
                },
                f = decodeURIComponent;

            function m(t, e, n) {
                void 0 === e && (e = {});
                var r, i = n || g;
                try {
                    r = i(t || "")
                } catch (a) {
                    r = {}
                }
                for (var o in e) r[o] = e[o];
                return r
            }

            function g(t) {
                var e = {};
                return t = t.trim().replace(/^(\?|#|&)/, ""), t ? (t.split("&").forEach((function(t) {
                    var n = t.replace(/\+/g, " ").split("="),
                        r = f(n.shift()),
                        i = n.length > 0 ? f(n.join("=")) : null;
                    void 0 === e[r] ? e[r] = i : Array.isArray(e[r]) ? e[r].push(i) : e[r] = [e[r], i]
                })), e) : e
            }

            function v(t) {
                var e = t ? Object.keys(t).map((function(e) {
                    var n = t[e];
                    if (void 0 === n) return "";
                    if (null === n) return p(e);
                    if (Array.isArray(n)) {
                        var r = [];
                        return n.forEach((function(t) {
                            void 0 !== t && (null === t ? r.push(p(e)) : r.push(p(e) + "=" + p(t)))
                        })), r.join("&")
                    }
                    return p(e) + "=" + p(n)
                })).filter((function(t) {
                    return t.length > 0
                })).join("&") : null;
                return e ? "?" + e : ""
            }
            var y = /\/?$/;

            function _(t, e, n, r) {
                var i = r && r.options.stringifyQuery,
                    o = e.query || {};
                try {
                    o = b(o)
                } catch (s) {}
                var a = {
                    name: e.name || t && t.name,
                    meta: t && t.meta || {},
                    path: e.path || "/",
                    hash: e.hash || "",
                    query: o,
                    params: e.params || {},
                    fullPath: M(e, i),
                    matched: t ? w(t) : []
                };
                return n && (a.redirectedFrom = M(n, i)), Object.freeze(a)
            }

            function b(t) {
                if (Array.isArray(t)) return t.map(b);
                if (t && "object" === typeof t) {
                    var e = {};
                    for (var n in t) e[n] = b(t[n]);
                    return e
                }
                return t
            }
            var x = _(null, {
                path: "/"
            });

            function w(t) {
                var e = [];
                while (t) e.unshift(t), t = t.parent;
                return e
            }

            function M(t, e) {
                var n = t.path,
                    r = t.query;
                void 0 === r && (r = {});
                var i = t.hash;
                void 0 === i && (i = "");
                var o = e || v;
                return (n || "/") + o(r) + i
            }

            function T(t, e) {
                return e === x ? t === e : !!e && (t.path && e.path ? t.path.replace(y, "") === e.path.replace(y, "") && t.hash === e.hash && S(t.query, e.query) : !(!t.name || !e.name) && (t.name === e.name && t.hash === e.hash && S(t.query, e.query) && S(t.params, e.params)))
            }

            function S(t, e) {
                if (void 0 === t && (t = {}), void 0 === e && (e = {}), !t || !e) return t === e;
                var n = Object.keys(t),
                    r = Object.keys(e);
                return n.length === r.length && n.every((function(n) {
                    var r = t[n],
                        i = e[n];
                    return "object" === typeof r && "object" === typeof i ? S(r, i) : String(r) === String(i)
                }))
            }

            function E(t, e) {
                return 0 === t.path.replace(y, "/").indexOf(e.path.replace(y, "/")) && (!e.hash || t.hash === e.hash) && A(t.query, e.query)
            }

            function A(t, e) {
                for (var n in e)
                    if (!(n in t)) return !1;
                return !0
            }

            function L(t, e, n) {
                var r = t.charAt(0);
                if ("/" === r) return t;
                if ("?" === r || "#" === r) return e + t;
                var i = e.split("/");
                n && i[i.length - 1] || i.pop();
                for (var o = t.replace(/^\//, "").split("/"), a = 0; a < o.length; a++) {
                    var s = o[a];
                    ".." === s ? i.pop() : "." !== s && i.push(s)
                }
                return "" !== i[0] && i.unshift(""), i.join("/")
            }

            function R(t) {
                var e = "",
                    n = "",
                    r = t.indexOf("#");
                r >= 0 && (e = t.slice(r), t = t.slice(0, r));
                var i = t.indexOf("?");
                return i >= 0 && (n = t.slice(i + 1), t = t.slice(0, i)), {
                    path: t,
                    query: n,
                    hash: e
                }
            }

            function C(t) {
                return t.replace(/\/\//g, "/")
            }
            var O = Array.isArray || function(t) {
                    return "[object Array]" == Object.prototype.toString.call(t)
                },
                P = J,
                I = B,
                N = U,
                D = j,
                k = Z,
                F = new RegExp(["(\\\\.)", "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"), "g");

            function B(t, e) {
                var n, r = [],
                    i = 0,
                    o = 0,
                    a = "",
                    s = e && e.delimiter || "/";
                while (null != (n = F.exec(t))) {
                    var c = n[0],
                        l = n[1],
                        u = n.index;
                    if (a += t.slice(o, u), o = u + c.length, l) a += l[1];
                    else {
                        var h = t[o],
                            d = n[2],
                            p = n[3],
                            f = n[4],
                            m = n[5],
                            g = n[6],
                            v = n[7];
                        a && (r.push(a), a = "");
                        var y = null != d && null != h && h !== d,
                            _ = "+" === g || "*" === g,
                            b = "?" === g || "*" === g,
                            x = n[2] || s,
                            w = f || m;
                        r.push({
                            name: p || i++,
                            prefix: d || "",
                            delimiter: x,
                            optional: b,
                            repeat: _,
                            partial: y,
                            asterisk: !!v,
                            pattern: w ? V(w) : v ? ".*" : "[^" + G(x) + "]+?"
                        })
                    }
                }
                return o < t.length && (a += t.substr(o)), a && r.push(a), r
            }

            function U(t, e) {
                return j(B(t, e), e)
            }

            function H(t) {
                return encodeURI(t).replace(/[\/?#]/g, (function(t) {
                    return "%" + t.charCodeAt(0).toString(16).toUpperCase()
                }))
            }

            function z(t) {
                return encodeURI(t).replace(/[?#]/g, (function(t) {
                    return "%" + t.charCodeAt(0).toString(16).toUpperCase()
                }))
            }

            function j(t, e) {
                for (var n = new Array(t.length), r = 0; r < t.length; r++) "object" === typeof t[r] && (n[r] = new RegExp("^(?:" + t[r].pattern + ")$", X(e)));
                return function(e, r) {
                    for (var i = "", o = e || {}, a = r || {}, s = a.pretty ? H : encodeURIComponent, c = 0; c < t.length; c++) {
                        var l = t[c];
                        if ("string" !== typeof l) {
                            var u, h = o[l.name];
                            if (null == h) {
                                if (l.optional) {
                                    l.partial && (i += l.prefix);
                                    continue
                                }
                                throw new TypeError('Expected "' + l.name + '" to be defined')
                            }
                            if (O(h)) {
                                if (!l.repeat) throw new TypeError('Expected "' + l.name + '" to not repeat, but received `' + JSON.stringify(h) + "`");
                                if (0 === h.length) {
                                    if (l.optional) continue;
                                    throw new TypeError('Expected "' + l.name + '" to not be empty')
                                }
                                for (var d = 0; d < h.length; d++) {
                                    if (u = s(h[d]), !n[c].test(u)) throw new TypeError('Expected all "' + l.name + '" to match "' + l.pattern + '", but received `' + JSON.stringify(u) + "`");
                                    i += (0 === d ? l.prefix : l.delimiter) + u
                                }
                            } else {
                                if (u = l.asterisk ? z(h) : s(h), !n[c].test(u)) throw new TypeError('Expected "' + l.name + '" to match "' + l.pattern + '", but received "' + u + '"');
                                i += l.prefix + u
                            }
                        } else i += l
                    }
                    return i
                }
            }

            function G(t) {
                return t.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1")
            }

            function V(t) {
                return t.replace(/([=!:$\/()])/g, "\\$1")
            }

            function W(t, e) {
                return t.keys = e, t
            }

            function X(t) {
                return t && t.sensitive ? "" : "i"
            }

            function q(t, e) {
                var n = t.source.match(/\((?!\?)/g);
                if (n)
                    for (var r = 0; r < n.length; r++) e.push({
                        name: r,
                        prefix: null,
                        delimiter: null,
                        optional: !1,
                        repeat: !1,
                        partial: !1,
                        asterisk: !1,
                        pattern: null
                    });
                return W(t, e)
            }

            function Y(t, e, n) {
                for (var r = [], i = 0; i < t.length; i++) r.push(J(t[i], e, n).source);
                var o = new RegExp("(?:" + r.join("|") + ")", X(n));
                return W(o, e)
            }

            function $(t, e, n) {
                return Z(B(t, n), e, n)
            }

            function Z(t, e, n) {
                O(e) || (n = e || n, e = []), n = n || {};
                for (var r = n.strict, i = !1 !== n.end, o = "", a = 0; a < t.length; a++) {
                    var s = t[a];
                    if ("string" === typeof s) o += G(s);
                    else {
                        var c = G(s.prefix),
                            l = "(?:" + s.pattern + ")";
                        e.push(s), s.repeat && (l += "(?:" + c + l + ")*"), l = s.optional ? s.partial ? c + "(" + l + ")?" : "(?:" + c + "(" + l + "))?" : c + "(" + l + ")", o += l
                    }
                }
                var u = G(n.delimiter || "/"),
                    h = o.slice(-u.length) === u;
                return r || (o = (h ? o.slice(0, -u.length) : o) + "(?:" + u + "(?=$))?"), o += i ? "$" : r && h ? "" : "(?=" + u + "|$)", W(new RegExp("^" + o, X(n)), e)
            }

            function J(t, e, n) {
                return O(e) || (n = e || n, e = []), n = n || {}, t instanceof RegExp ? q(t, e) : O(t) ? Y(t, e, n) : $(t, e, n)
            }
            P.parse = I, P.compile = N, P.tokensToFunction = D, P.tokensToRegExp = k;
            var K = Object.create(null);

            function Q(t, e, n) {
                e = e || {};
                try {
                    var r = K[t] || (K[t] = P.compile(t));
                    return "string" === typeof e.pathMatch && (e[0] = e.pathMatch), r(e, {
                        pretty: !0
                    })
                } catch (i) {
                    return ""
                } finally {
                    delete e[0]
                }
            }

            function tt(t, e, n, r) {
                var i = "string" === typeof t ? {
                    path: t
                } : t;
                if (i._normalized) return i;
                if (i.name) {
                    i = a({}, t);
                    var o = i.params;
                    return o && "object" === typeof o && (i.params = a({}, o)), i
                }
                if (!i.path && i.params && e) {
                    i = a({}, i), i._normalized = !0;
                    var s = a(a({}, e.params), i.params);
                    if (e.name) i.name = e.name, i.params = s;
                    else if (e.matched.length) {
                        var c = e.matched[e.matched.length - 1].path;
                        i.path = Q(c, s, "path " + e.path)
                    } else 0;
                    return i
                }
                var l = R(i.path || ""),
                    u = e && e.path || "/",
                    h = l.path ? L(l.path, u, n || i.append) : u,
                    d = m(l.query, i.query, r && r.options.parseQuery),
                    p = i.hash || l.hash;
                return p && "#" !== p.charAt(0) && (p = "#" + p), {
                    _normalized: !0,
                    path: h,
                    query: d,
                    hash: p
                }
            }
            var et, nt = [String, Object],
                rt = [String, Array],
                it = function() {},
                ot = {
                    name: "RouterLink",
                    props: {
                        to: {
                            type: nt,
                            required: !0
                        },
                        tag: {
                            type: String,
                            default: "a"
                        },
                        exact: Boolean,
                        append: Boolean,
                        replace: Boolean,
                        activeClass: String,
                        exactActiveClass: String,
                        ariaCurrentValue: {
                            type: String,
                            default: "page"
                        },
                        event: {
                            type: rt,
                            default: "click"
                        }
                    },
                    render: function(t) {
                        var e = this,
                            n = this.$router,
                            r = this.$route,
                            i = n.resolve(this.to, r, this.append),
                            o = i.location,
                            s = i.route,
                            c = i.href,
                            l = {},
                            u = n.options.linkActiveClass,
                            h = n.options.linkExactActiveClass,
                            d = null == u ? "router-link-active" : u,
                            p = null == h ? "router-link-exact-active" : h,
                            f = null == this.activeClass ? d : this.activeClass,
                            m = null == this.exactActiveClass ? p : this.exactActiveClass,
                            g = s.redirectedFrom ? _(null, tt(s.redirectedFrom), null, n) : s;
                        l[m] = T(r, g), l[f] = this.exact ? l[m] : E(r, g);
                        var v = l[m] ? this.ariaCurrentValue : null,
                            y = function(t) {
                                at(t) && (e.replace ? n.replace(o, it) : n.push(o, it))
                            },
                            b = {
                                click: at
                            };
                        Array.isArray(this.event) ? this.event.forEach((function(t) {
                            b[t] = y
                        })) : b[this.event] = y;
                        var x = {
                                class: l
                            },
                            w = !this.$scopedSlots.$hasNormal && this.$scopedSlots.default && this.$scopedSlots.default({
                                href: c,
                                route: s,
                                navigate: y,
                                isActive: l[f],
                                isExactActive: l[m]
                            });
                        if (w) {
                            if (1 === w.length) return w[0];
                            if (w.length > 1 || !w.length) return 0 === w.length ? t() : t("span", {}, w)
                        }
                        if ("a" === this.tag) x.on = b, x.attrs = {
                            href: c,
                            "aria-current": v
                        };
                        else {
                            var M = st(this.$slots.default);
                            if (M) {
                                M.isStatic = !1;
                                var S = M.data = a({}, M.data);
                                for (var A in S.on = S.on || {}, S.on) {
                                    var L = S.on[A];
                                    A in b && (S.on[A] = Array.isArray(L) ? L : [L])
                                }
                                for (var R in b) R in S.on ? S.on[R].push(b[R]) : S.on[R] = y;
                                var C = M.data.attrs = a({}, M.data.attrs);
                                C.href = c, C["aria-current"] = v
                            } else x.on = b
                        }
                        return t(this.tag, x, this.$slots.default)
                    }
                };

            function at(t) {
                if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) && !t.defaultPrevented && (void 0 === t.button || 0 === t.button)) {
                    if (t.currentTarget && t.currentTarget.getAttribute) {
                        var e = t.currentTarget.getAttribute("target");
                        if (/\b_blank\b/i.test(e)) return
                    }
                    return t.preventDefault && t.preventDefault(), !0
                }
            }

            function st(t) {
                if (t)
                    for (var e, n = 0; n < t.length; n++) {
                        if (e = t[n], "a" === e.tag) return e;
                        if (e.children && (e = st(e.children))) return e
                    }
            }

            function ct(t) {
                if (!ct.installed || et !== t) {
                    ct.installed = !0, et = t;
                    var e = function(t) {
                            return void 0 !== t
                        },
                        n = function(t, n) {
                            var r = t.$options._parentVnode;
                            e(r) && e(r = r.data) && e(r = r.registerRouteInstance) && r(t, n)
                        };
                    t.mixin({
                        beforeCreate: function() {
                            e(this.$options.router) ? (this._routerRoot = this, this._router = this.$options.router, this._router.init(this), t.util.defineReactive(this, "_route", this._router.history.current)) : this._routerRoot = this.$parent && this.$parent._routerRoot || this, n(this, this)
                        },
                        destroyed: function() {
                            n(this)
                        }
                    }), Object.defineProperty(t.prototype, "$router", {
                        get: function() {
                            return this._routerRoot._router
                        }
                    }), Object.defineProperty(t.prototype, "$route", {
                        get: function() {
                            return this._routerRoot._route
                        }
                    }), t.component("RouterView", s), t.component("RouterLink", ot);
                    var r = t.config.optionMergeStrategies;
                    r.beforeRouteEnter = r.beforeRouteLeave = r.beforeRouteUpdate = r.created
                }
            }
            var lt = "undefined" !== typeof window;

            function ut(t, e, n, r) {
                var i = e || [],
                    o = n || Object.create(null),
                    a = r || Object.create(null);
                t.forEach((function(t) {
                    ht(i, o, a, t)
                }));
                for (var s = 0, c = i.length; s < c; s++) "*" === i[s] && (i.push(i.splice(s, 1)[0]), c--, s--);
                return {
                    pathList: i,
                    pathMap: o,
                    nameMap: a
                }
            }

            function ht(t, e, n, r, i, o) {
                var a = r.path,
                    s = r.name;
                var c = r.pathToRegexpOptions || {},
                    l = pt(a, i, c.strict);
                "boolean" === typeof r.caseSensitive && (c.sensitive = r.caseSensitive);
                var u = {
                    path: l,
                    regex: dt(l, c),
                    components: r.components || {
                        default: r.component
                    },
                    instances: {},
                    name: s,
                    parent: i,
                    matchAs: o,
                    redirect: r.redirect,
                    beforeEnter: r.beforeEnter,
                    meta: r.meta || {},
                    props: null == r.props ? {} : r.components ? r.props : {
                        default: r.props
                    }
                };
                if (r.children && r.children.forEach((function(r) {
                        var i = o ? C(o + "/" + r.path) : void 0;
                        ht(t, e, n, r, u, i)
                    })), e[u.path] || (t.push(u.path), e[u.path] = u), void 0 !== r.alias)
                    for (var h = Array.isArray(r.alias) ? r.alias : [r.alias], d = 0; d < h.length; ++d) {
                        var p = h[d];
                        0;
                        var f = {
                            path: p,
                            children: r.children
                        };
                        ht(t, e, n, f, i, u.path || "/")
                    }
                s && (n[s] || (n[s] = u))
            }

            function dt(t, e) {
                var n = P(t, [], e);
                return n
            }

            function pt(t, e, n) {
                return n || (t = t.replace(/\/$/, "")), "/" === t[0] || null == e ? t : C(e.path + "/" + t)
            }

            function ft(t, e) {
                var n = ut(t),
                    r = n.pathList,
                    i = n.pathMap,
                    o = n.nameMap;

                function a(t) {
                    ut(t, r, i, o)
                }

                function s(t, n, a) {
                    var s = tt(t, n, !1, e),
                        c = s.name;
                    if (c) {
                        var l = o[c];
                        if (!l) return u(null, s);
                        var h = l.regex.keys.filter((function(t) {
                            return !t.optional
                        })).map((function(t) {
                            return t.name
                        }));
                        if ("object" !== typeof s.params && (s.params = {}), n && "object" === typeof n.params)
                            for (var d in n.params) !(d in s.params) && h.indexOf(d) > -1 && (s.params[d] = n.params[d]);
                        return s.path = Q(l.path, s.params, 'named route "' + c + '"'), u(l, s, a)
                    }
                    if (s.path) {
                        s.params = {};
                        for (var p = 0; p < r.length; p++) {
                            var f = r[p],
                                m = i[f];
                            if (mt(m.regex, s.path, s.params)) return u(m, s, a)
                        }
                    }
                    return u(null, s)
                }

                function c(t, n) {
                    var r = t.redirect,
                        i = "function" === typeof r ? r(_(t, n, null, e)) : r;
                    if ("string" === typeof i && (i = {
                            path: i
                        }), !i || "object" !== typeof i) return u(null, n);
                    var a = i,
                        c = a.name,
                        l = a.path,
                        h = n.query,
                        d = n.hash,
                        p = n.params;
                    if (h = a.hasOwnProperty("query") ? a.query : h, d = a.hasOwnProperty("hash") ? a.hash : d, p = a.hasOwnProperty("params") ? a.params : p, c) {
                        o[c];
                        return s({
                            _normalized: !0,
                            name: c,
                            query: h,
                            hash: d,
                            params: p
                        }, void 0, n)
                    }
                    if (l) {
                        var f = gt(l, t),
                            m = Q(f, p, 'redirect route with path "' + f + '"');
                        return s({
                            _normalized: !0,
                            path: m,
                            query: h,
                            hash: d
                        }, void 0, n)
                    }
                    return u(null, n)
                }

                function l(t, e, n) {
                    var r = Q(n, e.params, 'aliased route with path "' + n + '"'),
                        i = s({
                            _normalized: !0,
                            path: r
                        });
                    if (i) {
                        var o = i.matched,
                            a = o[o.length - 1];
                        return e.params = i.params, u(a, e)
                    }
                    return u(null, e)
                }

                function u(t, n, r) {
                    return t && t.redirect ? c(t, r || n) : t && t.matchAs ? l(t, n, t.matchAs) : _(t, n, r, e)
                }
                return {
                    match: s,
                    addRoutes: a
                }
            }

            function mt(t, e, n) {
                var r = e.match(t);
                if (!r) return !1;
                if (!n) return !0;
                for (var i = 1, o = r.length; i < o; ++i) {
                    var a = t.keys[i - 1],
                        s = "string" === typeof r[i] ? decodeURIComponent(r[i]) : r[i];
                    a && (n[a.name || "pathMatch"] = s)
                }
                return !0
            }

            function gt(t, e) {
                return L(t, e.parent ? e.parent.path : "/", !0)
            }
            var vt = lt && window.performance && window.performance.now ? window.performance : Date;

            function yt() {
                return vt.now().toFixed(3)
            }
            var _t = yt();

            function bt() {
                return _t
            }

            function xt(t) {
                return _t = t
            }
            var wt = Object.create(null);

            function Mt() {
                "scrollRestoration" in window.history && (window.history.scrollRestoration = "manual");
                var t = window.location.protocol + "//" + window.location.host,
                    e = window.location.href.replace(t, ""),
                    n = a({}, window.history.state);
                return n.key = bt(), window.history.replaceState(n, "", e), window.addEventListener("popstate", Et),
                    function() {
                        window.removeEventListener("popstate", Et)
                    }
            }

            function Tt(t, e, n, r) {
                if (t.app) {
                    var i = t.options.scrollBehavior;
                    i && t.app.$nextTick((function() {
                        var o = At(),
                            a = i.call(t, e, n, r ? o : null);
                        a && ("function" === typeof a.then ? a.then((function(t) {
                            Nt(t, o)
                        })).catch((function(t) {
                            0
                        })) : Nt(a, o))
                    }))
                }
            }

            function St() {
                var t = bt();
                t && (wt[t] = {
                    x: window.pageXOffset,
                    y: window.pageYOffset
                })
            }

            function Et(t) {
                St(), t.state && t.state.key && xt(t.state.key)
            }

            function At() {
                var t = bt();
                if (t) return wt[t]
            }

            function Lt(t, e) {
                var n = document.documentElement,
                    r = n.getBoundingClientRect(),
                    i = t.getBoundingClientRect();
                return {
                    x: i.left - r.left - e.x,
                    y: i.top - r.top - e.y
                }
            }

            function Rt(t) {
                return Pt(t.x) || Pt(t.y)
            }

            function Ct(t) {
                return {
                    x: Pt(t.x) ? t.x : window.pageXOffset,
                    y: Pt(t.y) ? t.y : window.pageYOffset
                }
            }

            function Ot(t) {
                return {
                    x: Pt(t.x) ? t.x : 0,
                    y: Pt(t.y) ? t.y : 0
                }
            }

            function Pt(t) {
                return "number" === typeof t
            }
            var It = /^#\d/;

            function Nt(t, e) {
                var n = "object" === typeof t;
                if (n && "string" === typeof t.selector) {
                    var r = It.test(t.selector) ? document.getElementById(t.selector.slice(1)) : document.querySelector(t.selector);
                    if (r) {
                        var i = t.offset && "object" === typeof t.offset ? t.offset : {};
                        i = Ot(i), e = Lt(r, i)
                    } else Rt(t) && (e = Ct(t))
                } else n && Rt(t) && (e = Ct(t));
                e && window.scrollTo(e.x, e.y)
            }
            var Dt = lt && function() {
                var t = window.navigator.userAgent;
                return (-1 === t.indexOf("Android 2.") && -1 === t.indexOf("Android 4.0") || -1 === t.indexOf("Mobile Safari") || -1 !== t.indexOf("Chrome") || -1 !== t.indexOf("Windows Phone")) && (window.history && "function" === typeof window.history.pushState)
            }();

            function kt(t, e) {
                St();
                var n = window.history;
                try {
                    if (e) {
                        var r = a({}, n.state);
                        r.key = bt(), n.replaceState(r, "", t)
                    } else n.pushState({
                        key: xt(yt())
                    }, "", t)
                } catch (i) {
                    window.location[e ? "replace" : "assign"](t)
                }
            }

            function Ft(t) {
                kt(t, !0)
            }

            function Bt(t, e, n) {
                var r = function(i) {
                    i >= t.length ? n() : t[i] ? e(t[i], (function() {
                        r(i + 1)
                    })) : r(i + 1)
                };
                r(0)
            }

            function Ut(t) {
                return function(e, n, r) {
                    var o = !1,
                        a = 0,
                        s = null;
                    Ht(t, (function(t, e, n, c) {
                        if ("function" === typeof t && void 0 === t.cid) {
                            o = !0, a++;
                            var l, u = Vt((function(e) {
                                    Gt(e) && (e = e.default), t.resolved = "function" === typeof e ? e : et.extend(e), n.components[c] = e, a--, a <= 0 && r()
                                })),
                                h = Vt((function(t) {
                                    var e = "Failed to resolve async component " + c + ": " + t;
                                    s || (s = i(t) ? t : new Error(e), r(s))
                                }));
                            try {
                                l = t(u, h)
                            } catch (p) {
                                h(p)
                            }
                            if (l)
                                if ("function" === typeof l.then) l.then(u, h);
                                else {
                                    var d = l.component;
                                    d && "function" === typeof d.then && d.then(u, h)
                                }
                        }
                    })), o || r()
                }
            }

            function Ht(t, e) {
                return zt(t.map((function(t) {
                    return Object.keys(t.components).map((function(n) {
                        return e(t.components[n], t.instances[n], t, n)
                    }))
                })))
            }

            function zt(t) {
                return Array.prototype.concat.apply([], t)
            }
            var jt = "function" === typeof Symbol && "symbol" === typeof Symbol.toStringTag;

            function Gt(t) {
                return t.__esModule || jt && "Module" === t[Symbol.toStringTag]
            }

            function Vt(t) {
                var e = !1;
                return function() {
                    var n = [],
                        r = arguments.length;
                    while (r--) n[r] = arguments[r];
                    if (!e) return e = !0, t.apply(this, n)
                }
            }
            var Wt = {
                redirected: 1,
                aborted: 2,
                cancelled: 3,
                duplicated: 4
            };

            function Xt(t, e) {
                return Zt(t, e, Wt.redirected, 'Redirected when going from "' + t.fullPath + '" to "' + Kt(e) + '" via a navigation guard.')
            }

            function qt(t, e) {
                return Zt(t, e, Wt.duplicated, 'Avoided redundant navigation to current location: "' + t.fullPath + '".')
            }

            function Yt(t, e) {
                return Zt(t, e, Wt.cancelled, 'Navigation cancelled from "' + t.fullPath + '" to "' + e.fullPath + '" with a new navigation.')
            }

            function $t(t, e) {
                return Zt(t, e, Wt.aborted, 'Navigation aborted from "' + t.fullPath + '" to "' + e.fullPath + '" via a navigation guard.')
            }

            function Zt(t, e, n, r) {
                var i = new Error(r);
                return i._isRouter = !0, i.from = t, i.to = e, i.type = n, i
            }
            var Jt = ["params", "query", "hash"];

            function Kt(t) {
                if ("string" === typeof t) return t;
                if ("path" in t) return t.path;
                var e = {};
                return Jt.forEach((function(n) {
                    n in t && (e[n] = t[n])
                })), JSON.stringify(e, null, 2)
            }
            var Qt = function(t, e) {
                this.router = t, this.base = te(e), this.current = x, this.pending = null, this.ready = !1, this.readyCbs = [], this.readyErrorCbs = [], this.errorCbs = [], this.listeners = []
            };

            function te(t) {
                if (!t)
                    if (lt) {
                        var e = document.querySelector("base");
                        t = e && e.getAttribute("href") || "/", t = t.replace(/^https?:\/\/[^\/]+/, "")
                    } else t = "/";
                return "/" !== t.charAt(0) && (t = "/" + t), t.replace(/\/$/, "")
            }

            function ee(t, e) {
                var n, r = Math.max(t.length, e.length);
                for (n = 0; n < r; n++)
                    if (t[n] !== e[n]) break;
                return {
                    updated: e.slice(0, n),
                    activated: e.slice(n),
                    deactivated: t.slice(n)
                }
            }

            function ne(t, e, n, r) {
                var i = Ht(t, (function(t, r, i, o) {
                    var a = re(t, e);
                    if (a) return Array.isArray(a) ? a.map((function(t) {
                        return n(t, r, i, o)
                    })) : n(a, r, i, o)
                }));
                return zt(r ? i.reverse() : i)
            }

            function re(t, e) {
                return "function" !== typeof t && (t = et.extend(t)), t.options[e]
            }

            function ie(t) {
                return ne(t, "beforeRouteLeave", ae, !0)
            }

            function oe(t) {
                return ne(t, "beforeRouteUpdate", ae)
            }

            function ae(t, e) {
                if (e) return function() {
                    return t.apply(e, arguments)
                }
            }

            function se(t, e, n) {
                return ne(t, "beforeRouteEnter", (function(t, r, i, o) {
                    return ce(t, i, o, e, n)
                }))
            }

            function ce(t, e, n, r, i) {
                return function(o, a, s) {
                    return t(o, a, (function(t) {
                        "function" === typeof t && r.push((function() {
                            le(t, e.instances, n, i)
                        })), s(t)
                    }))
                }
            }

            function le(t, e, n, r) {
                e[n] && !e[n]._isBeingDestroyed ? t(e[n]) : r() && setTimeout((function() {
                    le(t, e, n, r)
                }), 16)
            }
            Qt.prototype.listen = function(t) {
                this.cb = t
            }, Qt.prototype.onReady = function(t, e) {
                this.ready ? t() : (this.readyCbs.push(t), e && this.readyErrorCbs.push(e))
            }, Qt.prototype.onError = function(t) {
                this.errorCbs.push(t)
            }, Qt.prototype.transitionTo = function(t, e, n) {
                var r = this,
                    i = this.router.match(t, this.current);
                this.confirmTransition(i, (function() {
                    var t = r.current;
                    r.updateRoute(i), e && e(i), r.ensureURL(), r.router.afterHooks.forEach((function(e) {
                        e && e(i, t)
                    })), r.ready || (r.ready = !0, r.readyCbs.forEach((function(t) {
                        t(i)
                    })))
                }), (function(t) {
                    n && n(t), t && !r.ready && (r.ready = !0, o(t, Wt.redirected) ? r.readyCbs.forEach((function(t) {
                        t(i)
                    })) : r.readyErrorCbs.forEach((function(e) {
                        e(t)
                    })))
                }))
            }, Qt.prototype.confirmTransition = function(t, e, n) {
                var a = this,
                    s = this.current,
                    c = function(t) {
                        !o(t) && i(t) && (a.errorCbs.length ? a.errorCbs.forEach((function(e) {
                            e(t)
                        })) : (r(!1, "uncaught error during route navigation:"), console.error(t))), n && n(t)
                    },
                    l = t.matched.length - 1,
                    u = s.matched.length - 1;
                if (T(t, s) && l === u && t.matched[l] === s.matched[u]) return this.ensureURL(), c(qt(s, t));
                var h = ee(this.current.matched, t.matched),
                    d = h.updated,
                    p = h.deactivated,
                    f = h.activated,
                    m = [].concat(ie(p), this.router.beforeHooks, oe(d), f.map((function(t) {
                        return t.beforeEnter
                    })), Ut(f));
                this.pending = t;
                var g = function(e, n) {
                    if (a.pending !== t) return c(Yt(s, t));
                    try {
                        e(t, s, (function(e) {
                            !1 === e ? (a.ensureURL(!0), c($t(s, t))) : i(e) ? (a.ensureURL(!0), c(e)) : "string" === typeof e || "object" === typeof e && ("string" === typeof e.path || "string" === typeof e.name) ? (c(Xt(s, t)), "object" === typeof e && e.replace ? a.replace(e) : a.push(e)) : n(e)
                        }))
                    } catch (r) {
                        c(r)
                    }
                };
                Bt(m, g, (function() {
                    var n = [],
                        r = function() {
                            return a.current === t
                        },
                        i = se(f, n, r),
                        o = i.concat(a.router.resolveHooks);
                    Bt(o, g, (function() {
                        if (a.pending !== t) return c(Yt(s, t));
                        a.pending = null, e(t), a.router.app && a.router.app.$nextTick((function() {
                            n.forEach((function(t) {
                                t()
                            }))
                        }))
                    }))
                }))
            }, Qt.prototype.updateRoute = function(t) {
                this.current = t, this.cb && this.cb(t)
            }, Qt.prototype.setupListeners = function() {}, Qt.prototype.teardownListeners = function() {
                this.listeners.forEach((function(t) {
                    t()
                })), this.listeners = []
            };
            var ue = function(t) {
                function e(e, n) {
                    t.call(this, e, n), this._startLocation = he(this.base)
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.setupListeners = function() {
                    var t = this;
                    if (!(this.listeners.length > 0)) {
                        var e = this.router,
                            n = e.options.scrollBehavior,
                            r = Dt && n;
                        r && this.listeners.push(Mt());
                        var i = function() {
                            var n = t.current,
                                i = he(t.base);
                            t.current === x && i === t._startLocation || t.transitionTo(i, (function(t) {
                                r && Tt(e, t, n, !0)
                            }))
                        };
                        window.addEventListener("popstate", i), this.listeners.push((function() {
                            window.removeEventListener("popstate", i)
                        }))
                    }
                }, e.prototype.go = function(t) {
                    window.history.go(t)
                }, e.prototype.push = function(t, e, n) {
                    var r = this,
                        i = this,
                        o = i.current;
                    this.transitionTo(t, (function(t) {
                        kt(C(r.base + t.fullPath)), Tt(r.router, t, o, !1), e && e(t)
                    }), n)
                }, e.prototype.replace = function(t, e, n) {
                    var r = this,
                        i = this,
                        o = i.current;
                    this.transitionTo(t, (function(t) {
                        Ft(C(r.base + t.fullPath)), Tt(r.router, t, o, !1), e && e(t)
                    }), n)
                }, e.prototype.ensureURL = function(t) {
                    if (he(this.base) !== this.current.fullPath) {
                        var e = C(this.base + this.current.fullPath);
                        t ? kt(e) : Ft(e)
                    }
                }, e.prototype.getCurrentLocation = function() {
                    return he(this.base)
                }, e
            }(Qt);

            function he(t) {
                var e = decodeURI(window.location.pathname);
                return t && 0 === e.toLowerCase().indexOf(t.toLowerCase()) && (e = e.slice(t.length)), (e || "/") + window.location.search + window.location.hash
            }
            var de = function(t) {
                function e(e, n, r) {
                    t.call(this, e, n), r && pe(this.base) || fe()
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.setupListeners = function() {
                    var t = this;
                    if (!(this.listeners.length > 0)) {
                        var e = this.router,
                            n = e.options.scrollBehavior,
                            r = Dt && n;
                        r && this.listeners.push(Mt());
                        var i = function() {
                                var e = t.current;
                                fe() && t.transitionTo(me(), (function(n) {
                                    r && Tt(t.router, n, e, !0), Dt || ye(n.fullPath)
                                }))
                            },
                            o = Dt ? "popstate" : "hashchange";
                        window.addEventListener(o, i), this.listeners.push((function() {
                            window.removeEventListener(o, i)
                        }))
                    }
                }, e.prototype.push = function(t, e, n) {
                    var r = this,
                        i = this,
                        o = i.current;
                    this.transitionTo(t, (function(t) {
                        ve(t.fullPath), Tt(r.router, t, o, !1), e && e(t)
                    }), n)
                }, e.prototype.replace = function(t, e, n) {
                    var r = this,
                        i = this,
                        o = i.current;
                    this.transitionTo(t, (function(t) {
                        ye(t.fullPath), Tt(r.router, t, o, !1), e && e(t)
                    }), n)
                }, e.prototype.go = function(t) {
                    window.history.go(t)
                }, e.prototype.ensureURL = function(t) {
                    var e = this.current.fullPath;
                    me() !== e && (t ? ve(e) : ye(e))
                }, e.prototype.getCurrentLocation = function() {
                    return me()
                }, e
            }(Qt);

            function pe(t) {
                var e = he(t);
                if (!/^\/#/.test(e)) return window.location.replace(C(t + "/#" + e)), !0
            }

            function fe() {
                var t = me();
                return "/" === t.charAt(0) || (ye("/" + t), !1)
            }

            function me() {
                var t = window.location.href,
                    e = t.indexOf("#");
                if (e < 0) return "";
                t = t.slice(e + 1);
                var n = t.indexOf("?");
                if (n < 0) {
                    var r = t.indexOf("#");
                    t = r > -1 ? decodeURI(t.slice(0, r)) + t.slice(r) : decodeURI(t)
                } else t = decodeURI(t.slice(0, n)) + t.slice(n);
                return t
            }

            function ge(t) {
                var e = window.location.href,
                    n = e.indexOf("#"),
                    r = n >= 0 ? e.slice(0, n) : e;
                return r + "#" + t
            }

            function ve(t) {
                Dt ? kt(ge(t)) : window.location.hash = t
            }

            function ye(t) {
                Dt ? Ft(ge(t)) : window.location.replace(ge(t))
            }
            var _e = function(t) {
                    function e(e, n) {
                        t.call(this, e, n), this.stack = [], this.index = -1
                    }
                    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.push = function(t, e, n) {
                        var r = this;
                        this.transitionTo(t, (function(t) {
                            r.stack = r.stack.slice(0, r.index + 1).concat(t), r.index++, e && e(t)
                        }), n)
                    }, e.prototype.replace = function(t, e, n) {
                        var r = this;
                        this.transitionTo(t, (function(t) {
                            r.stack = r.stack.slice(0, r.index).concat(t), e && e(t)
                        }), n)
                    }, e.prototype.go = function(t) {
                        var e = this,
                            n = this.index + t;
                        if (!(n < 0 || n >= this.stack.length)) {
                            var r = this.stack[n];
                            this.confirmTransition(r, (function() {
                                e.index = n, e.updateRoute(r)
                            }), (function(t) {
                                o(t, Wt.duplicated) && (e.index = n)
                            }))
                        }
                    }, e.prototype.getCurrentLocation = function() {
                        var t = this.stack[this.stack.length - 1];
                        return t ? t.fullPath : "/"
                    }, e.prototype.ensureURL = function() {}, e
                }(Qt),
                be = function(t) {
                    void 0 === t && (t = {}), this.app = null, this.apps = [], this.options = t, this.beforeHooks = [], this.resolveHooks = [], this.afterHooks = [], this.matcher = ft(t.routes || [], this);
                    var e = t.mode || "hash";
                    switch (this.fallback = "history" === e && !Dt && !1 !== t.fallback, this.fallback && (e = "hash"), lt || (e = "abstract"), this.mode = e, e) {
                        case "history":
                            this.history = new ue(this, t.base);
                            break;
                        case "hash":
                            this.history = new de(this, t.base, this.fallback);
                            break;
                        case "abstract":
                            this.history = new _e(this, t.base);
                            break;
                        default:
                            0
                    }
                },
                xe = {
                    currentRoute: {
                        configurable: !0
                    }
                };

            function we(t, e) {
                return t.push(e),
                    function() {
                        var n = t.indexOf(e);
                        n > -1 && t.splice(n, 1)
                    }
            }

            function Me(t, e, n) {
                var r = "hash" === n ? "#" + e : e;
                return t ? C(t + "/" + r) : r
            }
            be.prototype.match = function(t, e, n) {
                return this.matcher.match(t, e, n)
            }, xe.currentRoute.get = function() {
                return this.history && this.history.current
            }, be.prototype.init = function(t) {
                var e = this;
                if (this.apps.push(t), t.$once("hook:destroyed", (function() {
                        var n = e.apps.indexOf(t);
                        n > -1 && e.apps.splice(n, 1), e.app === t && (e.app = e.apps[0] || null), e.app || e.history.teardownListeners()
                    })), !this.app) {
                    this.app = t;
                    var n = this.history;
                    if (n instanceof ue || n instanceof de) {
                        var r = function() {
                            n.setupListeners()
                        };
                        n.transitionTo(n.getCurrentLocation(), r, r)
                    }
                    n.listen((function(t) {
                        e.apps.forEach((function(e) {
                            e._route = t
                        }))
                    }))
                }
            }, be.prototype.beforeEach = function(t) {
                return we(this.beforeHooks, t)
            }, be.prototype.beforeResolve = function(t) {
                return we(this.resolveHooks, t)
            }, be.prototype.afterEach = function(t) {
                return we(this.afterHooks, t)
            }, be.prototype.onReady = function(t, e) {
                this.history.onReady(t, e)
            }, be.prototype.onError = function(t) {
                this.history.onError(t)
            }, be.prototype.push = function(t, e, n) {
                var r = this;
                if (!e && !n && "undefined" !== typeof Promise) return new Promise((function(e, n) {
                    r.history.push(t, e, n)
                }));
                this.history.push(t, e, n)
            }, be.prototype.replace = function(t, e, n) {
                var r = this;
                if (!e && !n && "undefined" !== typeof Promise) return new Promise((function(e, n) {
                    r.history.replace(t, e, n)
                }));
                this.history.replace(t, e, n)
            }, be.prototype.go = function(t) {
                this.history.go(t)
            }, be.prototype.back = function() {
                this.go(-1)
            }, be.prototype.forward = function() {
                this.go(1)
            }, be.prototype.getMatchedComponents = function(t) {
                var e = t ? t.matched ? t : this.resolve(t).route : this.currentRoute;
                return e ? [].concat.apply([], e.matched.map((function(t) {
                    return Object.keys(t.components).map((function(e) {
                        return t.components[e]
                    }))
                }))) : []
            }, be.prototype.resolve = function(t, e, n) {
                e = e || this.history.current;
                var r = tt(t, e, n, this),
                    i = this.match(r, e),
                    o = i.redirectedFrom || i.fullPath,
                    a = this.history.base,
                    s = Me(a, o, this.mode);
                return {
                    location: r,
                    route: i,
                    href: s,
                    normalizedTo: r,
                    resolved: i
                }
            }, be.prototype.addRoutes = function(t) {
                this.matcher.addRoutes(t), this.history.current !== x && this.history.transitionTo(this.history.getCurrentLocation())
            }, Object.defineProperties(be.prototype, xe), be.install = ct, be.version = "3.3.4", lt && window.Vue && window.Vue.use(be), e["a"] = be
        },
        "8eb7": function(t, e) {
            var n, r, i, o, a, s, c, l, u, h, d, p, f, m, g, v = !1;

            function y() {
                if (!v) {
                    v = !0;
                    var t = navigator.userAgent,
                        e = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(t),
                        y = /(Mac OS X)|(Windows)|(Linux)/.exec(t);
                    if (p = /\b(iPhone|iP[ao]d)/.exec(t), f = /\b(iP[ao]d)/.exec(t), h = /Android/i.exec(t), m = /FBAN\/\w+;/i.exec(t), g = /Mobile/i.exec(t), d = !!/Win64/.exec(t), e) {
                        n = e[1] ? parseFloat(e[1]) : e[5] ? parseFloat(e[5]) : NaN, n && document && document.documentMode && (n = document.documentMode);
                        var _ = /(?:Trident\/(\d+.\d+))/.exec(t);
                        s = _ ? parseFloat(_[1]) + 4 : n, r = e[2] ? parseFloat(e[2]) : NaN, i = e[3] ? parseFloat(e[3]) : NaN, o = e[4] ? parseFloat(e[4]) : NaN, o ? (e = /(?:Chrome\/(\d+\.\d+))/.exec(t), a = e && e[1] ? parseFloat(e[1]) : NaN) : a = NaN
                    } else n = r = i = a = o = NaN;
                    if (y) {
                        if (y[1]) {
                            var b = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(t);
                            c = !b || parseFloat(b[1].replace("_", "."))
                        } else c = !1;
                        l = !!y[2], u = !!y[3]
                    } else c = l = u = !1
                }
            }
            var _ = {
                ie: function() {
                    return y() || n
                },
                ieCompatibilityMode: function() {
                    return y() || s > n
                },
                ie64: function() {
                    return _.ie() && d
                },
                firefox: function() {
                    return y() || r
                },
                opera: function() {
                    return y() || i
                },
                webkit: function() {
                    return y() || o
                },
                safari: function() {
                    return _.webkit()
                },
                chrome: function() {
                    return y() || a
                },
                windows: function() {
                    return y() || l
                },
                osx: function() {
                    return y() || c
                },
                linux: function() {
                    return y() || u
                },
                iphone: function() {
                    return y() || p
                },
                mobile: function() {
                    return y() || p || f || h || g
                },
                nativeApp: function() {
                    return y() || m
                },
                android: function() {
                    return y() || h
                },
                ipad: function() {
                    return y() || f
                }
            };
            t.exports = _
        },
        9037: function(t, e, n) {
            "use strict";
            n.d(e, "a", (function() {
                return i
            }));
            var r = n("5a89"),
                i = {
                    computeTangents: function(t) {
                        var e = t.index,
                            n = t.attributes;
                        if (null !== e && void 0 !== n.position && void 0 !== n.normal && void 0 !== n.uv) {
                            var i = e.array,
                                o = n.position.array,
                                a = n.normal.array,
                                s = n.uv.array,
                                c = o.length / 3;
                            void 0 === n.tangent && t.setAttribute("tangent", new r["e"](new Float32Array(4 * c), 4));
                            for (var l = n.tangent.array, u = [], h = [], d = 0; d < c; d++) u[d] = new r["Rb"], h[d] = new r["Rb"];
                            var p = new r["Rb"],
                                f = new r["Rb"],
                                m = new r["Rb"],
                                g = new r["Qb"],
                                v = new r["Qb"],
                                y = new r["Qb"],
                                _ = new r["Rb"],
                                b = new r["Rb"],
                                x = t.groups;
                            0 === x.length && (x = [{
                                start: 0,
                                count: i.length
                            }]);
                            d = 0;
                            for (var w = x.length; d < w; ++d)
                                for (var M = x[d], T = M.start, S = M.count, E = T, A = T + S; E < A; E += 3) D(i[E + 0], i[E + 1], i[E + 2]);
                            var L, R, C, O = new r["Rb"],
                                P = new r["Rb"],
                                I = new r["Rb"],
                                N = new r["Rb"];
                            for (d = 0, w = x.length; d < w; ++d)
                                for (M = x[d], T = M.start, S = M.count, E = T, A = T + S; E < A; E += 3) k(i[E + 0]), k(i[E + 1]), k(i[E + 2])
                        } else console.error("THREE.BufferGeometryUtils: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");

                        function D(t, e, n) {
                            p.fromArray(o, 3 * t), f.fromArray(o, 3 * e), m.fromArray(o, 3 * n), g.fromArray(s, 2 * t), v.fromArray(s, 2 * e), y.fromArray(s, 2 * n), f.sub(p), m.sub(p), v.sub(g), y.sub(g);
                            var r = 1 / (v.x * y.y - y.x * v.y);
                            isFinite(r) && (_.copy(f).multiplyScalar(y.y).addScaledVector(m, -v.y).multiplyScalar(r), b.copy(m).multiplyScalar(v.x).addScaledVector(f, -y.x).multiplyScalar(r), u[t].add(_), u[e].add(_), u[n].add(_), h[t].add(b), h[e].add(b), h[n].add(b))
                        }

                        function k(t) {
                            I.fromArray(a, 3 * t), N.copy(I), R = u[t], O.copy(R), O.sub(I.multiplyScalar(I.dot(R))).normalize(), P.crossVectors(N, R), C = P.dot(h[t]), L = C < 0 ? -1 : 1, l[4 * t] = O.x, l[4 * t + 1] = O.y, l[4 * t + 2] = O.z, l[4 * t + 3] = L
                        }
                    },
                    mergeBufferGeometries: function(t, e) {
                        for (var n = null !== t[0].index, i = new Set(Object.keys(t[0].attributes)), o = new Set(Object.keys(t[0].morphAttributes)), a = {}, s = {}, c = t[0].morphTargetsRelative, l = new r["f"], u = 0, h = 0; h < t.length; ++h) {
                            var d = t[h],
                                p = 0;
                            if (n !== (null !== d.index)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
                            for (var f in d.attributes) {
                                if (!i.has(f)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + '. All geometries must have compatible attributes; make sure "' + f + '" attribute exists among all geometries, or in none of them.'), null;
                                void 0 === a[f] && (a[f] = []), a[f].push(d.attributes[f]), p++
                            }
                            if (p !== i.size) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". Make sure all geometries have the same number of attributes."), null;
                            if (c !== d.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
                            for (var f in d.morphAttributes) {
                                if (!o.has(f)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ".  .morphAttributes must be consistent throughout all geometries."), null;
                                void 0 === s[f] && (s[f] = []), s[f].push(d.morphAttributes[f])
                            }
                            if (l.userData.mergedUserData = l.userData.mergedUserData || [], l.userData.mergedUserData.push(d.userData), e) {
                                var m;
                                if (n) m = d.index.count;
                                else {
                                    if (void 0 === d.attributes.position) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". The geometry must have either an index or a position attribute"), null;
                                    m = d.attributes.position.count
                                }
                                l.addGroup(u, m, h), u += m
                            }
                        }
                        if (n) {
                            var g = 0,
                                v = [];
                            for (h = 0; h < t.length; ++h) {
                                for (var y = t[h].index, _ = 0; _ < y.count; ++_) v.push(y.getX(_) + g);
                                g += t[h].attributes.position.count
                            }
                            l.setIndex(v)
                        }
                        for (var f in a) {
                            var b = this.mergeBufferAttributes(a[f]);
                            if (!b) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + f + " attribute."), null;
                            l.setAttribute(f, b)
                        }
                        for (var f in s) {
                            var x = s[f][0].length;
                            if (0 === x) break;
                            l.morphAttributes = l.morphAttributes || {}, l.morphAttributes[f] = [];
                            for (h = 0; h < x; ++h) {
                                var w = [];
                                for (_ = 0; _ < s[f].length; ++_) w.push(s[f][_][h]);
                                var M = this.mergeBufferAttributes(w);
                                if (!M) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + f + " morphAttribute."), null;
                                l.morphAttributes[f].push(M)
                            }
                        }
                        return l
                    },
                    mergeBufferAttributes: function(t) {
                        for (var e, n, i, o = 0, a = 0; a < t.length; ++a) {
                            var s = t[a];
                            if (s.isInterleavedBufferAttribute) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."), null;
                            if (void 0 === e && (e = s.array.constructor), e !== s.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
                            if (void 0 === n && (n = s.itemSize), n !== s.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
                            if (void 0 === i && (i = s.normalized), i !== s.normalized) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
                            o += s.array.length
                        }
                        var c = new e(o),
                            l = 0;
                        for (a = 0; a < t.length; ++a) c.set(t[a].array, l), l += t[a].array.length;
                        return new r["e"](c, n, i)
                    },
                    interleaveAttributes: function(t) {
                        for (var e, n = 0, i = 0, o = 0, a = t.length; o < a; ++o) {
                            var s = t[o];
                            if (void 0 === e && (e = s.array.constructor), e !== s.array.constructor) return console.error("AttributeBuffers of different types cannot be interleaved"), null;
                            n += s.array.length, i += s.itemSize
                        }
                        var c = new r["A"](new e(n), i),
                            l = 0,
                            u = [],
                            h = ["getX", "getY", "getZ", "getW"],
                            d = ["setX", "setY", "setZ", "setW"],
                            p = 0;
                        for (a = t.length; p < a; p++) {
                            s = t[p];
                            var f = s.itemSize,
                                m = s.count,
                                g = new r["B"](c, f, l, s.normalized);
                            u.push(g), l += f;
                            for (var v = 0; v < m; v++)
                                for (var y = 0; y < f; y++) g[d[y]](v, s[h[y]](v))
                        }
                        return u
                    },
                    estimateBytesUsed: function(t) {
                        var e = 0;
                        for (var n in t.attributes) {
                            var r = t.getAttribute(n);
                            e += r.count * r.itemSize * r.array.BYTES_PER_ELEMENT
                        }
                        var i = t.getIndex();
                        return e += i ? i.count * i.itemSize * i.array.BYTES_PER_ELEMENT : 0, e
                    },
                    mergeVertices: function(t, e = 1e-4) {
                        e = Math.max(e, Number.EPSILON);
                        for (var n = {}, i = t.getIndex(), o = t.getAttribute("position"), a = i ? i.count : o.count, s = 0, c = Object.keys(t.attributes), l = {}, u = {}, h = [], d = ["getX", "getY", "getZ", "getW"], p = 0, f = c.length; p < f; p++) {
                            var m = c[p];
                            l[m] = [];
                            var g = t.morphAttributes[m];
                            g && (u[m] = new Array(g.length).fill().map(() => []))
                        }
                        var v = Math.log10(1 / e),
                            y = Math.pow(10, v);
                        for (p = 0; p < a; p++) {
                            var _ = i ? i.getX(p) : p,
                                b = "",
                                x = 0;
                            for (f = c.length; x < f; x++) {
                                m = c[x];
                                for (var w = t.getAttribute(m), M = w.itemSize, T = 0; T < M; T++) b += ~~(w[d[T]](_) * y) + ","
                            }
                            if (b in n) h.push(n[b]);
                            else {
                                for (x = 0, f = c.length; x < f; x++) {
                                    m = c[x], w = t.getAttribute(m), g = t.morphAttributes[m], M = w.itemSize;
                                    var S = l[m],
                                        E = u[m];
                                    for (T = 0; T < M; T++) {
                                        var A = d[T];
                                        if (S.push(w[A](_)), g)
                                            for (var L = 0, R = g.length; L < R; L++) E[L].push(g[L][A](_))
                                    }
                                }
                                n[b] = s, h.push(s), s++
                            }
                        }
                        const C = t.clone();
                        for (p = 0, f = c.length; p < f; p++) {
                            m = c[p];
                            var O = t.getAttribute(m),
                                P = new O.array.constructor(l[m]);
                            w = new r["e"](P, O.itemSize, O.normalized);
                            if (C.setAttribute(m, w), m in u)
                                for (x = 0; x < u[m].length; x++) {
                                    var I = t.morphAttributes[m][x],
                                        N = (P = new I.array.constructor(u[m][x]), new r["e"](P, I.itemSize, I.normalized));
                                    C.morphAttributes[m][x] = N
                                }
                        }
                        return C.setIndex(h), C
                    },
                    toTrianglesDrawMode: function(t, e) {
                        if (e === r["Mb"]) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), t;
                        if (e === r["Kb"] || e === r["Lb"]) {
                            var n = t.getIndex();
                            if (null === n) {
                                var i = [],
                                    o = t.getAttribute("position");
                                if (void 0 === o) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t;
                                for (var a = 0; a < o.count; a++) i.push(a);
                                t.setIndex(i), n = t.getIndex()
                            }
                            var s = n.count - 2,
                                c = [];
                            if (e === r["Kb"])
                                for (a = 1; a <= s; a++) c.push(n.getX(0)), c.push(n.getX(a)), c.push(n.getX(a + 1));
                            else
                                for (a = 0; a < s; a++) a % 2 === 0 ? (c.push(n.getX(a)), c.push(n.getX(a + 1)), c.push(n.getX(a + 2))) : (c.push(n.getX(a + 2)), c.push(n.getX(a + 1)), c.push(n.getX(a)));
                            c.length / 3 !== s && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                            var l = t.clone();
                            return l.setIndex(c), l.clearGroups(), l
                        }
                        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), t
                    }
                }
        },
        "90e3": function(t, e) {
            var n = 0,
                r = Math.random();
            t.exports = function(t) {
                return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++n + r).toString(36)
            }
        },
        9112: function(t, e, n) {
            var r = n("83ab"),
                i = n("9bf2"),
                o = n("5c6c");
            t.exports = r ? function(t, e, n) {
                return i.f(t, e, o(1, n))
            } : function(t, e, n) {
                return t[e] = n, t
            }
        },
        9263: function(t, e, n) {
            "use strict";
            var r = n("ad6d"),
                i = n("9f7f"),
                o = RegExp.prototype.exec,
                a = String.prototype.replace,
                s = o,
                c = function() {
                    var t = /a/,
                        e = /b*/g;
                    return o.call(t, "a"), o.call(e, "a"), 0 !== t.lastIndex || 0 !== e.lastIndex
                }(),
                l = i.UNSUPPORTED_Y || i.BROKEN_CARET,
                u = void 0 !== /()??/.exec("")[1],
                h = c || u || l;
            h && (s = function(t) {
                var e, n, i, s, h = this,
                    d = l && h.sticky,
                    p = r.call(h),
                    f = h.source,
                    m = 0,
                    g = t;
                return d && (p = p.replace("y", ""), -1 === p.indexOf("g") && (p += "g"), g = String(t).slice(h.lastIndex), h.lastIndex > 0 && (!h.multiline || h.multiline && "\n" !== t[h.lastIndex - 1]) && (f = "(?: " + f + ")", g = " " + g, m++), n = new RegExp("^(?:" + f + ")", p)), u && (n = new RegExp("^" + f + "$(?!\\s)", p)), c && (e = h.lastIndex), i = o.call(d ? n : h, g), d ? i ? (i.input = i.input.slice(m), i[0] = i[0].slice(m), i.index = h.lastIndex, h.lastIndex += i[0].length) : h.lastIndex = 0 : c && i && (h.lastIndex = h.global ? i.index + i[0].length : e), u && i && i.length > 1 && a.call(i[0], n, (function() {
                    for (s = 1; s < arguments.length - 2; s++) void 0 === arguments[s] && (i[s] = void 0)
                })), i
            }), t.exports = s
        },
        "93e9": function(t, e, n) {
            "use strict";
            n.d(e, "a", (function() {
                return i
            }));
            var r = n("1b53"),
                i = function(t, e, n, i, o) {
                    r["a"].call(this), this.scene = t, this.camera = e, this.overrideMaterial = n, this.clearColor = i, this.clearAlpha = void 0 !== o ? o : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1
                };
            i.prototype = Object.assign(Object.create(r["a"].prototype), {
                constructor: i,
                render: function(t, e, n) {
                    var r, i, o, a = t.autoClear;
                    t.autoClear = !1, void 0 !== this.overrideMaterial && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (r = t.getClearColor().getHex(), i = t.getClearAlpha(), t.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : n), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor && t.setClearColor(r, i), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = o), t.autoClear = a
                }
            })
        },
        "94ca": function(t, e, n) {
            var r = n("d039"),
                i = /#|\.prototype\./,
                o = function(t, e) {
                    var n = s[a(t)];
                    return n == l || n != c && ("function" == typeof e ? r(e) : !!e)
                },
                a = o.normalize = function(t) {
                    return String(t).replace(i, ".").toLowerCase()
                },
                s = o.data = {},
                c = o.NATIVE = "N",
                l = o.POLYFILL = "P";
            t.exports = o
        },
        "99af": function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("d039"),
                o = n("e8b5"),
                a = n("861d"),
                s = n("7b0b"),
                c = n("50c4"),
                l = n("8418"),
                u = n("65f0"),
                h = n("1dde"),
                d = n("b622"),
                p = n("2d00"),
                f = d("isConcatSpreadable"),
                m = 9007199254740991,
                g = "Maximum allowed index exceeded",
                v = p >= 51 || !i((function() {
                    var t = [];
                    return t[f] = !1, t.concat()[0] !== t
                })),
                y = h("concat"),
                _ = function(t) {
                    if (!a(t)) return !1;
                    var e = t[f];
                    return void 0 !== e ? !!e : o(t)
                },
                b = !v || !y;
            r({
                target: "Array",
                proto: !0,
                forced: b
            }, {
                concat: function(t) {
                    var e, n, r, i, o, a = s(this),
                        h = u(a, 0),
                        d = 0;
                    for (e = -1, r = arguments.length; e < r; e++)
                        if (o = -1 === e ? a : arguments[e], _(o)) {
                            if (i = c(o.length), d + i > m) throw TypeError(g);
                            for (n = 0; n < i; n++, d++) n in o && l(h, d, o[n])
                        } else {
                            if (d >= m) throw TypeError(g);
                            l(h, d++, o)
                        }
                    return h.length = d, h
                }
            })
        },
        "9a8c": function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("145e"),
                o = r.aTypedArray,
                a = r.exportTypedArrayMethod;
            a("copyWithin", (function(t, e) {
                return i.call(o(this), t, e, arguments.length > 2 ? arguments[2] : void 0)
            }))
        },
        "9bdd": function(t, e, n) {
            var r = n("825a");
            t.exports = function(t, e, n, i) {
                try {
                    return i ? e(r(n)[0], n[1]) : e(n)
                } catch (a) {
                    var o = t["return"];
                    throw void 0 !== o && r(o.call(t)), a
                }
            }
        },
        "9bf2": function(t, e, n) {
            var r = n("83ab"),
                i = n("0cfb"),
                o = n("825a"),
                a = n("c04e"),
                s = Object.defineProperty;
            e.f = r ? s : function(t, e, n) {
                if (o(t), e = a(e, !0), o(n), i) try {
                    return s(t, e, n)
                } catch (r) {}
                if ("get" in n || "set" in n) throw TypeError("Accessors not supported");
                return "value" in n && (t[e] = n.value), t
            }
        },
        "9ed3": function(t, e, n) {
            "use strict";
            var r = n("ae93").IteratorPrototype,
                i = n("7c73"),
                o = n("5c6c"),
                a = n("d44e"),
                s = n("3f8c"),
                c = function() {
                    return this
                };
            t.exports = function(t, e, n) {
                var l = e + " Iterator";
                return t.prototype = i(r, {
                    next: o(1, n)
                }), a(t, l, !1, !0), s[l] = c, t
            }
        },
        "9f7f": function(t, e, n) {
            "use strict";
            var r = n("d039");

            function i(t, e) {
                return RegExp(t, e)
            }
            e.UNSUPPORTED_Y = r((function() {
                var t = i("a", "y");
                return t.lastIndex = 2, null != t.exec("abcd")
            })), e.BROKEN_CARET = r((function() {
                var t = i("^r", "gy");
                return t.lastIndex = 2, null != t.exec("str")
            }))
        },
        a078: function(t, e, n) {
            var r = n("7b0b"),
                i = n("50c4"),
                o = n("35a1"),
                a = n("e95a"),
                s = n("0366"),
                c = n("ebb5").aTypedArrayConstructor;
            t.exports = function(t) {
                var e, n, l, u, h, d, p = r(t),
                    f = arguments.length,
                    m = f > 1 ? arguments[1] : void 0,
                    g = void 0 !== m,
                    v = o(p);
                if (void 0 != v && !a(v)) {
                    h = v.call(p), d = h.next, p = [];
                    while (!(u = d.call(h)).done) p.push(u.value)
                }
                for (g && f > 2 && (m = s(m, arguments[2], 2)), n = i(p.length), l = new(c(this))(n), e = 0; n > e; e++) l[e] = g ? m(p[e], e) : p[e];
                return l
            }
        },
        a15b: function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("44ad"),
                o = n("fc6a"),
                a = n("a640"),
                s = [].join,
                c = i != Object,
                l = a("join", ",");
            r({
                target: "Array",
                proto: !0,
                forced: c || !l
            }, {
                join: function(t) {
                    return s.call(o(this), void 0 === t ? "," : t)
                }
            })
        },
        a3de: function(t, e, n) {
            "use strict";
            var r = !("undefined" === typeof window || !window.document || !window.document.createElement),
                i = {
                    canUseDOM: r,
                    canUseWorkers: "undefined" !== typeof Worker,
                    canUseEventListeners: r && !(!window.addEventListener && !window.attachEvent),
                    canUseViewport: r && !!window.screen,
                    isInWorker: !r
                };
            t.exports = i
        },
        a434: function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("23cb"),
                o = n("a691"),
                a = n("50c4"),
                s = n("7b0b"),
                c = n("65f0"),
                l = n("8418"),
                u = n("1dde"),
                h = n("ae40"),
                d = u("splice"),
                p = h("splice", {
                    ACCESSORS: !0,
                    0: 0,
                    1: 2
                }),
                f = Math.max,
                m = Math.min,
                g = 9007199254740991,
                v = "Maximum allowed length exceeded";
            r({
                target: "Array",
                proto: !0,
                forced: !d || !p
            }, {
                splice: function(t, e) {
                    var n, r, u, h, d, p, y = s(this),
                        _ = a(y.length),
                        b = i(t, _),
                        x = arguments.length;
                    if (0 === x ? n = r = 0 : 1 === x ? (n = 0, r = _ - b) : (n = x - 2, r = m(f(o(e), 0), _ - b)), _ + n - r > g) throw TypeError(v);
                    for (u = c(y, r), h = 0; h < r; h++) d = b + h, d in y && l(u, h, y[d]);
                    if (u.length = r, n < r) {
                        for (h = b; h < _ - r; h++) d = h + r, p = h + n, d in y ? y[p] = y[d] : delete y[p];
                        for (h = _; h > _ - r + n; h--) delete y[h - 1]
                    } else if (n > r)
                        for (h = _ - r; h > b; h--) d = h + r - 1, p = h + n - 1, d in y ? y[p] = y[d] : delete y[p];
                    for (h = 0; h < n; h++) y[h + b] = arguments[h + 2];
                    return y.length = _ - r + n, u
                }
            })
        },
        a4d3: function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("da84"),
                o = n("d066"),
                a = n("c430"),
                s = n("83ab"),
                c = n("4930"),
                l = n("fdbf"),
                u = n("d039"),
                h = n("5135"),
                d = n("e8b5"),
                p = n("861d"),
                f = n("825a"),
                m = n("7b0b"),
                g = n("fc6a"),
                v = n("c04e"),
                y = n("5c6c"),
                _ = n("7c73"),
                b = n("df75"),
                x = n("241c"),
                w = n("057f"),
                M = n("7418"),
                T = n("06cf"),
                S = n("9bf2"),
                E = n("d1e7"),
                A = n("9112"),
                L = n("6eeb"),
                R = n("5692"),
                C = n("f772"),
                O = n("d012"),
                P = n("90e3"),
                I = n("b622"),
                N = n("e538"),
                D = n("746f"),
                k = n("d44e"),
                F = n("69f3"),
                B = n("b727").forEach,
                U = C("hidden"),
                H = "Symbol",
                z = "prototype",
                j = I("toPrimitive"),
                G = F.set,
                V = F.getterFor(H),
                W = Object[z],
                X = i.Symbol,
                q = o("JSON", "stringify"),
                Y = T.f,
                $ = S.f,
                Z = w.f,
                J = E.f,
                K = R("symbols"),
                Q = R("op-symbols"),
                tt = R("string-to-symbol-registry"),
                et = R("symbol-to-string-registry"),
                nt = R("wks"),
                rt = i.QObject,
                it = !rt || !rt[z] || !rt[z].findChild,
                ot = s && u((function() {
                    return 7 != _($({}, "a", {
                        get: function() {
                            return $(this, "a", {
                                value: 7
                            }).a
                        }
                    })).a
                })) ? function(t, e, n) {
                    var r = Y(W, e);
                    r && delete W[e], $(t, e, n), r && t !== W && $(W, e, r)
                } : $,
                at = function(t, e) {
                    var n = K[t] = _(X[z]);
                    return G(n, {
                        type: H,
                        tag: t,
                        description: e
                    }), s || (n.description = e), n
                },
                st = l ? function(t) {
                    return "symbol" == typeof t
                } : function(t) {
                    return Object(t) instanceof X
                },
                ct = function(t, e, n) {
                    t === W && ct(Q, e, n), f(t);
                    var r = v(e, !0);
                    return f(n), h(K, r) ? (n.enumerable ? (h(t, U) && t[U][r] && (t[U][r] = !1), n = _(n, {
                        enumerable: y(0, !1)
                    })) : (h(t, U) || $(t, U, y(1, {})), t[U][r] = !0), ot(t, r, n)) : $(t, r, n)
                },
                lt = function(t, e) {
                    f(t);
                    var n = g(e),
                        r = b(n).concat(ft(n));
                    return B(r, (function(e) {
                        s && !ht.call(n, e) || ct(t, e, n[e])
                    })), t
                },
                ut = function(t, e) {
                    return void 0 === e ? _(t) : lt(_(t), e)
                },
                ht = function(t) {
                    var e = v(t, !0),
                        n = J.call(this, e);
                    return !(this === W && h(K, e) && !h(Q, e)) && (!(n || !h(this, e) || !h(K, e) || h(this, U) && this[U][e]) || n)
                },
                dt = function(t, e) {
                    var n = g(t),
                        r = v(e, !0);
                    if (n !== W || !h(K, r) || h(Q, r)) {
                        var i = Y(n, r);
                        return !i || !h(K, r) || h(n, U) && n[U][r] || (i.enumerable = !0), i
                    }
                },
                pt = function(t) {
                    var e = Z(g(t)),
                        n = [];
                    return B(e, (function(t) {
                        h(K, t) || h(O, t) || n.push(t)
                    })), n
                },
                ft = function(t) {
                    var e = t === W,
                        n = Z(e ? Q : g(t)),
                        r = [];
                    return B(n, (function(t) {
                        !h(K, t) || e && !h(W, t) || r.push(K[t])
                    })), r
                };
            if (c || (X = function() {
                    if (this instanceof X) throw TypeError("Symbol is not a constructor");
                    var t = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0,
                        e = P(t),
                        n = function(t) {
                            this === W && n.call(Q, t), h(this, U) && h(this[U], e) && (this[U][e] = !1), ot(this, e, y(1, t))
                        };
                    return s && it && ot(W, e, {
                        configurable: !0,
                        set: n
                    }), at(e, t)
                }, L(X[z], "toString", (function() {
                    return V(this).tag
                })), L(X, "withoutSetter", (function(t) {
                    return at(P(t), t)
                })), E.f = ht, S.f = ct, T.f = dt, x.f = w.f = pt, M.f = ft, N.f = function(t) {
                    return at(I(t), t)
                }, s && ($(X[z], "description", {
                    configurable: !0,
                    get: function() {
                        return V(this).description
                    }
                }), a || L(W, "propertyIsEnumerable", ht, {
                    unsafe: !0
                }))), r({
                    global: !0,
                    wrap: !0,
                    forced: !c,
                    sham: !c
                }, {
                    Symbol: X
                }), B(b(nt), (function(t) {
                    D(t)
                })), r({
                    target: H,
                    stat: !0,
                    forced: !c
                }, {
                    for: function(t) {
                        var e = String(t);
                        if (h(tt, e)) return tt[e];
                        var n = X(e);
                        return tt[e] = n, et[n] = e, n
                    },
                    keyFor: function(t) {
                        if (!st(t)) throw TypeError(t + " is not a symbol");
                        if (h(et, t)) return et[t]
                    },
                    useSetter: function() {
                        it = !0
                    },
                    useSimple: function() {
                        it = !1
                    }
                }), r({
                    target: "Object",
                    stat: !0,
                    forced: !c,
                    sham: !s
                }, {
                    create: ut,
                    defineProperty: ct,
                    defineProperties: lt,
                    getOwnPropertyDescriptor: dt
                }), r({
                    target: "Object",
                    stat: !0,
                    forced: !c
                }, {
                    getOwnPropertyNames: pt,
                    getOwnPropertySymbols: ft
                }), r({
                    target: "Object",
                    stat: !0,
                    forced: u((function() {
                        M.f(1)
                    }))
                }, {
                    getOwnPropertySymbols: function(t) {
                        return M.f(m(t))
                    }
                }), q) {
                var mt = !c || u((function() {
                    var t = X();
                    return "[null]" != q([t]) || "{}" != q({
                        a: t
                    }) || "{}" != q(Object(t))
                }));
                r({
                    target: "JSON",
                    stat: !0,
                    forced: mt
                }, {
                    stringify: function(t, e, n) {
                        var r, i = [t],
                            o = 1;
                        while (arguments.length > o) i.push(arguments[o++]);
                        if (r = e, (p(e) || void 0 !== t) && !st(t)) return d(e) || (e = function(t, e) {
                            if ("function" == typeof r && (e = r.call(this, t, e)), !st(e)) return e
                        }), i[1] = e, q.apply(null, i)
                    }
                })
            }
            X[z][j] || A(X[z], j, X[z].valueOf), k(X, H), O[U] = !0
        },
        a5cf: function(t, e, n) {
            "use strict";

            function r(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }

            function i(t, e) {
                t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
            }
            /*!
             * GSAP 3.5.1
             * https://greensock.com
             *
             * @license Copyright 2008-2020, GreenSock. All rights reserved.
             * Subject to the terms at https://greensock.com/standard-license or for
             * Club GreenSock members, the agreement issued with that membership.
             * @author: Jack Doyle, jack@greensock.com
             */
            n.d(e, "a", (function() {
                return De
            })), n.d(e, "c", (function() {
                return ln
            })), n.d(e, "y", (function() {
                return fn
            })), n.d(e, "b", (function() {
                return mn
            })), n.d(e, "w", (function() {
                return fn
            })), n.d(e, "x", (function() {
                return zt
            })), n.d(e, "i", (function() {
                return nt
            })), n.d(e, "n", (function() {
                return N
            })), n.d(e, "o", (function() {
                return D
            })), n.d(e, "k", (function() {
                return M
            })), n.d(e, "l", (function() {
                return E
            })), n.d(e, "r", (function() {
                return nn
            })), n.d(e, "q", (function() {
                return F
            })), n.d(e, "g", (function() {
                return rt
            })), n.d(e, "u", (function() {
                return cn
            })), n.d(e, "e", (function() {
                return _e
            })), n.d(e, "s", (function() {
                return ie
            })), n.d(e, "d", (function() {
                return je
            })), n.d(e, "p", (function() {
                return $
            })), n.d(e, "v", (function() {
                return be
            })), n.d(e, "f", (function() {
                return p
            })), n.d(e, "t", (function() {
                return it
            })), n.d(e, "m", (function() {
                return j
            })), n.d(e, "j", (function() {
                return Qe
            })), n.d(e, "h", (function() {
                return et
            }));
            var o, a, s, c, l, u, h, d, p = {
                    autoSleep: 120,
                    force3D: "auto",
                    nullTargetWarn: 1,
                    units: {
                        lineHeight: ""
                    }
                },
                f = {
                    duration: .5,
                    overwrite: !1,
                    delay: 0
                },
                m = 1e8,
                g = 1 / m,
                v = 2 * Math.PI,
                y = v / 4,
                _ = 0,
                b = Math.sqrt,
                x = Math.cos,
                w = Math.sin,
                M = function(t) {
                    return "string" === typeof t
                },
                T = function(t) {
                    return "function" === typeof t
                },
                S = function(t) {
                    return "number" === typeof t
                },
                E = function(t) {
                    return "undefined" === typeof t
                },
                A = function(t) {
                    return "object" === typeof t
                },
                L = function(t) {
                    return !1 !== t
                },
                R = function() {
                    return "undefined" !== typeof window
                },
                C = function(t) {
                    return T(t) || M(t)
                },
                O = "function" === typeof ArrayBuffer && ArrayBuffer.isView || function() {},
                P = Array.isArray,
                I = /(?:-?\.?\d|\.)+/gi,
                N = /[-+=.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g,
                D = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
                k = /[-+=.]*\d+(?:\.|e-|e)*\d*/gi,
                F = /[+-]=-?[\.\d]+/,
                B = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
                U = {},
                H = {},
                z = function(t) {
                    return (H = pt(t, U)) && fn
                },
                j = function(t, e) {
                    return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
                },
                G = function(t, e) {
                    return !e && console.warn(t)
                },
                V = function(t, e) {
                    return t && (U[t] = e) && H && (H[t] = e) || U
                },
                W = function() {
                    return 0
                },
                X = {},
                q = [],
                Y = {},
                $ = {},
                Z = {},
                J = 30,
                K = [],
                Q = "",
                tt = function(t) {
                    var e, n, r = t[0];
                    if (A(r) || T(r) || (t = [t]), !(e = (r._gsap || {}).harness)) {
                        n = K.length;
                        while (n-- && !K[n].targetTest(r));
                        e = K[n]
                    }
                    n = t.length;
                    while (n--) t[n] && (t[n]._gsap || (t[n]._gsap = new De(t[n], e))) || t.splice(n, 1);
                    return t
                },
                et = function(t) {
                    return t._gsap || tt(Xt(t))[0]._gsap
                },
                nt = function(t, e, n) {
                    return (n = t[e]) && T(n) ? t[e]() : E(n) && t.getAttribute && t.getAttribute(e) || n
                },
                rt = function(t, e) {
                    return (t = t.split(",")).forEach(e) || t
                },
                it = function(t) {
                    return Math.round(1e5 * t) / 1e5 || 0
                },
                ot = function(t, e) {
                    for (var n = e.length, r = 0; t.indexOf(e[r]) < 0 && ++r < n;);
                    return r < n
                },
                at = function(t, e, n) {
                    var r, i = S(t[1]),
                        o = (i ? 2 : 1) + (e < 2 ? 0 : 1),
                        a = t[o];
                    if (i && (a.duration = t[1]), a.parent = n, e) {
                        r = a;
                        while (n && !("immediateRender" in r)) r = n.vars.defaults || {}, n = L(n.vars.inherit) && n.parent;
                        a.immediateRender = L(r.immediateRender), e < 2 ? a.runBackwards = 1 : a.startAt = t[o - 1]
                    }
                    return a
                },
                st = function() {
                    var t, e, n = q.length,
                        r = q.slice(0);
                    for (Y = {}, q.length = 0, t = 0; t < n; t++) e = r[t], e && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
                },
                ct = function(t, e, n, r) {
                    q.length && st(), t.render(e, n, r), q.length && st()
                },
                lt = function(t) {
                    var e = parseFloat(t);
                    return (e || 0 === e) && (t + "").match(B).length < 2 ? e : M(t) ? t.trim() : t
                },
                ut = function(t) {
                    return t
                },
                ht = function(t, e) {
                    for (var n in e) n in t || (t[n] = e[n]);
                    return t
                },
                dt = function(t, e) {
                    for (var n in e) n in t || "duration" === n || "ease" === n || (t[n] = e[n])
                },
                pt = function(t, e) {
                    for (var n in e) t[n] = e[n];
                    return t
                },
                ft = function t(e, n) {
                    for (var r in n) e[r] = A(n[r]) ? t(e[r] || (e[r] = {}), n[r]) : n[r];
                    return e
                },
                mt = function(t, e) {
                    var n, r = {};
                    for (n in t) n in e || (r[n] = t[n]);
                    return r
                },
                gt = function(t) {
                    var e = t.parent || o,
                        n = t.keyframes ? dt : ht;
                    if (L(t.inherit))
                        while (e) n(t, e.vars.defaults), e = e.parent || e._dp;
                    return t
                },
                vt = function(t, e) {
                    var n = t.length,
                        r = n === e.length;
                    while (r && n-- && t[n] === e[n]);
                    return n < 0
                },
                yt = function(t, e, n, r, i) {
                    void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
                    var o, a = t[r];
                    if (i) {
                        o = e[i];
                        while (a && a[i] > o) a = a._prev
                    }
                    return a ? (e._next = a._next, a._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[r] = e, e._prev = a, e.parent = e._dp = t, e
                },
                _t = function(t, e, n, r) {
                    void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
                    var i = e._prev,
                        o = e._next;
                    i ? i._next = o : t[n] === e && (t[n] = o), o ? o._prev = i : t[r] === e && (t[r] = i), e._next = e._prev = e.parent = null
                },
                bt = function(t, e) {
                    t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t), t._act = 0
                },
                xt = function(t, e) {
                    if (t && (!e || e._end > t._dur || e._start < 0)) {
                        var n = t;
                        while (n) n._dirty = 1, n = n.parent
                    }
                    return t
                },
                wt = function(t) {
                    var e = t.parent;
                    while (e && e.parent) e._dirty = 1, e.totalDuration(), e = e.parent;
                    return t
                },
                Mt = function t(e) {
                    return !e || e._ts && t(e.parent)
                },
                Tt = function(t) {
                    return t._repeat ? St(t._tTime, t = t.duration() + t._rDelay) * t : 0
                },
                St = function(t, e) {
                    return (t /= e) && ~~t === t ? ~~t - 1 : ~~t
                },
                Et = function(t, e) {
                    return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
                },
                At = function(t) {
                    return t._end = it(t._start + (t._tDur / Math.abs(t._ts || t._rts || g) || 0))
                },
                Lt = function(t, e) {
                    var n = t._dp;
                    return n && n.smoothChildTiming && t._ts && (t._start = it(t._dp._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), At(t), n._dirty || xt(n, t)), t
                },
                Rt = function(t, e) {
                    var n;
                    if ((e._time || e._initted && !e._dur) && (n = Et(t.rawTime(), e), (!e._dur || Ht(0, e.totalDuration(), n) - e._tTime > g) && e.render(n, !0)), xt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                        if (t._dur < t.duration()) {
                            n = t;
                            while (n._dp) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp
                        }
                        t._zTime = -g
                    }
                },
                Ct = function(t, e, n, r) {
                    return e.parent && bt(e), e._start = it(n + e._delay), e._end = it(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), yt(t, e, "_first", "_last", t._sort ? "_start" : 0), t._recent = e, r || Rt(t, e), t
                },
                Ot = function(t, e) {
                    return (U.ScrollTrigger || j("scrollTrigger", e)) && U.ScrollTrigger.create(e, t)
                },
                Pt = function(t, e, n, r) {
                    return Ge(t, e), t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && u !== be.frame ? (q.push(t), t._lazy = [e, r], 1) : void 0 : 1
                },
                It = function(t, e, n, r) {
                    var i, o, a, s = t.ratio,
                        c = e < 0 || !e && s && !t._start && t._zTime > g && !t._dp._lock || (t._ts < 0 || t._dp._ts < 0) && "isFromStart" !== t.data && "isStart" !== t.data ? 0 : 1,
                        l = t._rDelay,
                        u = 0;
                    if (l && t._repeat && (u = Ht(0, t._tDur, e), o = St(u, l), a = St(t._tTime, l), o !== a && (s = 1 - c, t.vars.repeatRefresh && t._initted && t.invalidate())), c !== s || r || t._zTime === g || !e && t._zTime) {
                        if (!t._initted && Pt(t, e, r, n)) return;
                        a = t._zTime, t._zTime = e || (n ? g : 0), n || (n = e && !a), t.ratio = c, t._from && (c = 1 - c), t._time = 0, t._tTime = u, n || ce(t, "onStart"), i = t._pt;
                        while (i) i.r(c, i.d), i = i._next;
                        t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !n && ce(t, "onUpdate"), u && t._repeat && !n && t.parent && ce(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === c && (c && bt(t, 1), n || (ce(t, c ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                    } else t._zTime || (t._zTime = e)
                },
                Nt = function(t, e, n) {
                    var r;
                    if (n > e) {
                        r = t._first;
                        while (r && r._start <= n) {
                            if (!r._dur && "isPause" === r.data && r._start > e) return r;
                            r = r._next
                        }
                    } else {
                        r = t._last;
                        while (r && r._start >= n) {
                            if (!r._dur && "isPause" === r.data && r._start < e) return r;
                            r = r._prev
                        }
                    }
                },
                Dt = function(t, e, n, r) {
                    var i = t._repeat,
                        o = it(e) || 0,
                        a = t._tTime / t._tDur;
                    return a && !r && (t._time *= o / t._dur), t._dur = o, t._tDur = i ? i < 0 ? 1e10 : it(o * (i + 1) + t._rDelay * i) : o, a && !r ? Lt(t, t._tTime = t._tDur * a) : t.parent && At(t), n || xt(t.parent, t), t
                },
                kt = function(t) {
                    return t instanceof Fe ? xt(t) : Dt(t, t._dur)
                },
                Ft = {
                    _start: 0,
                    endTime: W
                },
                Bt = function t(e, n) {
                    var r, i, o = e.labels,
                        a = e._recent || Ft,
                        s = e.duration() >= m ? a.endTime(!1) : e._dur;
                    return M(n) && (isNaN(n) || n in o) ? (r = n.charAt(0), "<" === r || ">" === r ? ("<" === r ? a._start : a.endTime(a._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) : (r = n.indexOf("="), r < 0 ? (n in o || (o[n] = s), o[n]) : (i = +(n.charAt(r - 1) + n.substr(r + 1)), r > 1 ? t(e, n.substr(0, r - 1)) + i : s + i))) : null == n ? s : +n
                },
                Ut = function(t, e) {
                    return t || 0 === t ? e(t) : e
                },
                Ht = function(t, e, n) {
                    return n < t ? t : n > e ? e : n
                },
                zt = function(t) {
                    return (t = (t + "").substr((parseFloat(t) + "").length)) && isNaN(t) ? t : ""
                },
                jt = function(t, e, n) {
                    return Ut(n, (function(n) {
                        return Ht(t, e, n)
                    }))
                },
                Gt = [].slice,
                Vt = function(t, e) {
                    return t && A(t) && "length" in t && (!e && !t.length || t.length - 1 in t && A(t[0])) && !t.nodeType && t !== a
                },
                Wt = function(t, e, n) {
                    return void 0 === n && (n = []), t.forEach((function(t) {
                        var r;
                        return M(t) && !e || Vt(t, 1) ? (r = n).push.apply(r, Xt(t)) : n.push(t)
                    })) || n
                },
                Xt = function(t, e) {
                    return !M(t) || e || !s && xe() ? P(t) ? Wt(t, e) : Vt(t) ? Gt.call(t, 0) : t ? [t] : [] : Gt.call(c.querySelectorAll(t), 0)
                },
                qt = function(t) {
                    return t.sort((function() {
                        return .5 - Math.random()
                    }))
                },
                Yt = function(t) {
                    if (T(t)) return t;
                    var e = A(t) ? t : {
                            each: t
                        },
                        n = Ce(e.ease),
                        r = e.from || 0,
                        i = parseFloat(e.base) || 0,
                        o = {},
                        a = r > 0 && r < 1,
                        s = isNaN(r) || a,
                        c = e.axis,
                        l = r,
                        u = r;
                    return M(r) ? l = u = {
                            center: .5,
                            edges: .5,
                            end: 1
                        }[r] || 0 : !a && s && (l = r[0], u = r[1]),
                        function(t, a, h) {
                            var d, p, f, g, v, y, _, x, w, M = (h || e).length,
                                T = o[M];
                            if (!T) {
                                if (w = "auto" === e.grid ? 0 : (e.grid || [1, m])[1], !w) {
                                    _ = -m;
                                    while (_ < (_ = h[w++].getBoundingClientRect().left) && w < M);
                                    w--
                                }
                                for (T = o[M] = [], d = s ? Math.min(w, M) * l - .5 : r % w, p = s ? M * u / w - .5 : r / w | 0, _ = 0, x = m, y = 0; y < M; y++) f = y % w - d, g = p - (y / w | 0), T[y] = v = c ? Math.abs("y" === c ? g : f) : b(f * f + g * g), v > _ && (_ = v), v < x && (x = v);
                                "random" === r && qt(T), T.max = _ - x, T.min = x, T.v = M = (parseFloat(e.amount) || parseFloat(e.each) * (w > M ? M - 1 : c ? "y" === c ? M / w : w : Math.max(w, M / w)) || 0) * ("edges" === r ? -1 : 1), T.b = M < 0 ? i - M : i, T.u = zt(e.amount || e.each) || 0, n = n && M < 0 ? Le(n) : n
                            }
                            return M = (T[t] - T.min) / T.max || 0, it(T.b + (n ? n(M) : M) * T.v) + T.u
                        }
                },
                $t = function(t) {
                    var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
                    return function(n) {
                        return Math.floor(Math.round(parseFloat(n) / t) * t * e) / e + (S(n) ? 0 : zt(n))
                    }
                },
                Zt = function(t, e) {
                    var n, r, i = P(t);
                    return !i && A(t) && (n = i = t.radius || m, t.values ? (t = Xt(t.values), (r = !S(t[0])) && (n *= n)) : t = $t(t.increment)), Ut(e, i ? T(t) ? function(e) {
                        return r = t(e), Math.abs(r - e) <= n ? r : e
                    } : function(e) {
                        var i, o, a = parseFloat(r ? e.x : e),
                            s = parseFloat(r ? e.y : 0),
                            c = m,
                            l = 0,
                            u = t.length;
                        while (u--) r ? (i = t[u].x - a, o = t[u].y - s, i = i * i + o * o) : i = Math.abs(t[u] - a), i < c && (c = i, l = u);
                        return l = !n || c <= n ? t[l] : e, r || l === e || S(e) ? l : l + zt(e)
                    } : $t(t))
                },
                Jt = function(t, e, n, r) {
                    return Ut(P(t) ? !e : !0 === n ? !!(n = 0) : !r, (function() {
                        return P(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (r = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t + Math.random() * (e - t)) / n) * n * r) / r
                    }))
                },
                Kt = function() {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    return function(t) {
                        return e.reduce((function(t, e) {
                            return e(t)
                        }), t)
                    }
                },
                Qt = function(t, e) {
                    return function(n) {
                        return t(parseFloat(n)) + (e || zt(n))
                    }
                },
                te = function(t, e, n) {
                    return oe(t, e, 0, 1, n)
                },
                ee = function(t, e, n) {
                    return Ut(n, (function(n) {
                        return t[~~e(n)]
                    }))
                },
                ne = function t(e, n, r) {
                    var i = n - e;
                    return P(e) ? ee(e, t(0, e.length), n) : Ut(r, (function(t) {
                        return (i + (t - e) % i) % i + e
                    }))
                },
                re = function t(e, n, r) {
                    var i = n - e,
                        o = 2 * i;
                    return P(e) ? ee(e, t(0, e.length - 1), n) : Ut(r, (function(t) {
                        return t = (o + (t - e) % o) % o || 0, e + (t > i ? o - t : t)
                    }))
                },
                ie = function(t) {
                    var e, n, r, i, o = 0,
                        a = "";
                    while (~(e = t.indexOf("random(", o))) r = t.indexOf(")", e), i = "[" === t.charAt(e + 7), n = t.substr(e + 7, r - e - 7).match(i ? B : I), a += t.substr(o, e - o) + Jt(i ? n : +n[0], i ? 0 : +n[1], +n[2] || 1e-5), o = r + 1;
                    return a + t.substr(o, t.length - o)
                },
                oe = function(t, e, n, r, i) {
                    var o = e - t,
                        a = r - n;
                    return Ut(i, (function(e) {
                        return n + ((e - t) / o * a || 0)
                    }))
                },
                ae = function t(e, n, r, i) {
                    var o = isNaN(e + n) ? 0 : function(t) {
                        return (1 - t) * e + t * n
                    };
                    if (!o) {
                        var a, s, c, l, u, h = M(e),
                            d = {};
                        if (!0 === r && (i = 1) && (r = null), h) e = {
                            p: e
                        }, n = {
                            p: n
                        };
                        else if (P(e) && !P(n)) {
                            for (c = [], l = e.length, u = l - 2, s = 1; s < l; s++) c.push(t(e[s - 1], e[s]));
                            l--, o = function(t) {
                                t *= l;
                                var e = Math.min(u, ~~t);
                                return c[e](t - e)
                            }, r = n
                        } else i || (e = pt(P(e) ? [] : {}, e));
                        if (!c) {
                            for (a in n) He.call(d, e, a, "get", n[a]);
                            o = function(t) {
                                return rn(t, d) || (h ? e.p : e)
                            }
                        }
                    }
                    return Ut(r, o)
                },
                se = function(t, e, n) {
                    var r, i, o, a = t.labels,
                        s = m;
                    for (r in a) i = a[r] - e, i < 0 === !!n && i && s > (i = Math.abs(i)) && (o = r, s = i);
                    return o
                },
                ce = function(t, e, n) {
                    var r, i, o = t.vars,
                        a = o[e];
                    if (a) return r = o[e + "Params"], i = o.callbackScope || t, n && q.length && st(), r ? a.apply(i, r) : a.call(i)
                },
                le = function(t) {
                    return bt(t), t.progress() < 1 && ce(t, "onInterrupt"), t
                },
                ue = function(t) {
                    t = !t.name && t["default"] || t;
                    var e = t.name,
                        n = T(t),
                        r = e && !n && t.init ? function() {
                            this._props = []
                        } : t,
                        i = {
                            init: W,
                            render: rn,
                            add: He,
                            kill: an,
                            modifier: on,
                            rawVars: 0
                        },
                        o = {
                            targetTest: 0,
                            get: 0,
                            getSetter: Qe,
                            aliases: {},
                            register: 0
                        };
                    if (xe(), t !== r) {
                        if ($[e]) return;
                        ht(r, ht(mt(t, i), o)), pt(r.prototype, pt(i, mt(t, o))), $[r.prop = e] = r, t.targetTest && (K.push(r), X[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                    }
                    V(e, r), t.register && t.register(fn, r, ln)
                },
                he = 255,
                de = {
                    aqua: [0, he, he],
                    lime: [0, he, 0],
                    silver: [192, 192, 192],
                    black: [0, 0, 0],
                    maroon: [128, 0, 0],
                    teal: [0, 128, 128],
                    blue: [0, 0, he],
                    navy: [0, 0, 128],
                    white: [he, he, he],
                    olive: [128, 128, 0],
                    yellow: [he, he, 0],
                    orange: [he, 165, 0],
                    gray: [128, 128, 128],
                    purple: [128, 0, 128],
                    green: [0, 128, 0],
                    red: [he, 0, 0],
                    pink: [he, 192, 203],
                    cyan: [0, he, he],
                    transparent: [he, he, he, 0]
                },
                pe = function(t, e, n) {
                    return t = t < 0 ? t + 1 : t > 1 ? t - 1 : t, (6 * t < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * he + .5 | 0
                },
                fe = function(t, e, n) {
                    var r, i, o, a, s, c, l, u, h, d, p = t ? S(t) ? [t >> 16, t >> 8 & he, t & he] : 0 : de.black;
                    if (!p) {
                        if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), de[t]) p = de[t];
                        else if ("#" === t.charAt(0)) 4 === t.length && (r = t.charAt(1), i = t.charAt(2), o = t.charAt(3), t = "#" + r + r + i + i + o + o), t = parseInt(t.substr(1), 16), p = [t >> 16, t >> 8 & he, t & he];
                        else if ("hsl" === t.substr(0, 3))
                            if (p = d = t.match(I), e) {
                                if (~t.indexOf("=")) return p = t.match(N), n && p.length < 4 && (p[3] = 1), p
                            } else a = +p[0] % 360 / 360, s = +p[1] / 100, c = +p[2] / 100, i = c <= .5 ? c * (s + 1) : c + s - c * s, r = 2 * c - i, p.length > 3 && (p[3] *= 1), p[0] = pe(a + 1 / 3, r, i), p[1] = pe(a, r, i), p[2] = pe(a - 1 / 3, r, i);
                        else p = t.match(I) || de.transparent;
                        p = p.map(Number)
                    }
                    return e && !d && (r = p[0] / he, i = p[1] / he, o = p[2] / he, l = Math.max(r, i, o), u = Math.min(r, i, o), c = (l + u) / 2, l === u ? a = s = 0 : (h = l - u, s = c > .5 ? h / (2 - l - u) : h / (l + u), a = l === r ? (i - o) / h + (i < o ? 6 : 0) : l === i ? (o - r) / h + 2 : (r - i) / h + 4, a *= 60), p[0] = ~~(a + .5), p[1] = ~~(100 * s + .5), p[2] = ~~(100 * c + .5)), n && p.length < 4 && (p[3] = 1), p
                },
                me = function(t) {
                    var e = [],
                        n = [],
                        r = -1;
                    return t.split(ve).forEach((function(t) {
                        var i = t.match(D) || [];
                        e.push.apply(e, i), n.push(r += i.length + 1)
                    })), e.c = n, e
                },
                ge = function(t, e, n) {
                    var r, i, o, a, s = "",
                        c = (t + s).match(ve),
                        l = e ? "hsla(" : "rgba(",
                        u = 0;
                    if (!c) return t;
                    if (c = c.map((function(t) {
                            return (t = fe(t, e, 1)) && l + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
                        })), n && (o = me(t), r = n.c, r.join(s) !== o.c.join(s)))
                        for (i = t.replace(ve, "1").split(D), a = i.length - 1; u < a; u++) s += i[u] + (~r.indexOf(u) ? c.shift() || l + "0,0,0,0)" : (o.length ? o : c.length ? c : n).shift());
                    if (!i)
                        for (i = t.split(ve), a = i.length - 1; u < a; u++) s += i[u] + c[u];
                    return s + i[a]
                },
                ve = function() {
                    var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                    for (t in de) e += "|" + t + "\\b";
                    return new RegExp(e + ")", "gi")
                }(),
                ye = /hsl[a]?\(/,
                _e = function(t) {
                    var e, n = t.join(" ");
                    if (ve.lastIndex = 0, ve.test(n)) return e = ye.test(n), t[1] = ge(t[1], e), t[0] = ge(t[0], e, me(t[1])), !0
                },
                be = function() {
                    var t, e, n, r, i, o, u = Date.now,
                        h = 500,
                        p = 33,
                        f = u(),
                        m = f,
                        v = 1e3 / 240,
                        y = v,
                        _ = [],
                        b = function n(a) {
                            var s, c, l, d, g = u() - m,
                                b = !0 === a;
                            if (g > h && (f += g - p), m += g, l = m - f, s = l - y, (s > 0 || b) && (d = ++r.frame, i = l - 1e3 * r.time, r.time = l /= 1e3, y += s + (s >= v ? 4 : v - s), c = 1), b || (t = e(n)), c)
                                for (o = 0; o < _.length; o++) _[o](l, i, d, a)
                        };
                    return r = {
                        time: 0,
                        frame: 0,
                        tick: function() {
                            b(!0)
                        },
                        deltaRatio: function(t) {
                            return i / (1e3 / (t || 60))
                        },
                        wake: function() {
                            l && (!s && R() && (a = s = window, c = a.document || {}, U.gsap = fn, (a.gsapVersions || (a.gsapVersions = [])).push(fn.version), z(H || a.GreenSockGlobals || !a.gsap && a || {}), n = a.requestAnimationFrame), t && r.sleep(), e = n || function(t) {
                                return setTimeout(t, y - 1e3 * r.time + 1 | 0)
                            }, d = 1, b(2))
                        },
                        sleep: function() {
                            (n ? a.cancelAnimationFrame : clearTimeout)(t), d = 0, e = W
                        },
                        lagSmoothing: function(t, e) {
                            h = t || 1 / g, p = Math.min(e, h, 0)
                        },
                        fps: function(t) {
                            v = 1e3 / (t || 240), y = 1e3 * r.time + v
                        },
                        add: function(t) {
                            _.indexOf(t) < 0 && _.push(t), xe()
                        },
                        remove: function(t) {
                            var e;
                            ~(e = _.indexOf(t)) && _.splice(e, 1) && o >= e && o--
                        },
                        _listeners: _
                    }, r
                }(),
                xe = function() {
                    return !d && be.wake()
                },
                we = {},
                Me = /^[\d.\-M][\d.\-,\s]/,
                Te = /["']/g,
                Se = function(t) {
                    for (var e, n, r, i = {}, o = t.substr(1, t.length - 3).split(":"), a = o[0], s = 1, c = o.length; s < c; s++) n = o[s], e = s !== c - 1 ? n.lastIndexOf(",") : n.length, r = n.substr(0, e), i[a] = isNaN(r) ? r.replace(Te, "").trim() : +r, a = n.substr(e + 1).trim();
                    return i
                },
                Ee = function(t) {
                    var e = t.indexOf("(") + 1,
                        n = t.indexOf(")"),
                        r = t.indexOf("(", e);
                    return t.substring(e, ~r && r < n ? t.indexOf(")", n + 1) : n)
                },
                Ae = function(t) {
                    var e = (t + "").split("("),
                        n = we[e[0]];
                    return n && e.length > 1 && n.config ? n.config.apply(null, ~t.indexOf("{") ? [Se(e[1])] : Ee(t).split(",").map(lt)) : we._CE && Me.test(t) ? we._CE("", t) : n
                },
                Le = function(t) {
                    return function(e) {
                        return 1 - t(1 - e)
                    }
                },
                Re = function t(e, n) {
                    var r, i = e._first;
                    while (i) i instanceof Fe ? t(i, n) : !i.vars.yoyoEase || i._yoyo && i._repeat || i._yoyo === n || (i.timeline ? t(i.timeline, n) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = n)), i = i._next
                },
                Ce = function(t, e) {
                    return t && (T(t) ? t : we[t] || Ae(t)) || e
                },
                Oe = function(t, e, n, r) {
                    void 0 === n && (n = function(t) {
                        return 1 - e(1 - t)
                    }), void 0 === r && (r = function(t) {
                        return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
                    });
                    var i, o = {
                        easeIn: e,
                        easeOut: n,
                        easeInOut: r
                    };
                    return rt(t, (function(t) {
                        for (var e in we[t] = U[t] = o, we[i = t.toLowerCase()] = n, o) we[i + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = we[t + "." + e] = o[e]
                    })), o
                },
                Pe = function(t) {
                    return function(e) {
                        return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
                    }
                },
                Ie = function t(e, n, r) {
                    var i = n >= 1 ? n : 1,
                        o = (r || (e ? .3 : .45)) / (n < 1 ? n : 1),
                        a = o / v * (Math.asin(1 / i) || 0),
                        s = function(t) {
                            return 1 === t ? 1 : i * Math.pow(2, -10 * t) * w((t - a) * o) + 1
                        },
                        c = "out" === e ? s : "in" === e ? function(t) {
                            return 1 - s(1 - t)
                        } : Pe(s);
                    return o = v / o, c.config = function(n, r) {
                        return t(e, n, r)
                    }, c
                },
                Ne = function t(e, n) {
                    void 0 === n && (n = 1.70158);
                    var r = function(t) {
                            return t ? --t * t * ((n + 1) * t + n) + 1 : 0
                        },
                        i = "out" === e ? r : "in" === e ? function(t) {
                            return 1 - r(1 - t)
                        } : Pe(r);
                    return i.config = function(n) {
                        return t(e, n)
                    }, i
                };
            rt("Linear,Quad,Cubic,Quart,Quint,Strong", (function(t, e) {
                    var n = e < 5 ? e + 1 : e;
                    Oe(t + ",Power" + (n - 1), e ? function(t) {
                        return Math.pow(t, n)
                    } : function(t) {
                        return t
                    }, (function(t) {
                        return 1 - Math.pow(1 - t, n)
                    }), (function(t) {
                        return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
                    }))
                })), we.Linear.easeNone = we.none = we.Linear.easeIn, Oe("Elastic", Ie("in"), Ie("out"), Ie()),
                function(t, e) {
                    var n = 1 / e,
                        r = 2 * n,
                        i = 2.5 * n,
                        o = function(o) {
                            return o < n ? t * o * o : o < r ? t * Math.pow(o - 1.5 / e, 2) + .75 : o < i ? t * (o -= 2.25 / e) * o + .9375 : t * Math.pow(o - 2.625 / e, 2) + .984375
                        };
                    Oe("Bounce", (function(t) {
                        return 1 - o(1 - t)
                    }), o)
                }(7.5625, 2.75), Oe("Expo", (function(t) {
                    return t ? Math.pow(2, 10 * (t - 1)) : 0
                })), Oe("Circ", (function(t) {
                    return -(b(1 - t * t) - 1)
                })), Oe("Sine", (function(t) {
                    return 1 === t ? 1 : 1 - x(t * y)
                })), Oe("Back", Ne("in"), Ne("out"), Ne()), we.SteppedEase = we.steps = U.SteppedEase = {
                    config: function(t, e) {
                        void 0 === t && (t = 1);
                        var n = 1 / t,
                            r = t + (e ? 0 : 1),
                            i = e ? 1 : 0,
                            o = 1 - g;
                        return function(t) {
                            return ((r * Ht(0, o, t) | 0) + i) * n
                        }
                    }
                }, f.ease = we["quad.out"], rt("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(t) {
                    return Q += t + "," + t + "Params,"
                }));
            var De = function(t, e) {
                    this.id = _++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : nt, this.set = e ? e.getSetter : Qe
                },
                ke = function() {
                    function t(t, e) {
                        var n = t.parent || o;
                        this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Dt(this, +t.duration, 1, 1), this.data = t.data, d || be.wake(), n && Ct(n, this, e || 0 === e ? e : n._time, 1), t.reversed && this.reverse(), t.paused && this.paused(!0)
                    }
                    var e = t.prototype;
                    return e.delay = function(t) {
                        return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
                    }, e.duration = function(t) {
                        return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
                    }, e.totalDuration = function(t) {
                        return arguments.length ? (this._dirty = 0, Dt(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                    }, e.totalTime = function(t, e) {
                        if (xe(), !arguments.length) return this._tTime;
                        var n = this._dp;
                        if (n && n.smoothChildTiming && this._ts) {
                            Lt(this, t);
                            while (n.parent) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
                            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && Ct(this._dp, this, this._start - this._delay)
                        }
                        return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === g || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), ct(this, t, e)), this
                    }, e.time = function(t, e) {
                        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Tt(this)) % this._dur || (t ? this._dur : 0), e) : this._time
                    }, e.totalProgress = function(t, e) {
                        return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
                    }, e.progress = function(t, e) {
                        return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Tt(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
                    }, e.iteration = function(t, e) {
                        var n = this.duration() + this._rDelay;
                        return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? St(this._tTime, n) + 1 : 1
                    }, e.timeScale = function(t) {
                        if (!arguments.length) return this._rts === -g ? 0 : this._rts;
                        if (this._rts === t) return this;
                        var e = this.parent && this._ts ? Et(this.parent._time, this) : this._tTime;
                        return this._rts = +t || 0, this._ts = this._ps || t === -g ? 0 : this._rts, wt(this.totalTime(Ht(-this._delay, this._tDur, e), !0))
                    }, e.paused = function(t) {
                        return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (xe(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= g) && Math.abs(this._zTime) !== g))), this) : this._ps
                    }, e.startTime = function(t) {
                        if (arguments.length) {
                            this._start = t;
                            var e = this.parent || this._dp;
                            return e && (e._sort || !this.parent) && Ct(e, this, t - this._delay), this
                        }
                        return this._start
                    }, e.endTime = function(t) {
                        return this._start + (L(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
                    }, e.rawTime = function(t) {
                        var e = this.parent || this._dp;
                        return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Et(e.rawTime(t), this) : this._tTime : this._tTime
                    }, e.globalTime = function(t) {
                        var e = this,
                            n = arguments.length ? t : e.rawTime();
                        while (e) n = e._start + n / (e._ts || 1), e = e._dp;
                        return n
                    }, e.repeat = function(t) {
                        return arguments.length ? (this._repeat = t, kt(this)) : this._repeat
                    }, e.repeatDelay = function(t) {
                        return arguments.length ? (this._rDelay = t, kt(this)) : this._rDelay
                    }, e.yoyo = function(t) {
                        return arguments.length ? (this._yoyo = t, this) : this._yoyo
                    }, e.seek = function(t, e) {
                        return this.totalTime(Bt(this, t), L(e))
                    }, e.restart = function(t, e) {
                        return this.play().totalTime(t ? -this._delay : 0, L(e))
                    }, e.play = function(t, e) {
                        return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                    }, e.reverse = function(t, e) {
                        return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                    }, e.pause = function(t, e) {
                        return null != t && this.seek(t, e), this.paused(!0)
                    }, e.resume = function() {
                        return this.paused(!1)
                    }, e.reversed = function(t) {
                        return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -g : 0)), this) : this._rts < 0
                    }, e.invalidate = function() {
                        return this._initted = 0, this._zTime = -g, this
                    }, e.isActive = function() {
                        var t, e = this.parent || this._dp,
                            n = this._start;
                        return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - g))
                    }, e.eventCallback = function(t, e, n) {
                        var r = this.vars;
                        return arguments.length > 1 ? (e ? (r[t] = e, n && (r[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete r[t], this) : r[t]
                    }, e.then = function(t) {
                        var e = this;
                        return new Promise((function(n) {
                            var r = T(t) ? t : ut,
                                i = function() {
                                    var t = e.then;
                                    e.then = null, T(r) && (r = r(e)) && (r.then || r === e) && (e.then = t), n(r), e.then = t
                                };
                            e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? i() : e._prom = i
                        }))
                    }, e.kill = function() {
                        le(this)
                    }, t
                }();
            ht(ke.prototype, {
                _time: 0,
                _start: 0,
                _end: 0,
                _tTime: 0,
                _tDur: 0,
                _dirty: 0,
                _repeat: 0,
                _yoyo: !1,
                parent: null,
                _initted: !1,
                _rDelay: 0,
                _ts: 1,
                _dp: 0,
                ratio: 0,
                _zTime: -g,
                _prom: 0,
                _ps: !1,
                _rts: 1
            });
            var Fe = function(t) {
                function e(e, n) {
                    var i;
                    return void 0 === e && (e = {}), i = t.call(this, e, n) || this, i.labels = {}, i.smoothChildTiming = !!e.smoothChildTiming, i.autoRemoveChildren = !!e.autoRemoveChildren, i._sort = L(e.sortChildren), i.parent && Rt(i.parent, r(i)), e.scrollTrigger && Ot(r(i), e.scrollTrigger), i
                }
                i(e, t);
                var n = e.prototype;
                return n.to = function(t, e, n) {
                    return new Ye(t, at(arguments, 0, this), Bt(this, S(e) ? arguments[3] : n)), this
                }, n.from = function(t, e, n) {
                    return new Ye(t, at(arguments, 1, this), Bt(this, S(e) ? arguments[3] : n)), this
                }, n.fromTo = function(t, e, n, r) {
                    return new Ye(t, at(arguments, 2, this), Bt(this, S(e) ? arguments[4] : r)), this
                }, n.set = function(t, e, n) {
                    return e.duration = 0, e.parent = this, gt(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new Ye(t, e, Bt(this, n), 1), this
                }, n.call = function(t, e, n) {
                    return Ct(this, Ye.delayedCall(0, t, e), Bt(this, n))
                }, n.staggerTo = function(t, e, n, r, i, o, a) {
                    return n.duration = e, n.stagger = n.stagger || r, n.onComplete = o, n.onCompleteParams = a, n.parent = this, new Ye(t, n, Bt(this, i)), this
                }, n.staggerFrom = function(t, e, n, r, i, o, a) {
                    return n.runBackwards = 1, gt(n).immediateRender = L(n.immediateRender), this.staggerTo(t, e, n, r, i, o, a)
                }, n.staggerFromTo = function(t, e, n, r, i, o, a, s) {
                    return r.startAt = n, gt(r).immediateRender = L(r.immediateRender), this.staggerTo(t, e, r, i, o, a, s)
                }, n.render = function(t, e, n) {
                    var r, i, a, s, c, l, u, h, d, p, f, m, v = this._time,
                        y = this._dirty ? this.totalDuration() : this._tDur,
                        _ = this._dur,
                        b = this !== o && t > y - g && t >= 0 ? y : t < g ? 0 : t,
                        x = this._zTime < 0 !== t < 0 && (this._initted || !_);
                    if (b !== this._tTime || n || x) {
                        if (v !== this._time && _ && (b += this._time - v, t += this._time - v), r = b, d = this._start, h = this._ts, l = !h, x && (_ || (v = this._zTime), (t || !e) && (this._zTime = t)), this._repeat && (f = this._yoyo, c = _ + this._rDelay, r = it(b % c), b === y ? (s = this._repeat, r = _) : (s = ~~(b / c), s && s === b / c && (r = _, s--), r > _ && (r = _)), p = St(this._tTime, c), !v && this._tTime && p !== s && (p = s), f && 1 & s && (r = _ - r, m = 1), s !== p && !this._lock)) {
                            var w = f && 1 & p,
                                M = w === (f && 1 & s);
                            if (s < p && (w = !w), v = w ? 0 : _, this._lock = 1, this.render(v || (m ? 0 : it(s * c)), e, !_)._lock = 0, !e && this.parent && ce(this, "onRepeat"), this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1), v !== this._time || l !== !this._ts) return this;
                            if (_ = this._dur, y = this._tDur, M && (this._lock = 2, v = w ? _ : -1e-4, this.render(v, !0), this.vars.repeatRefresh && !m && this.invalidate()), this._lock = 0, !this._ts && !l) return this;
                            Re(this, m)
                        }
                        if (this._hasPause && !this._forcing && this._lock < 2 && (u = Nt(this, it(v), it(r)), u && (b -= r - (r = u._start))), this._tTime = b, this._time = r, this._act = !h, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t), !v && r && !e && ce(this, "onStart"), r >= v && t >= 0) {
                            i = this._first;
                            while (i) {
                                if (a = i._next, (i._act || r >= i._start) && i._ts && u !== i) {
                                    if (i.parent !== this) return this.render(t, e, n);
                                    if (i.render(i._ts > 0 ? (r - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (r - i._start) * i._ts, e, n), r !== this._time || !this._ts && !l) {
                                        u = 0, a && (b += this._zTime = -g);
                                        break
                                    }
                                }
                                i = a
                            }
                        } else {
                            i = this._last;
                            var T = t < 0 ? t : r;
                            while (i) {
                                if (a = i._prev, (i._act || T <= i._end) && i._ts && u !== i) {
                                    if (i.parent !== this) return this.render(t, e, n);
                                    if (i.render(i._ts > 0 ? (T - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (T - i._start) * i._ts, e, n), r !== this._time || !this._ts && !l) {
                                        u = 0, a && (b += this._zTime = T ? -g : g);
                                        break
                                    }
                                }
                                i = a
                            }
                        }
                        if (u && !e && (this.pause(), u.render(r >= v ? 0 : -g)._zTime = r >= v ? 1 : -1, this._ts)) return this._start = d, At(this), this.render(t, e, n);
                        this._onUpdate && !e && ce(this, "onUpdate", !0), (b === y && y >= this.totalDuration() || !b && v) && (d !== this._start && Math.abs(h) === Math.abs(this._ts) || this._lock || ((t || !_) && (b === y && this._ts > 0 || !b && this._ts < 0) && bt(this, 1), e || t < 0 && !v || !b && !v || (ce(this, b === y ? "onComplete" : "onReverseComplete", !0), this._prom && !(b < y && this.timeScale() > 0) && this._prom())))
                    }
                    return this
                }, n.add = function(t, e) {
                    var n = this;
                    if (S(e) || (e = Bt(this, e)), !(t instanceof ke)) {
                        if (P(t)) return t.forEach((function(t) {
                            return n.add(t, e)
                        })), this;
                        if (M(t)) return this.addLabel(t, e);
                        if (!T(t)) return this;
                        t = Ye.delayedCall(0, t)
                    }
                    return this !== t ? Ct(this, t, e) : this
                }, n.getChildren = function(t, e, n, r) {
                    void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === r && (r = -m);
                    var i = [],
                        o = this._first;
                    while (o) o._start >= r && (o instanceof Ye ? e && i.push(o) : (n && i.push(o), t && i.push.apply(i, o.getChildren(!0, e, n)))), o = o._next;
                    return i
                }, n.getById = function(t) {
                    var e = this.getChildren(1, 1, 1),
                        n = e.length;
                    while (n--)
                        if (e[n].vars.id === t) return e[n]
                }, n.remove = function(t) {
                    return M(t) ? this.removeLabel(t) : T(t) ? this.killTweensOf(t) : (_t(this, t), t === this._recent && (this._recent = this._last), xt(this))
                }, n.totalTime = function(e, n) {
                    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = it(be.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime
                }, n.addLabel = function(t, e) {
                    return this.labels[t] = Bt(this, e), this
                }, n.removeLabel = function(t) {
                    return delete this.labels[t], this
                }, n.addPause = function(t, e, n) {
                    var r = Ye.delayedCall(0, e || W, n);
                    return r.data = "isPause", this._hasPause = 1, Ct(this, r, Bt(this, t))
                }, n.removePause = function(t) {
                    var e = this._first;
                    t = Bt(this, t);
                    while (e) e._start === t && "isPause" === e.data && bt(e), e = e._next
                }, n.killTweensOf = function(t, e, n) {
                    var r = this.getTweensOf(t, n),
                        i = r.length;
                    while (i--) Be !== r[i] && r[i].kill(t, e);
                    return this
                }, n.getTweensOf = function(t, e) {
                    var n, r = [],
                        i = Xt(t),
                        o = this._first,
                        a = S(e);
                    while (o) o instanceof Ye ? ot(o._targets, i) && (a ? (!Be || o._initted && o._ts) && o.globalTime(0) <= e && o.globalTime(o.totalDuration()) > e : !e || o.isActive()) && r.push(o) : (n = o.getTweensOf(i, e)).length && r.push.apply(r, n), o = o._next;
                    return r
                }, n.tweenTo = function(t, e) {
                    e = e || {};
                    var n = this,
                        r = Bt(n, t),
                        i = e,
                        o = i.startAt,
                        a = i.onStart,
                        s = i.onStartParams,
                        c = Ye.to(n, ht(e, {
                            ease: "none",
                            lazy: !1,
                            time: r,
                            overwrite: "auto",
                            duration: e.duration || Math.abs((r - (o && "time" in o ? o.time : n._time)) / n.timeScale()) || g,
                            onStart: function() {
                                n.pause();
                                var t = e.duration || Math.abs((r - n._time) / n.timeScale());
                                c._dur !== t && Dt(c, t, 0, 1).render(c._time, !0, !0), a && a.apply(c, s || [])
                            }
                        }));
                    return c
                }, n.tweenFromTo = function(t, e, n) {
                    return this.tweenTo(e, ht({
                        startAt: {
                            time: Bt(this, t)
                        }
                    }, n))
                }, n.recent = function() {
                    return this._recent
                }, n.nextLabel = function(t) {
                    return void 0 === t && (t = this._time), se(this, Bt(this, t))
                }, n.previousLabel = function(t) {
                    return void 0 === t && (t = this._time), se(this, Bt(this, t), 1)
                }, n.currentLabel = function(t) {
                    return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + g)
                }, n.shiftChildren = function(t, e, n) {
                    void 0 === n && (n = 0);
                    var r, i = this._first,
                        o = this.labels;
                    while (i) i._start >= n && (i._start += t, i._end += t), i = i._next;
                    if (e)
                        for (r in o) o[r] >= n && (o[r] += t);
                    return xt(this)
                }, n.invalidate = function() {
                    var e = this._first;
                    this._lock = 0;
                    while (e) e.invalidate(), e = e._next;
                    return t.prototype.invalidate.call(this)
                }, n.clear = function(t) {
                    void 0 === t && (t = !0);
                    var e, n = this._first;
                    while (n) e = n._next, this.remove(n), n = e;
                    return this._time = this._tTime = this._pTime = 0, t && (this.labels = {}), xt(this)
                }, n.totalDuration = function(t) {
                    var e, n, r, i = 0,
                        a = this,
                        s = a._last,
                        c = m;
                    if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -t : t));
                    if (a._dirty) {
                        r = a.parent;
                        while (s) e = s._prev, s._dirty && s.totalDuration(), n = s._start, n > c && a._sort && s._ts && !a._lock ? (a._lock = 1, Ct(a, s, n - s._delay, 1)._lock = 0) : c = n, n < 0 && s._ts && (i -= n, (!r && !a._dp || r && r.smoothChildTiming) && (a._start += n / a._ts, a._time -= n, a._tTime -= n), a.shiftChildren(-n, !1, -Infinity), c = 0), s._end > i && s._ts && (i = s._end), s = e;
                        Dt(a, a === o && a._time > i ? a._time : i, 1, 1), a._dirty = 0
                    }
                    return a._tDur
                }, e.updateRoot = function(t) {
                    if (o._ts && (ct(o, Et(t, o)), u = be.frame), be.frame >= J) {
                        J += p.autoSleep || 120;
                        var e = o._first;
                        if ((!e || !e._ts) && p.autoSleep && be._listeners.length < 2) {
                            while (e && !e._ts) e = e._next;
                            e || be.sleep()
                        }
                    }
                }, e
            }(ke);
            ht(Fe.prototype, {
                _lock: 0,
                _hasPause: 0,
                _forcing: 0
            });
            var Be, Ue = function(t, e, n, r, i, o, a) {
                    var s, c, l, u, h, d, p, f, m = new ln(this._pt, t, e, 0, 1, nn, null, i),
                        g = 0,
                        v = 0;
                    m.b = n, m.e = r, n += "", r += "", (p = ~r.indexOf("random(")) && (r = ie(r)), o && (f = [n, r], o(f, t, e), n = f[0], r = f[1]), c = n.match(k) || [];
                    while (s = k.exec(r)) u = s[0], h = r.substring(g, s.index), l ? l = (l + 1) % 5 : "rgba(" === h.substr(-5) && (l = 1), u !== c[v++] && (d = parseFloat(c[v - 1]) || 0, m._pt = {
                        _next: m._pt,
                        p: h || 1 === v ? h : ",",
                        s: d,
                        c: "=" === u.charAt(1) ? parseFloat(u.substr(2)) * ("-" === u.charAt(0) ? -1 : 1) : parseFloat(u) - d,
                        m: l && l < 4 ? Math.round : 0
                    }, g = k.lastIndex);
                    return m.c = g < r.length ? r.substring(g, r.length) : "", m.fp = a, (F.test(r) || p) && (m.e = 0), this._pt = m, m
                },
                He = function(t, e, n, r, i, o, a, s, c) {
                    T(r) && (r = r(i || 0, t, o));
                    var l, u = t[e],
                        h = "get" !== n ? n : T(u) ? c ? t[e.indexOf("set") || !T(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](c) : t[e]() : u,
                        d = T(u) ? c ? Je : Ze : $e;
                    if (M(r) && (~r.indexOf("random(") && (r = ie(r)), "=" === r.charAt(1) && (r = parseFloat(h) + parseFloat(r.substr(2)) * ("-" === r.charAt(0) ? -1 : 1) + (zt(h) || 0))), h !== r) return isNaN(h * r) ? (!u && !(e in t) && j(e, r), Ue.call(this, t, e, h, r, d, s || p.stringFilter, c)) : (l = new ln(this._pt, t, e, +h || 0, r - (h || 0), "boolean" === typeof u ? en : tn, 0, d), c && (l.fp = c), a && l.modifier(a, this, t), this._pt = l)
                },
                ze = function(t, e, n, r, i) {
                    if (T(t) && (t = We(t, i, e, n, r)), !A(t) || t.style && t.nodeType || P(t) || O(t)) return M(t) ? We(t, i, e, n, r) : t;
                    var o, a = {};
                    for (o in t) a[o] = We(t[o], i, e, n, r);
                    return a
                },
                je = function(t, e, n, r, i, o) {
                    var a, s, c, l;
                    if ($[t] && !1 !== (a = new $[t]).init(i, a.rawVars ? e[t] : ze(e[t], r, i, o, n), n, r, o) && (n._pt = s = new ln(n._pt, i, t, 0, 1, a.render, a, 0, a.priority), n !== h)) {
                        c = n._ptLookup[n._targets.indexOf(i)], l = a._props.length;
                        while (l--) c[a._props[l]] = s
                    }
                    return a
                },
                Ge = function t(e, n) {
                    var r, i, a, s, c, l, u, h, d, p, m, v, y, _ = e.vars,
                        b = _.ease,
                        x = _.startAt,
                        w = _.immediateRender,
                        M = _.lazy,
                        T = _.onUpdate,
                        S = _.onUpdateParams,
                        E = _.callbackScope,
                        A = _.runBackwards,
                        R = _.yoyoEase,
                        C = _.keyframes,
                        O = _.autoRevert,
                        P = e._dur,
                        I = e._startAt,
                        N = e._targets,
                        D = e.parent,
                        k = D && "nested" === D.data ? D.parent._targets : N,
                        F = "auto" === e._overwrite,
                        B = e.timeline;
                    if (B && (!C || !b) && (b = "none"), e._ease = Ce(b, f.ease), e._yEase = R ? Le(Ce(!0 === R ? b : R, f.ease)) : 0, R && e._yoyo && !e._repeat && (R = e._yEase, e._yEase = e._ease, e._ease = R), !B) {
                        if (h = N[0] ? et(N[0]).harness : 0, v = h && _[h.prop], r = mt(_, X), I && I.render(-1, !0).kill(), x) {
                            if (bt(e._startAt = Ye.set(N, ht({
                                    data: "isStart",
                                    overwrite: !1,
                                    parent: D,
                                    immediateRender: !0,
                                    lazy: L(M),
                                    startAt: null,
                                    delay: 0,
                                    onUpdate: T,
                                    onUpdateParams: S,
                                    callbackScope: E,
                                    stagger: 0
                                }, x))), w)
                                if (n > 0) O || (e._startAt = 0);
                                else if (P && !(n < 0 && I)) return void(n && (e._zTime = n))
                        } else if (A && P)
                            if (I) !O && (e._startAt = 0);
                            else if (n && (w = !1), a = ht({
                                overwrite: !1,
                                data: "isFromStart",
                                lazy: w && L(M),
                                immediateRender: w,
                                stagger: 0,
                                parent: D
                            }, r), v && (a[h.prop] = v), bt(e._startAt = Ye.set(N, a)), w) {
                            if (!n) return
                        } else t(e._startAt, g);
                        for (e._pt = 0, M = P && L(M) || M && !P, i = 0; i < N.length; i++) {
                            if (c = N[i], u = c._gsap || tt(N)[i]._gsap, e._ptLookup[i] = p = {}, Y[u.id] && q.length && st(), m = k === N ? i : k.indexOf(c), h && !1 !== (d = new h).init(c, v || r, e, m, k) && (e._pt = s = new ln(e._pt, c, d.name, 0, 1, d.render, d, 0, d.priority), d._props.forEach((function(t) {
                                    p[t] = s
                                })), d.priority && (l = 1)), !h || v)
                                for (a in r) $[a] && (d = je(a, r, e, m, c, k)) ? d.priority && (l = 1) : p[a] = s = He.call(e, c, a, "get", r[a], m, k, 0, _.stringFilter);
                            e._op && e._op[i] && e.kill(c, e._op[i]), F && e._pt && (Be = e, o.killTweensOf(c, p, e.globalTime(0)), y = !e.parent, Be = 0), e._pt && M && (Y[u.id] = 1)
                        }
                        l && cn(e), e._onInit && e._onInit(e)
                    }
                    e._from = !B && !!_.runBackwards, e._onUpdate = T, e._initted = (!e._op || e._pt) && !y
                },
                Ve = function(t, e) {
                    var n, r, i, o, a = t[0] ? et(t[0]).harness : 0,
                        s = a && a.aliases;
                    if (!s) return e;
                    for (r in n = pt({}, e), s)
                        if (r in n) {
                            o = s[r].split(","), i = o.length;
                            while (i--) n[o[i]] = n[r]
                        }
                    return n
                },
                We = function(t, e, n, r, i) {
                    return T(t) ? t.call(e, n, r, i) : M(t) && ~t.indexOf("random(") ? ie(t) : t
                },
                Xe = Q + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
                qe = (Xe + ",id,stagger,delay,duration,paused,scrollTrigger").split(","),
                Ye = function(t) {
                    function e(e, n, i, a) {
                        var s;
                        "number" === typeof n && (i.duration = n, n = i, i = null), s = t.call(this, a ? n : gt(n), i) || this;
                        var c, l, u, h, d, f, m, v, y = s.vars,
                            _ = y.duration,
                            b = y.delay,
                            x = y.immediateRender,
                            w = y.stagger,
                            M = y.overwrite,
                            T = y.keyframes,
                            E = y.defaults,
                            R = y.scrollTrigger,
                            I = y.yoyoEase,
                            N = s.parent,
                            D = (P(e) || O(e) ? S(e[0]) : "length" in n) ? [e] : Xt(e);
                        if (s._targets = D.length ? tt(D) : G("GSAP target " + e + " not found. https://greensock.com", !p.nullTargetWarn) || [], s._ptLookup = [], s._overwrite = M, T || w || C(_) || C(b)) {
                            if (n = s.vars, c = s.timeline = new Fe({
                                    data: "nested",
                                    defaults: E || {}
                                }), c.kill(), c.parent = r(s), T) ht(c.vars.defaults, {
                                ease: "none"
                            }), T.forEach((function(t) {
                                return c.to(D, t, ">")
                            }));
                            else {
                                if (h = D.length, m = w ? Yt(w) : W, A(w))
                                    for (d in w) ~Xe.indexOf(d) && (v || (v = {}), v[d] = w[d]);
                                for (l = 0; l < h; l++) {
                                    for (d in u = {}, n) qe.indexOf(d) < 0 && (u[d] = n[d]);
                                    u.stagger = 0, I && (u.yoyoEase = I), v && pt(u, v), f = D[l], u.duration = +We(_, r(s), l, f, D), u.delay = (+We(b, r(s), l, f, D) || 0) - s._delay, !w && 1 === h && u.delay && (s._delay = b = u.delay, s._start += b, u.delay = 0), c.to(f, u, m(l, f, D))
                                }
                                c.duration() ? _ = b = 0 : s.timeline = 0
                            }
                            _ || s.duration(_ = c.duration())
                        } else s.timeline = 0;
                        return !0 === M && (Be = r(s), o.killTweensOf(D), Be = 0), N && Rt(N, r(s)), (x || !_ && !T && s._start === it(N._time) && L(x) && Mt(r(s)) && "nested" !== N.data) && (s._tTime = -g, s.render(Math.max(0, -b))), R && Ot(r(s), R), s
                    }
                    i(e, t);
                    var n = e.prototype;
                    return n.render = function(t, e, n) {
                        var r, i, o, a, s, c, l, u, h, d = this._time,
                            p = this._tDur,
                            f = this._dur,
                            m = t > p - g && t >= 0 ? p : t < g ? 0 : t;
                        if (f) {
                            if (m !== this._tTime || !t || n || this._startAt && this._zTime < 0 !== t < 0) {
                                if (r = m, u = this.timeline, this._repeat) {
                                    if (a = f + this._rDelay, r = it(m % a), m === p ? (o = this._repeat, r = f) : (o = ~~(m / a), o && o === m / a && (r = f, o--), r > f && (r = f)), c = this._yoyo && 1 & o, c && (h = this._yEase, r = f - r), s = St(this._tTime, a), r === d && !n && this._initted) return this;
                                    o !== s && (u && this._yEase && Re(u, c), !this.vars.repeatRefresh || c || this._lock || (this._lock = n = 1, this.render(it(a * o), !0).invalidate()._lock = 0))
                                }
                                if (!this._initted) {
                                    if (Pt(this, t < 0 ? t : r, n, e)) return this._tTime = 0, this;
                                    if (f !== this._dur) return this.render(t, e, n)
                                }
                                this._tTime = m, this._time = r, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = l = (h || this._ease)(r / f), this._from && (this.ratio = l = 1 - l), r && !d && !e && ce(this, "onStart"), i = this._pt;
                                while (i) i.r(l, i.d), i = i._next;
                                u && u.render(t < 0 ? t : !r && c ? -g : u._dur * l, e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n), ce(this, "onUpdate")), this._repeat && o !== s && this.vars.onRepeat && !e && this.parent && ce(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), (t || !f) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && bt(this, 1), e || t < 0 && !d || !m && !d || (ce(this, m === p ? "onComplete" : "onReverseComplete", !0), this._prom && !(m < p && this.timeScale() > 0) && this._prom()))
                            }
                        } else It(this, t, e, n);
                        return this
                    }, n.targets = function() {
                        return this._targets
                    }, n.invalidate = function() {
                        return this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this)
                    }, n.kill = function(t, e) {
                        if (void 0 === e && (e = "all"), !t && (!e || "all" === e) && (this._lazy = 0, this.parent)) return le(this);
                        if (this.timeline) {
                            var n = this.timeline.totalDuration();
                            return this.timeline.killTweensOf(t, e, Be && !0 !== Be.vars.overwrite)._first || le(this), this.parent && n !== this.timeline.totalDuration() && Dt(this, this._dur * this.timeline._tDur / n, 0, 1), this
                        }
                        var r, i, o, a, s, c, l, u = this._targets,
                            h = t ? Xt(t) : u,
                            d = this._ptLookup,
                            p = this._pt;
                        if ((!e || "all" === e) && vt(u, h)) return "all" === e && (this._pt = 0), le(this);
                        r = this._op = this._op || [], "all" !== e && (M(e) && (s = {}, rt(e, (function(t) {
                            return s[t] = 1
                        })), e = s), e = Ve(u, e)), l = u.length;
                        while (l--)
                            if (~h.indexOf(u[l]))
                                for (s in i = d[l], "all" === e ? (r[l] = e, a = i, o = {}) : (o = r[l] = r[l] || {}, a = e), a) c = i && i[s], c && ("kill" in c.d && !0 !== c.d.kill(s) || _t(this, c, "_pt"), delete i[s]), "all" !== o && (o[s] = 1);
                        return this._initted && !this._pt && p && le(this), this
                    }, e.to = function(t, n) {
                        return new e(t, n, arguments[2])
                    }, e.from = function(t, n) {
                        return new e(t, at(arguments, 1))
                    }, e.delayedCall = function(t, n, r, i) {
                        return new e(n, 0, {
                            immediateRender: !1,
                            lazy: !1,
                            overwrite: !1,
                            delay: t,
                            onComplete: n,
                            onReverseComplete: n,
                            onCompleteParams: r,
                            onReverseCompleteParams: r,
                            callbackScope: i
                        })
                    }, e.fromTo = function(t, n, r) {
                        return new e(t, at(arguments, 2))
                    }, e.set = function(t, n) {
                        return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n)
                    }, e.killTweensOf = function(t, e, n) {
                        return o.killTweensOf(t, e, n)
                    }, e
                }(ke);
            ht(Ye.prototype, {
                _targets: [],
                _lazy: 0,
                _startAt: 0,
                _op: 0,
                _onInit: 0
            }), rt("staggerTo,staggerFrom,staggerFromTo", (function(t) {
                Ye[t] = function() {
                    var e = new Fe,
                        n = Gt.call(arguments, 0);
                    return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
                }
            }));
            var $e = function(t, e, n) {
                    return t[e] = n
                },
                Ze = function(t, e, n) {
                    return t[e](n)
                },
                Je = function(t, e, n, r) {
                    return t[e](r.fp, n)
                },
                Ke = function(t, e, n) {
                    return t.setAttribute(e, n)
                },
                Qe = function(t, e) {
                    return T(t[e]) ? Ze : E(t[e]) && t.setAttribute ? Ke : $e
                },
                tn = function(t, e) {
                    return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4, e)
                },
                en = function(t, e) {
                    return e.set(e.t, e.p, !!(e.s + e.c * t), e)
                },
                nn = function(t, e) {
                    var n = e._pt,
                        r = "";
                    if (!t && e.b) r = e.b;
                    else if (1 === t && e.e) r = e.e;
                    else {
                        while (n) r = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + r, n = n._next;
                        r += e.c
                    }
                    e.set(e.t, e.p, r, e)
                },
                rn = function(t, e) {
                    var n = e._pt;
                    while (n) n.r(t, n.d), n = n._next
                },
                on = function(t, e, n, r) {
                    var i, o = this._pt;
                    while (o) i = o._next, o.p === r && o.modifier(t, e, n), o = i
                },
                an = function(t) {
                    var e, n, r = this._pt;
                    while (r) n = r._next, r.p === t && !r.op || r.op === t ? _t(this, r, "_pt") : r.dep || (e = 1), r = n;
                    return !e
                },
                sn = function(t, e, n, r) {
                    r.mSet(t, e, r.m.call(r.tween, n, r.mt), r)
                },
                cn = function(t) {
                    var e, n, r, i, o = t._pt;
                    while (o) {
                        e = o._next, n = r;
                        while (n && n.pr > o.pr) n = n._next;
                        (o._prev = n ? n._prev : i) ? o._prev._next = o: r = o, (o._next = n) ? n._prev = o : i = o, o = e
                    }
                    t._pt = r
                },
                ln = function() {
                    function t(t, e, n, r, i, o, a, s, c) {
                        this.t = e, this.s = r, this.c = i, this.p = n, this.r = o || tn, this.d = a || this, this.set = s || $e, this.pr = c || 0, this._next = t, t && (t._prev = this)
                    }
                    var e = t.prototype;
                    return e.modifier = function(t, e, n) {
                        this.mSet = this.mSet || this.set, this.set = sn, this.m = t, this.mt = n, this.tween = e
                    }, t
                }();
            rt(Q + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(t) {
                return X[t] = 1
            })), U.TweenMax = U.TweenLite = Ye, U.TimelineLite = U.TimelineMax = Fe, o = new Fe({
                sortChildren: !1,
                defaults: f,
                autoRemoveChildren: !0,
                id: "root",
                smoothChildTiming: !0
            }), p.stringFilter = _e;
            var un = {
                registerPlugin: function() {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    e.forEach((function(t) {
                        return ue(t)
                    }))
                },
                timeline: function(t) {
                    return new Fe(t)
                },
                getTweensOf: function(t, e) {
                    return o.getTweensOf(t, e)
                },
                getProperty: function(t, e, n, r) {
                    M(t) && (t = Xt(t)[0]);
                    var i = et(t || {}).get,
                        o = n ? ut : lt;
                    return "native" === n && (n = ""), t ? e ? o(($[e] && $[e].get || i)(t, e, n, r)) : function(e, n, r) {
                        return o(($[e] && $[e].get || i)(t, e, n, r))
                    } : t
                },
                quickSetter: function(t, e, n) {
                    if (t = Xt(t), t.length > 1) {
                        var r = t.map((function(t) {
                                return fn.quickSetter(t, e, n)
                            })),
                            i = r.length;
                        return function(t) {
                            var e = i;
                            while (e--) r[e](t)
                        }
                    }
                    t = t[0] || {};
                    var o = $[e],
                        a = et(t),
                        s = a.harness && (a.harness.aliases || {})[e] || e,
                        c = o ? function(e) {
                            var r = new o;
                            h._pt = 0, r.init(t, n ? e + n : e, h, 0, [t]), r.render(1, r), h._pt && rn(1, h)
                        } : a.set(t, s);
                    return o ? c : function(e) {
                        return c(t, s, n ? e + n : e, a, 1)
                    }
                },
                isTweening: function(t) {
                    return o.getTweensOf(t, !0).length > 0
                },
                defaults: function(t) {
                    return t && t.ease && (t.ease = Ce(t.ease, f.ease)), ft(f, t || {})
                },
                config: function(t) {
                    return ft(p, t || {})
                },
                registerEffect: function(t) {
                    var e = t.name,
                        n = t.effect,
                        r = t.plugins,
                        i = t.defaults,
                        o = t.extendTimeline;
                    (r || "").split(",").forEach((function(t) {
                        return t && !$[t] && !U[t] && G(e + " effect requires " + t + " plugin.")
                    })), Z[e] = function(t, e, r) {
                        return n(Xt(t), ht(e || {}, i), r)
                    }, o && (Fe.prototype[e] = function(t, n, r) {
                        return this.add(Z[e](t, A(n) ? n : (r = n) && {}, this), r)
                    })
                },
                registerEase: function(t, e) {
                    we[t] = Ce(e)
                },
                parseEase: function(t, e) {
                    return arguments.length ? Ce(t, e) : we
                },
                getById: function(t) {
                    return o.getById(t)
                },
                exportRoot: function(t, e) {
                    void 0 === t && (t = {});
                    var n, r, i = new Fe(t);
                    i.smoothChildTiming = L(t.smoothChildTiming), o.remove(i), i._dp = 0, i._time = i._tTime = o._time, n = o._first;
                    while (n) r = n._next, !e && !n._dur && n instanceof Ye && n.vars.onComplete === n._targets[0] || Ct(i, n, n._start - n._delay), n = r;
                    return Ct(o, i, 0), i
                },
                utils: {
                    wrap: ne,
                    wrapYoyo: re,
                    distribute: Yt,
                    random: Jt,
                    snap: Zt,
                    normalize: te,
                    getUnit: zt,
                    clamp: jt,
                    splitColor: fe,
                    toArray: Xt,
                    mapRange: oe,
                    pipe: Kt,
                    unitize: Qt,
                    interpolate: ae,
                    shuffle: qt
                },
                install: z,
                effects: Z,
                ticker: be,
                updateRoot: Fe.updateRoot,
                plugins: $,
                globalTimeline: o,
                core: {
                    PropTween: ln,
                    globals: V,
                    Tween: Ye,
                    Timeline: Fe,
                    Animation: ke,
                    getCache: et,
                    _removeLinkedListItem: _t
                }
            };
            rt("to,from,fromTo,delayedCall,set,killTweensOf", (function(t) {
                return un[t] = Ye[t]
            })), be.add(Fe.updateRoot), h = un.to({}, {
                duration: 0
            });
            var hn = function(t, e) {
                    var n = t._pt;
                    while (n && n.p !== e && n.op !== e && n.fp !== e) n = n._next;
                    return n
                },
                dn = function(t, e) {
                    var n, r, i, o = t._targets;
                    for (n in e) {
                        r = o.length;
                        while (r--) i = t._ptLookup[r][n], i && (i = i.d) && (i._pt && (i = hn(i, n)), i && i.modifier && i.modifier(e[n], t, o[r], n))
                    }
                },
                pn = function(t, e) {
                    return {
                        name: t,
                        rawVars: 1,
                        init: function(t, n, r) {
                            r._onInit = function(t) {
                                var r, i;
                                if (M(n) && (r = {}, rt(n, (function(t) {
                                        return r[t] = 1
                                    })), n = r), e) {
                                    for (i in r = {}, n) r[i] = e(n[i]);
                                    n = r
                                }
                                dn(t, n)
                            }
                        }
                    }
                },
                fn = un.registerPlugin({
                    name: "attr",
                    init: function(t, e, n, r, i) {
                        var o, a;
                        for (o in e) a = this.add(t, "setAttribute", (t.getAttribute(o) || 0) + "", e[o], r, i, 0, 0, o), a && (a.op = o), this._props.push(o)
                    }
                }, {
                    name: "endArray",
                    init: function(t, e) {
                        var n = e.length;
                        while (n--) this.add(t, n, t[n] || 0, e[n])
                    }
                }, pn("roundProps", $t), pn("modifiers"), pn("snap", Zt)) || un;
            Ye.version = Fe.version = fn.version = "3.5.1", l = 1, R() && xe();
            we.Power0;
            var mn = we.Power1;
            we.Power2, we.Power3, we.Power4, we.Linear, we.Quad, we.Cubic, we.Quart, we.Quint, we.Strong, we.Elastic, we.Back, we.SteppedEase, we.Bounce, we.Sine, we.Expo, we.Circ
        },
        a630: function(t, e, n) {
            var r = n("23e7"),
                i = n("4df4"),
                o = n("1c7e"),
                a = !o((function(t) {
                    Array.from(t)
                }));
            r({
                target: "Array",
                stat: !0,
                forced: a
            }, {
                from: i
            })
        },
        a640: function(t, e, n) {
            "use strict";
            var r = n("d039");
            t.exports = function(t, e) {
                var n = [][t];
                return !!n && r((function() {
                    n.call(null, e || function() {
                        throw 1
                    }, 1)
                }))
            }
        },
        a691: function(t, e) {
            var n = Math.ceil,
                r = Math.floor;
            t.exports = function(t) {
                return isNaN(t = +t) ? 0 : (t > 0 ? r : n)(t)
            }
        },
        a79d: function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("c430"),
                o = n("fea9"),
                a = n("d039"),
                s = n("d066"),
                c = n("4840"),
                l = n("cdf9"),
                u = n("6eeb"),
                h = !!o && a((function() {
                    o.prototype["finally"].call({
                        then: function() {}
                    }, (function() {}))
                }));
            r({
                target: "Promise",
                proto: !0,
                real: !0,
                forced: h
            }, {
                finally: function(t) {
                    var e = c(this, s("Promise")),
                        n = "function" == typeof t;
                    return this.then(n ? function(n) {
                        return l(e, t()).then((function() {
                            return n
                        }))
                    } : t, n ? function(n) {
                        return l(e, t()).then((function() {
                            throw n
                        }))
                    } : t)
                }
            }), i || "function" != typeof o || o.prototype["finally"] || u(o.prototype, "finally", s("Promise").prototype["finally"])
        },
        a925: function(t, e, n) {
            "use strict";
            /*!
             * vue-i18n v8.20.0 
             * (c) 2020 kazuya kawaguchi
             * Released under the MIT License.
             */
            var r = ["style", "currency", "currencyDisplay", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "localeMatcher", "formatMatcher", "unit"];

            function i(t, e) {
                "undefined" !== typeof console && (console.warn("[vue-i18n] " + t), e && console.warn(e.stack))
            }

            function o(t, e) {
                "undefined" !== typeof console && (console.error("[vue-i18n] " + t), e && console.error(e.stack))
            }
            var a = Array.isArray;

            function s(t) {
                return null !== t && "object" === typeof t
            }

            function c(t) {
                return "boolean" === typeof t
            }

            function l(t) {
                return "string" === typeof t
            }
            var u = Object.prototype.toString,
                h = "[object Object]";

            function d(t) {
                return u.call(t) === h
            }

            function p(t) {
                return null === t || void 0 === t
            }

            function f() {
                var t = [],
                    e = arguments.length;
                while (e--) t[e] = arguments[e];
                var n = null,
                    r = null;
                return 1 === t.length ? s(t[0]) || Array.isArray(t[0]) ? r = t[0] : "string" === typeof t[0] && (n = t[0]) : 2 === t.length && ("string" === typeof t[0] && (n = t[0]), (s(t[1]) || Array.isArray(t[1])) && (r = t[1])), {
                    locale: n,
                    params: r
                }
            }

            function m(t) {
                return JSON.parse(JSON.stringify(t))
            }

            function g(t, e) {
                if (t.length) {
                    var n = t.indexOf(e);
                    if (n > -1) return t.splice(n, 1)
                }
            }

            function v(t, e) {
                return !!~t.indexOf(e)
            }
            var y = Object.prototype.hasOwnProperty;

            function _(t, e) {
                return y.call(t, e)
            }

            function b(t) {
                for (var e = arguments, n = Object(t), r = 1; r < arguments.length; r++) {
                    var i = e[r];
                    if (void 0 !== i && null !== i) {
                        var o = void 0;
                        for (o in i) _(i, o) && (s(i[o]) ? n[o] = b(n[o], i[o]) : n[o] = i[o])
                    }
                }
                return n
            }

            function x(t, e) {
                if (t === e) return !0;
                var n = s(t),
                    r = s(e);
                if (!n || !r) return !n && !r && String(t) === String(e);
                try {
                    var i = Array.isArray(t),
                        o = Array.isArray(e);
                    if (i && o) return t.length === e.length && t.every((function(t, n) {
                        return x(t, e[n])
                    }));
                    if (i || o) return !1;
                    var a = Object.keys(t),
                        c = Object.keys(e);
                    return a.length === c.length && a.every((function(n) {
                        return x(t[n], e[n])
                    }))
                } catch (l) {
                    return !1
                }
            }

            function w(t) {
                t.prototype.hasOwnProperty("$i18n") || Object.defineProperty(t.prototype, "$i18n", {
                    get: function() {
                        return this._i18n
                    }
                }), t.prototype.$t = function(t) {
                    var e = [],
                        n = arguments.length - 1;
                    while (n-- > 0) e[n] = arguments[n + 1];
                    var r = this.$i18n;
                    return r._t.apply(r, [t, r.locale, r._getMessages(), this].concat(e))
                }, t.prototype.$tc = function(t, e) {
                    var n = [],
                        r = arguments.length - 2;
                    while (r-- > 0) n[r] = arguments[r + 2];
                    var i = this.$i18n;
                    return i._tc.apply(i, [t, i.locale, i._getMessages(), this, e].concat(n))
                }, t.prototype.$te = function(t, e) {
                    var n = this.$i18n;
                    return n._te(t, n.locale, n._getMessages(), e)
                }, t.prototype.$d = function(t) {
                    var e, n = [],
                        r = arguments.length - 1;
                    while (r-- > 0) n[r] = arguments[r + 1];
                    return (e = this.$i18n).d.apply(e, [t].concat(n))
                }, t.prototype.$n = function(t) {
                    var e, n = [],
                        r = arguments.length - 1;
                    while (r-- > 0) n[r] = arguments[r + 1];
                    return (e = this.$i18n).n.apply(e, [t].concat(n))
                }
            }
            var M = {
                    beforeCreate: function() {
                        var t = this.$options;
                        if (t.i18n = t.i18n || (t.__i18n ? {} : null), t.i18n)
                            if (t.i18n instanceof xt) {
                                if (t.__i18n) try {
                                    var e = {};
                                    t.__i18n.forEach((function(t) {
                                        e = b(e, JSON.parse(t))
                                    })), Object.keys(e).forEach((function(n) {
                                        t.i18n.mergeLocaleMessage(n, e[n])
                                    }))
                                } catch (a) {
                                    0
                                }
                                this._i18n = t.i18n, this._i18nWatcher = this._i18n.watchI18nData()
                            } else if (d(t.i18n)) {
                            var n = this.$root && this.$root.$i18n && this.$root.$i18n instanceof xt ? this.$root.$i18n : null;
                            if (n && (t.i18n.root = this.$root, t.i18n.formatter = n.formatter, t.i18n.fallbackLocale = n.fallbackLocale, t.i18n.formatFallbackMessages = n.formatFallbackMessages, t.i18n.silentTranslationWarn = n.silentTranslationWarn, t.i18n.silentFallbackWarn = n.silentFallbackWarn, t.i18n.pluralizationRules = n.pluralizationRules, t.i18n.preserveDirectiveContent = n.preserveDirectiveContent), t.__i18n) try {
                                var r = {};
                                t.__i18n.forEach((function(t) {
                                    r = b(r, JSON.parse(t))
                                })), t.i18n.messages = r
                            } catch (a) {
                                0
                            }
                            var i = t.i18n,
                                o = i.sharedMessages;
                            o && d(o) && (t.i18n.messages = b(t.i18n.messages, o)), this._i18n = new xt(t.i18n), this._i18nWatcher = this._i18n.watchI18nData(), (void 0 === t.i18n.sync || t.i18n.sync) && (this._localeWatcher = this.$i18n.watchLocale()), n && n.onComponentInstanceCreated(this._i18n)
                        } else 0;
                        else this.$root && this.$root.$i18n && this.$root.$i18n instanceof xt ? this._i18n = this.$root.$i18n : t.parent && t.parent.$i18n && t.parent.$i18n instanceof xt && (this._i18n = t.parent.$i18n)
                    },
                    beforeMount: function() {
                        var t = this.$options;
                        t.i18n = t.i18n || (t.__i18n ? {} : null), t.i18n ? (t.i18n instanceof xt || d(t.i18n)) && (this._i18n.subscribeDataChanging(this), this._subscribing = !0) : (this.$root && this.$root.$i18n && this.$root.$i18n instanceof xt || t.parent && t.parent.$i18n && t.parent.$i18n instanceof xt) && (this._i18n.subscribeDataChanging(this), this._subscribing = !0)
                    },
                    beforeDestroy: function() {
                        if (this._i18n) {
                            var t = this;
                            this.$nextTick((function() {
                                t._subscribing && (t._i18n.unsubscribeDataChanging(t), delete t._subscribing), t._i18nWatcher && (t._i18nWatcher(), t._i18n.destroyVM(), delete t._i18nWatcher), t._localeWatcher && (t._localeWatcher(), delete t._localeWatcher)
                            }))
                        }
                    }
                },
                T = {
                    name: "i18n",
                    functional: !0,
                    props: {
                        tag: {
                            type: [String, Boolean, Object],
                            default: "span"
                        },
                        path: {
                            type: String,
                            required: !0
                        },
                        locale: {
                            type: String
                        },
                        places: {
                            type: [Array, Object]
                        }
                    },
                    render: function(t, e) {
                        var n = e.data,
                            r = e.parent,
                            i = e.props,
                            o = e.slots,
                            a = r.$i18n;
                        if (a) {
                            var s = i.path,
                                c = i.locale,
                                l = i.places,
                                u = o(),
                                h = a.i(s, c, S(u) || l ? E(u.default, l) : u),
                                d = i.tag && !0 !== i.tag || !1 === i.tag ? i.tag : "span";
                            return d ? t(d, n, h) : h
                        }
                    }
                };

            function S(t) {
                var e;
                for (e in t)
                    if ("default" !== e) return !1;
                return Boolean(e)
            }

            function E(t, e) {
                var n = e ? A(e) : {};
                if (!t) return n;
                t = t.filter((function(t) {
                    return t.tag || "" !== t.text.trim()
                }));
                var r = t.every(C);
                return t.reduce(r ? L : R, n)
            }

            function A(t) {
                return Array.isArray(t) ? t.reduce(R, {}) : Object.assign({}, t)
            }

            function L(t, e) {
                return e.data && e.data.attrs && e.data.attrs.place && (t[e.data.attrs.place] = e), t
            }

            function R(t, e, n) {
                return t[n] = e, t
            }

            function C(t) {
                return Boolean(t.data && t.data.attrs && t.data.attrs.place)
            }
            var O, P = {
                name: "i18n-n",
                functional: !0,
                props: {
                    tag: {
                        type: [String, Boolean, Object],
                        default: "span"
                    },
                    value: {
                        type: Number,
                        required: !0
                    },
                    format: {
                        type: [String, Object]
                    },
                    locale: {
                        type: String
                    }
                },
                render: function(t, e) {
                    var n = e.props,
                        i = e.parent,
                        o = e.data,
                        a = i.$i18n;
                    if (!a) return null;
                    var c = null,
                        u = null;
                    l(n.format) ? c = n.format : s(n.format) && (n.format.key && (c = n.format.key), u = Object.keys(n.format).reduce((function(t, e) {
                        var i;
                        return v(r, e) ? Object.assign({}, t, (i = {}, i[e] = n.format[e], i)) : t
                    }), null));
                    var h = n.locale || a.locale,
                        d = a._ntp(n.value, h, c, u),
                        p = d.map((function(t, e) {
                            var n, r = o.scopedSlots && o.scopedSlots[t.type];
                            return r ? r((n = {}, n[t.type] = t.value, n.index = e, n.parts = d, n)) : t.value
                        })),
                        f = n.tag && !0 !== n.tag || !1 === n.tag ? n.tag : "span";
                    return f ? t(f, {
                        attrs: o.attrs,
                        class: o["class"],
                        staticClass: o.staticClass
                    }, p) : p
                }
            };

            function I(t, e, n) {
                k(t, n) && B(t, e, n)
            }

            function N(t, e, n, r) {
                if (k(t, n)) {
                    var i = n.context.$i18n;
                    F(t, n) && x(e.value, e.oldValue) && x(t._localeMessage, i.getLocaleMessage(i.locale)) || B(t, e, n)
                }
            }

            function D(t, e, n, r) {
                var o = n.context;
                if (o) {
                    var a = n.context.$i18n || {};
                    e.modifiers.preserve || a.preserveDirectiveContent || (t.textContent = ""), t._vt = void 0, delete t["_vt"], t._locale = void 0, delete t["_locale"], t._localeMessage = void 0, delete t["_localeMessage"]
                } else i("Vue instance does not exists in VNode context")
            }

            function k(t, e) {
                var n = e.context;
                return n ? !!n.$i18n || (i("VueI18n instance does not exists in Vue instance"), !1) : (i("Vue instance does not exists in VNode context"), !1)
            }

            function F(t, e) {
                var n = e.context;
                return t._locale === n.$i18n.locale
            }

            function B(t, e, n) {
                var r, o, a = e.value,
                    s = U(a),
                    c = s.path,
                    l = s.locale,
                    u = s.args,
                    h = s.choice;
                if (c || l || u)
                    if (c) {
                        var d = n.context;
                        t._vt = t.textContent = null != h ? (r = d.$i18n).tc.apply(r, [c, h].concat(H(l, u))) : (o = d.$i18n).t.apply(o, [c].concat(H(l, u))), t._locale = d.$i18n.locale, t._localeMessage = d.$i18n.getLocaleMessage(d.$i18n.locale)
                    } else i("`path` is required in v-t directive");
                else i("value type not supported")
            }

            function U(t) {
                var e, n, r, i;
                return l(t) ? e = t : d(t) && (e = t.path, n = t.locale, r = t.args, i = t.choice), {
                    path: e,
                    locale: n,
                    args: r,
                    choice: i
                }
            }

            function H(t, e) {
                var n = [];
                return t && n.push(t), e && (Array.isArray(e) || d(e)) && n.push(e), n
            }

            function z(t) {
                z.installed = !0, O = t;
                O.version && Number(O.version.split(".")[0]);
                w(O), O.mixin(M), O.directive("t", {
                    bind: I,
                    update: N,
                    unbind: D
                }), O.component(T.name, T), O.component(P.name, P);
                var e = O.config.optionMergeStrategies;
                e.i18n = function(t, e) {
                    return void 0 === e ? t : e
                }
            }
            var j = function() {
                this._caches = Object.create(null)
            };
            j.prototype.interpolate = function(t, e) {
                if (!e) return [t];
                var n = this._caches[t];
                return n || (n = W(t), this._caches[t] = n), X(n, e)
            };
            var G = /^(?:\d)+/,
                V = /^(?:\w)+/;

            function W(t) {
                var e = [],
                    n = 0,
                    r = "";
                while (n < t.length) {
                    var i = t[n++];
                    if ("{" === i) {
                        r && e.push({
                            type: "text",
                            value: r
                        }), r = "";
                        var o = "";
                        i = t[n++];
                        while (void 0 !== i && "}" !== i) o += i, i = t[n++];
                        var a = "}" === i,
                            s = G.test(o) ? "list" : a && V.test(o) ? "named" : "unknown";
                        e.push({
                            value: o,
                            type: s
                        })
                    } else "%" === i ? "{" !== t[n] && (r += i) : r += i
                }
                return r && e.push({
                    type: "text",
                    value: r
                }), e
            }

            function X(t, e) {
                var n = [],
                    r = 0,
                    i = Array.isArray(e) ? "list" : s(e) ? "named" : "unknown";
                if ("unknown" === i) return n;
                while (r < t.length) {
                    var o = t[r];
                    switch (o.type) {
                        case "text":
                            n.push(o.value);
                            break;
                        case "list":
                            n.push(e[parseInt(o.value, 10)]);
                            break;
                        case "named":
                            "named" === i && n.push(e[o.value]);
                            break;
                        case "unknown":
                            0;
                            break
                    }
                    r++
                }
                return n
            }
            var q = 0,
                Y = 1,
                $ = 2,
                Z = 3,
                J = 0,
                K = 1,
                Q = 2,
                tt = 3,
                et = 4,
                nt = 5,
                rt = 6,
                it = 7,
                ot = 8,
                at = [];
            at[J] = {
                ws: [J],
                ident: [tt, q],
                "[": [et],
                eof: [it]
            }, at[K] = {
                ws: [K],
                ".": [Q],
                "[": [et],
                eof: [it]
            }, at[Q] = {
                ws: [Q],
                ident: [tt, q],
                0: [tt, q],
                number: [tt, q]
            }, at[tt] = {
                ident: [tt, q],
                0: [tt, q],
                number: [tt, q],
                ws: [K, Y],
                ".": [Q, Y],
                "[": [et, Y],
                eof: [it, Y]
            }, at[et] = {
                "'": [nt, q],
                '"': [rt, q],
                "[": [et, $],
                "]": [K, Z],
                eof: ot,
                else: [et, q]
            }, at[nt] = {
                "'": [et, q],
                eof: ot,
                else: [nt, q]
            }, at[rt] = {
                '"': [et, q],
                eof: ot,
                else: [rt, q]
            };
            var st = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;

            function ct(t) {
                return st.test(t)
            }

            function lt(t) {
                var e = t.charCodeAt(0),
                    n = t.charCodeAt(t.length - 1);
                return e !== n || 34 !== e && 39 !== e ? t : t.slice(1, -1)
            }

            function ut(t) {
                if (void 0 === t || null === t) return "eof";
                var e = t.charCodeAt(0);
                switch (e) {
                    case 91:
                    case 93:
                    case 46:
                    case 34:
                    case 39:
                        return t;
                    case 95:
                    case 36:
                    case 45:
                        return "ident";
                    case 9:
                    case 10:
                    case 13:
                    case 160:
                    case 65279:
                    case 8232:
                    case 8233:
                        return "ws"
                }
                return "ident"
            }

            function ht(t) {
                var e = t.trim();
                return ("0" !== t.charAt(0) || !isNaN(t)) && (ct(e) ? lt(e) : "*" + e)
            }

            function dt(t) {
                var e, n, r, i, o, a, s, c = [],
                    l = -1,
                    u = J,
                    h = 0,
                    d = [];

                function p() {
                    var e = t[l + 1];
                    if (u === nt && "'" === e || u === rt && '"' === e) return l++, r = "\\" + e, d[q](), !0
                }
                d[Y] = function() {
                    void 0 !== n && (c.push(n), n = void 0)
                }, d[q] = function() {
                    void 0 === n ? n = r : n += r
                }, d[$] = function() {
                    d[q](), h++
                }, d[Z] = function() {
                    if (h > 0) h--, u = et, d[q]();
                    else {
                        if (h = 0, void 0 === n) return !1;
                        if (n = ht(n), !1 === n) return !1;
                        d[Y]()
                    }
                };
                while (null !== u)
                    if (l++, e = t[l], "\\" !== e || !p()) {
                        if (i = ut(e), s = at[u], o = s[i] || s["else"] || ot, o === ot) return;
                        if (u = o[0], a = d[o[1]], a && (r = o[2], r = void 0 === r ? e : r, !1 === a())) return;
                        if (u === it) return c
                    }
            }
            var pt = function() {
                this._cache = Object.create(null)
            };
            pt.prototype.parsePath = function(t) {
                var e = this._cache[t];
                return e || (e = dt(t), e && (this._cache[t] = e)), e || []
            }, pt.prototype.getPathValue = function(t, e) {
                if (!s(t)) return null;
                var n = this.parsePath(e);
                if (0 === n.length) return null;
                var r = n.length,
                    i = t,
                    o = 0;
                while (o < r) {
                    var a = i[n[o]];
                    if (void 0 === a) return null;
                    i = a, o++
                }
                return i
            };
            var ft, mt = /<\/?[\w\s="/.':;#-\/]+>/,
                gt = /(?:@(?:\.[a-z]+)?:(?:[\w\-_|.]+|\([\w\-_|.]+\)))/g,
                vt = /^@(?:\.([a-z]+))?:/,
                yt = /[()]/g,
                _t = {
                    upper: function(t) {
                        return t.toLocaleUpperCase()
                    },
                    lower: function(t) {
                        return t.toLocaleLowerCase()
                    },
                    capitalize: function(t) {
                        return "" + t.charAt(0).toLocaleUpperCase() + t.substr(1)
                    }
                },
                bt = new j,
                xt = function(t) {
                    var e = this;
                    void 0 === t && (t = {}), !O && "undefined" !== typeof window && window.Vue && z(window.Vue);
                    var n = t.locale || "en-US",
                        r = !1 !== t.fallbackLocale && (t.fallbackLocale || "en-US"),
                        i = t.messages || {},
                        o = t.dateTimeFormats || {},
                        a = t.numberFormats || {};
                    this._vm = null, this._formatter = t.formatter || bt, this._modifiers = t.modifiers || {}, this._missing = t.missing || null, this._root = t.root || null, this._sync = void 0 === t.sync || !!t.sync, this._fallbackRoot = void 0 === t.fallbackRoot || !!t.fallbackRoot, this._formatFallbackMessages = void 0 !== t.formatFallbackMessages && !!t.formatFallbackMessages, this._silentTranslationWarn = void 0 !== t.silentTranslationWarn && t.silentTranslationWarn, this._silentFallbackWarn = void 0 !== t.silentFallbackWarn && !!t.silentFallbackWarn, this._dateTimeFormatters = {}, this._numberFormatters = {}, this._path = new pt, this._dataListeners = [], this._componentInstanceCreatedListener = t.componentInstanceCreatedListener || null, this._preserveDirectiveContent = void 0 !== t.preserveDirectiveContent && !!t.preserveDirectiveContent, this.pluralizationRules = t.pluralizationRules || {}, this._warnHtmlInMessage = t.warnHtmlInMessage || "off", this._postTranslation = t.postTranslation || null, this.getChoiceIndex = function(t, n) {
                        var r = Object.getPrototypeOf(e);
                        if (r && r.getChoiceIndex) {
                            var i = r.getChoiceIndex;
                            return i.call(e, t, n)
                        }
                        var o = function(t, e) {
                            return t = Math.abs(t), 2 === e ? t ? t > 1 ? 1 : 0 : 1 : t ? Math.min(t, 2) : 0
                        };
                        return e.locale in e.pluralizationRules ? e.pluralizationRules[e.locale].apply(e, [t, n]) : o(t, n)
                    }, this._exist = function(t, n) {
                        return !(!t || !n) && (!p(e._path.getPathValue(t, n)) || !!t[n])
                    }, "warn" !== this._warnHtmlInMessage && "error" !== this._warnHtmlInMessage || Object.keys(i).forEach((function(t) {
                        e._checkLocaleMessage(t, e._warnHtmlInMessage, i[t])
                    })), this._initVM({
                        locale: n,
                        fallbackLocale: r,
                        messages: i,
                        dateTimeFormats: o,
                        numberFormats: a
                    })
                },
                wt = {
                    vm: {
                        configurable: !0
                    },
                    messages: {
                        configurable: !0
                    },
                    dateTimeFormats: {
                        configurable: !0
                    },
                    numberFormats: {
                        configurable: !0
                    },
                    availableLocales: {
                        configurable: !0
                    },
                    locale: {
                        configurable: !0
                    },
                    fallbackLocale: {
                        configurable: !0
                    },
                    formatFallbackMessages: {
                        configurable: !0
                    },
                    missing: {
                        configurable: !0
                    },
                    formatter: {
                        configurable: !0
                    },
                    silentTranslationWarn: {
                        configurable: !0
                    },
                    silentFallbackWarn: {
                        configurable: !0
                    },
                    preserveDirectiveContent: {
                        configurable: !0
                    },
                    warnHtmlInMessage: {
                        configurable: !0
                    },
                    postTranslation: {
                        configurable: !0
                    }
                };
            xt.prototype._checkLocaleMessage = function(t, e, n) {
                var r = [],
                    a = function(t, e, n, r) {
                        if (d(n)) Object.keys(n).forEach((function(i) {
                            var o = n[i];
                            d(o) ? (r.push(i), r.push("."), a(t, e, o, r), r.pop(), r.pop()) : (r.push(i), a(t, e, o, r), r.pop())
                        }));
                        else if (Array.isArray(n)) n.forEach((function(n, i) {
                            d(n) ? (r.push("[" + i + "]"), r.push("."), a(t, e, n, r), r.pop(), r.pop()) : (r.push("[" + i + "]"), a(t, e, n, r), r.pop())
                        }));
                        else if (l(n)) {
                            var s = mt.test(n);
                            if (s) {
                                var c = "Detected HTML in message '" + n + "' of keypath '" + r.join("") + "' at '" + e + "'. Consider component interpolation with '<i18n>' to avoid XSS. See https://bit.ly/2ZqJzkp";
                                "warn" === t ? i(c) : "error" === t && o(c)
                            }
                        }
                    };
                a(e, t, n, r)
            }, xt.prototype._initVM = function(t) {
                var e = O.config.silent;
                O.config.silent = !0, this._vm = new O({
                    data: t
                }), O.config.silent = e
            }, xt.prototype.destroyVM = function() {
                this._vm.$destroy()
            }, xt.prototype.subscribeDataChanging = function(t) {
                this._dataListeners.push(t)
            }, xt.prototype.unsubscribeDataChanging = function(t) {
                g(this._dataListeners, t)
            }, xt.prototype.watchI18nData = function() {
                var t = this;
                return this._vm.$watch("$data", (function() {
                    var e = t._dataListeners.length;
                    while (e--) O.nextTick((function() {
                        t._dataListeners[e] && t._dataListeners[e].$forceUpdate()
                    }))
                }), {
                    deep: !0
                })
            }, xt.prototype.watchLocale = function() {
                if (!this._sync || !this._root) return null;
                var t = this._vm;
                return this._root.$i18n.vm.$watch("locale", (function(e) {
                    t.$set(t, "locale", e), t.$forceUpdate()
                }), {
                    immediate: !0
                })
            }, xt.prototype.onComponentInstanceCreated = function(t) {
                this._componentInstanceCreatedListener && this._componentInstanceCreatedListener(t, this)
            }, wt.vm.get = function() {
                return this._vm
            }, wt.messages.get = function() {
                return m(this._getMessages())
            }, wt.dateTimeFormats.get = function() {
                return m(this._getDateTimeFormats())
            }, wt.numberFormats.get = function() {
                return m(this._getNumberFormats())
            }, wt.availableLocales.get = function() {
                return Object.keys(this.messages).sort()
            }, wt.locale.get = function() {
                return this._vm.locale
            }, wt.locale.set = function(t) {
                this._vm.$set(this._vm, "locale", t)
            }, wt.fallbackLocale.get = function() {
                return this._vm.fallbackLocale
            }, wt.fallbackLocale.set = function(t) {
                this._localeChainCache = {}, this._vm.$set(this._vm, "fallbackLocale", t)
            }, wt.formatFallbackMessages.get = function() {
                return this._formatFallbackMessages
            }, wt.formatFallbackMessages.set = function(t) {
                this._formatFallbackMessages = t
            }, wt.missing.get = function() {
                return this._missing
            }, wt.missing.set = function(t) {
                this._missing = t
            }, wt.formatter.get = function() {
                return this._formatter
            }, wt.formatter.set = function(t) {
                this._formatter = t
            }, wt.silentTranslationWarn.get = function() {
                return this._silentTranslationWarn
            }, wt.silentTranslationWarn.set = function(t) {
                this._silentTranslationWarn = t
            }, wt.silentFallbackWarn.get = function() {
                return this._silentFallbackWarn
            }, wt.silentFallbackWarn.set = function(t) {
                this._silentFallbackWarn = t
            }, wt.preserveDirectiveContent.get = function() {
                return this._preserveDirectiveContent
            }, wt.preserveDirectiveContent.set = function(t) {
                this._preserveDirectiveContent = t
            }, wt.warnHtmlInMessage.get = function() {
                return this._warnHtmlInMessage
            }, wt.warnHtmlInMessage.set = function(t) {
                var e = this,
                    n = this._warnHtmlInMessage;
                if (this._warnHtmlInMessage = t, n !== t && ("warn" === t || "error" === t)) {
                    var r = this._getMessages();
                    Object.keys(r).forEach((function(t) {
                        e._checkLocaleMessage(t, e._warnHtmlInMessage, r[t])
                    }))
                }
            }, wt.postTranslation.get = function() {
                return this._postTranslation
            }, wt.postTranslation.set = function(t) {
                this._postTranslation = t
            }, xt.prototype._getMessages = function() {
                return this._vm.messages
            }, xt.prototype._getDateTimeFormats = function() {
                return this._vm.dateTimeFormats
            }, xt.prototype._getNumberFormats = function() {
                return this._vm.numberFormats
            }, xt.prototype._warnDefault = function(t, e, n, r, i, o) {
                if (!p(n)) return n;
                if (this._missing) {
                    var a = this._missing.apply(null, [t, e, r, i]);
                    if (l(a)) return a
                } else 0;
                if (this._formatFallbackMessages) {
                    var s = f.apply(void 0, i);
                    return this._render(e, o, s.params, e)
                }
                return e
            }, xt.prototype._isFallbackRoot = function(t) {
                return !t && !p(this._root) && this._fallbackRoot
            }, xt.prototype._isSilentFallbackWarn = function(t) {
                return this._silentFallbackWarn instanceof RegExp ? this._silentFallbackWarn.test(t) : this._silentFallbackWarn
            }, xt.prototype._isSilentFallback = function(t, e) {
                return this._isSilentFallbackWarn(e) && (this._isFallbackRoot() || t !== this.fallbackLocale)
            }, xt.prototype._isSilentTranslationWarn = function(t) {
                return this._silentTranslationWarn instanceof RegExp ? this._silentTranslationWarn.test(t) : this._silentTranslationWarn
            }, xt.prototype._interpolate = function(t, e, n, r, i, o, a) {
                if (!e) return null;
                var s, c = this._path.getPathValue(e, n);
                if (Array.isArray(c) || d(c)) return c;
                if (p(c)) {
                    if (!d(e)) return null;
                    if (s = e[n], !l(s)) return null
                } else {
                    if (!l(c)) return null;
                    s = c
                }
                return (s.indexOf("@:") >= 0 || s.indexOf("@.") >= 0) && (s = this._link(t, e, s, r, "raw", o, a)), this._render(s, i, o, n)
            }, xt.prototype._link = function(t, e, n, r, i, o, a) {
                var s = n,
                    c = s.match(gt);
                for (var l in c)
                    if (c.hasOwnProperty(l)) {
                        var u = c[l],
                            h = u.match(vt),
                            d = h[0],
                            p = h[1],
                            f = u.replace(d, "").replace(yt, "");
                        if (v(a, f)) return s;
                        a.push(f);
                        var m = this._interpolate(t, e, f, r, "raw" === i ? "string" : i, "raw" === i ? void 0 : o, a);
                        if (this._isFallbackRoot(m)) {
                            if (!this._root) throw Error("unexpected error");
                            var g = this._root.$i18n;
                            m = g._translate(g._getMessages(), g.locale, g.fallbackLocale, f, r, i, o)
                        }
                        m = this._warnDefault(t, f, m, r, Array.isArray(o) ? o : [o], i), this._modifiers.hasOwnProperty(p) ? m = this._modifiers[p](m) : _t.hasOwnProperty(p) && (m = _t[p](m)), a.pop(), s = m ? s.replace(u, m) : s
                    }
                return s
            }, xt.prototype._render = function(t, e, n, r) {
                var i = this._formatter.interpolate(t, n, r);
                return i || (i = bt.interpolate(t, n, r)), "string" !== e || l(i) ? i : i.join("")
            }, xt.prototype._appendItemToChain = function(t, e, n) {
                var r = !1;
                return v(t, e) || (r = !0, e && (r = "!" !== e[e.length - 1], e = e.replace(/!/g, ""), t.push(e), n && n[e] && (r = n[e]))), r
            }, xt.prototype._appendLocaleToChain = function(t, e, n) {
                var r, i = e.split("-");
                do {
                    var o = i.join("-");
                    r = this._appendItemToChain(t, o, n), i.splice(-1, 1)
                } while (i.length && !0 === r);
                return r
            }, xt.prototype._appendBlockToChain = function(t, e, n) {
                for (var r = !0, i = 0; i < e.length && c(r); i++) {
                    var o = e[i];
                    l(o) && (r = this._appendLocaleToChain(t, o, n))
                }
                return r
            }, xt.prototype._getLocaleChain = function(t, e) {
                if ("" === t) return [];
                this._localeChainCache || (this._localeChainCache = {});
                var n = this._localeChainCache[t];
                if (!n) {
                    e || (e = this.fallbackLocale), n = [];
                    var r, i = [t];
                    while (a(i)) i = this._appendBlockToChain(n, i, e);
                    r = a(e) ? e : s(e) ? e["default"] ? e["default"] : null : e, i = l(r) ? [r] : r, i && this._appendBlockToChain(n, i, null), this._localeChainCache[t] = n
                }
                return n
            }, xt.prototype._translate = function(t, e, n, r, i, o, a) {
                for (var s, c = this._getLocaleChain(e, n), l = 0; l < c.length; l++) {
                    var u = c[l];
                    if (s = this._interpolate(u, t[u], r, i, o, a, [r]), !p(s)) return s
                }
                return null
            }, xt.prototype._t = function(t, e, n, r) {
                var i, o = [],
                    a = arguments.length - 4;
                while (a-- > 0) o[a] = arguments[a + 4];
                if (!t) return "";
                var s = f.apply(void 0, o),
                    c = s.locale || e,
                    l = this._translate(n, c, this.fallbackLocale, t, r, "string", s.params);
                if (this._isFallbackRoot(l)) {
                    if (!this._root) throw Error("unexpected error");
                    return (i = this._root).$t.apply(i, [t].concat(o))
                }
                return l = this._warnDefault(c, t, l, r, o, "string"), this._postTranslation && null !== l && void 0 !== l && (l = this._postTranslation(l, t)), l
            }, xt.prototype.t = function(t) {
                var e, n = [],
                    r = arguments.length - 1;
                while (r-- > 0) n[r] = arguments[r + 1];
                return (e = this)._t.apply(e, [t, this.locale, this._getMessages(), null].concat(n))
            }, xt.prototype._i = function(t, e, n, r, i) {
                var o = this._translate(n, e, this.fallbackLocale, t, r, "raw", i);
                if (this._isFallbackRoot(o)) {
                    if (!this._root) throw Error("unexpected error");
                    return this._root.$i18n.i(t, e, i)
                }
                return this._warnDefault(e, t, o, r, [i], "raw")
            }, xt.prototype.i = function(t, e, n) {
                return t ? (l(e) || (e = this.locale), this._i(t, e, this._getMessages(), null, n)) : ""
            }, xt.prototype._tc = function(t, e, n, r, i) {
                var o, a = [],
                    s = arguments.length - 5;
                while (s-- > 0) a[s] = arguments[s + 5];
                if (!t) return "";
                void 0 === i && (i = 1);
                var c = {
                        count: i,
                        n: i
                    },
                    l = f.apply(void 0, a);
                return l.params = Object.assign(c, l.params), a = null === l.locale ? [l.params] : [l.locale, l.params], this.fetchChoice((o = this)._t.apply(o, [t, e, n, r].concat(a)), i)
            }, xt.prototype.fetchChoice = function(t, e) {
                if (!t && !l(t)) return null;
                var n = t.split("|");
                return e = this.getChoiceIndex(e, n.length), n[e] ? n[e].trim() : t
            }, xt.prototype.tc = function(t, e) {
                var n, r = [],
                    i = arguments.length - 2;
                while (i-- > 0) r[i] = arguments[i + 2];
                return (n = this)._tc.apply(n, [t, this.locale, this._getMessages(), null, e].concat(r))
            }, xt.prototype._te = function(t, e, n) {
                var r = [],
                    i = arguments.length - 3;
                while (i-- > 0) r[i] = arguments[i + 3];
                var o = f.apply(void 0, r).locale || e;
                return this._exist(n[o], t)
            }, xt.prototype.te = function(t, e) {
                return this._te(t, this.locale, this._getMessages(), e)
            }, xt.prototype.getLocaleMessage = function(t) {
                return m(this._vm.messages[t] || {})
            }, xt.prototype.setLocaleMessage = function(t, e) {
                "warn" !== this._warnHtmlInMessage && "error" !== this._warnHtmlInMessage || this._checkLocaleMessage(t, this._warnHtmlInMessage, e), this._vm.$set(this._vm.messages, t, e)
            }, xt.prototype.mergeLocaleMessage = function(t, e) {
                "warn" !== this._warnHtmlInMessage && "error" !== this._warnHtmlInMessage || this._checkLocaleMessage(t, this._warnHtmlInMessage, e), this._vm.$set(this._vm.messages, t, b({}, this._vm.messages[t] || {}, e))
            }, xt.prototype.getDateTimeFormat = function(t) {
                return m(this._vm.dateTimeFormats[t] || {})
            }, xt.prototype.setDateTimeFormat = function(t, e) {
                this._vm.$set(this._vm.dateTimeFormats, t, e), this._clearDateTimeFormat(t, e)
            }, xt.prototype.mergeDateTimeFormat = function(t, e) {
                this._vm.$set(this._vm.dateTimeFormats, t, b(this._vm.dateTimeFormats[t] || {}, e)), this._clearDateTimeFormat(t, e)
            }, xt.prototype._clearDateTimeFormat = function(t, e) {
                for (var n in e) {
                    var r = t + "__" + n;
                    this._dateTimeFormatters.hasOwnProperty(r) && delete this._dateTimeFormatters[r]
                }
            }, xt.prototype._localizeDateTime = function(t, e, n, r, i) {
                for (var o = e, a = r[o], s = this._getLocaleChain(e, n), c = 0; c < s.length; c++) {
                    var l = s[c];
                    if (a = r[l], o = l, !p(a) && !p(a[i])) break
                }
                if (p(a) || p(a[i])) return null;
                var u = a[i],
                    h = o + "__" + i,
                    d = this._dateTimeFormatters[h];
                return d || (d = this._dateTimeFormatters[h] = new Intl.DateTimeFormat(o, u)), d.format(t)
            }, xt.prototype._d = function(t, e, n) {
                if (!n) return new Intl.DateTimeFormat(e).format(t);
                var r = this._localizeDateTime(t, e, this.fallbackLocale, this._getDateTimeFormats(), n);
                if (this._isFallbackRoot(r)) {
                    if (!this._root) throw Error("unexpected error");
                    return this._root.$i18n.d(t, n, e)
                }
                return r || ""
            }, xt.prototype.d = function(t) {
                var e = [],
                    n = arguments.length - 1;
                while (n-- > 0) e[n] = arguments[n + 1];
                var r = this.locale,
                    i = null;
                return 1 === e.length ? l(e[0]) ? i = e[0] : s(e[0]) && (e[0].locale && (r = e[0].locale), e[0].key && (i = e[0].key)) : 2 === e.length && (l(e[0]) && (i = e[0]), l(e[1]) && (r = e[1])), this._d(t, r, i)
            }, xt.prototype.getNumberFormat = function(t) {
                return m(this._vm.numberFormats[t] || {})
            }, xt.prototype.setNumberFormat = function(t, e) {
                this._vm.$set(this._vm.numberFormats, t, e), this._clearNumberFormat(t, e)
            }, xt.prototype.mergeNumberFormat = function(t, e) {
                this._vm.$set(this._vm.numberFormats, t, b(this._vm.numberFormats[t] || {}, e)), this._clearNumberFormat(t, e)
            }, xt.prototype._clearNumberFormat = function(t, e) {
                for (var n in e) {
                    var r = t + "__" + n;
                    this._numberFormatters.hasOwnProperty(r) && delete this._numberFormatters[r]
                }
            }, xt.prototype._getNumberFormatter = function(t, e, n, r, i, o) {
                for (var a = e, s = r[a], c = this._getLocaleChain(e, n), l = 0; l < c.length; l++) {
                    var u = c[l];
                    if (s = r[u], a = u, !p(s) && !p(s[i])) break
                }
                if (p(s) || p(s[i])) return null;
                var h, d = s[i];
                if (o) h = new Intl.NumberFormat(a, Object.assign({}, d, o));
                else {
                    var f = a + "__" + i;
                    h = this._numberFormatters[f], h || (h = this._numberFormatters[f] = new Intl.NumberFormat(a, d))
                }
                return h
            }, xt.prototype._n = function(t, e, n, r) {
                if (!xt.availabilities.numberFormat) return "";
                if (!n) {
                    var i = r ? new Intl.NumberFormat(e, r) : new Intl.NumberFormat(e);
                    return i.format(t)
                }
                var o = this._getNumberFormatter(t, e, this.fallbackLocale, this._getNumberFormats(), n, r),
                    a = o && o.format(t);
                if (this._isFallbackRoot(a)) {
                    if (!this._root) throw Error("unexpected error");
                    return this._root.$i18n.n(t, Object.assign({}, {
                        key: n,
                        locale: e
                    }, r))
                }
                return a || ""
            }, xt.prototype.n = function(t) {
                var e = [],
                    n = arguments.length - 1;
                while (n-- > 0) e[n] = arguments[n + 1];
                var i = this.locale,
                    o = null,
                    a = null;
                return 1 === e.length ? l(e[0]) ? o = e[0] : s(e[0]) && (e[0].locale && (i = e[0].locale), e[0].key && (o = e[0].key), a = Object.keys(e[0]).reduce((function(t, n) {
                    var i;
                    return v(r, n) ? Object.assign({}, t, (i = {}, i[n] = e[0][n], i)) : t
                }), null)) : 2 === e.length && (l(e[0]) && (o = e[0]), l(e[1]) && (i = e[1])), this._n(t, i, o, a)
            }, xt.prototype._ntp = function(t, e, n, r) {
                if (!xt.availabilities.numberFormat) return [];
                if (!n) {
                    var i = r ? new Intl.NumberFormat(e, r) : new Intl.NumberFormat(e);
                    return i.formatToParts(t)
                }
                var o = this._getNumberFormatter(t, e, this.fallbackLocale, this._getNumberFormats(), n, r),
                    a = o && o.formatToParts(t);
                if (this._isFallbackRoot(a)) {
                    if (!this._root) throw Error("unexpected error");
                    return this._root.$i18n._ntp(t, e, n, r)
                }
                return a || []
            }, Object.defineProperties(xt.prototype, wt), Object.defineProperty(xt, "availabilities", {
                get: function() {
                    if (!ft) {
                        var t = "undefined" !== typeof Intl;
                        ft = {
                            dateTimeFormat: t && "undefined" !== typeof Intl.DateTimeFormat,
                            numberFormat: t && "undefined" !== typeof Intl.NumberFormat
                        }
                    }
                    return ft
                }
            }), xt.install = z, xt.version = "8.20.0", e["a"] = xt
        },
        a975: function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("b727").every,
                o = r.aTypedArray,
                a = r.exportTypedArrayMethod;
            a("every", (function(t) {
                return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0)
            }))
        },
        a981: function(t, e) {
            t.exports = "undefined" !== typeof ArrayBuffer && "undefined" !== typeof DataView
        },
        a9e3: function(t, e, n) {
            "use strict";
            var r = n("83ab"),
                i = n("da84"),
                o = n("94ca"),
                a = n("6eeb"),
                s = n("5135"),
                c = n("c6b6"),
                l = n("7156"),
                u = n("c04e"),
                h = n("d039"),
                d = n("7c73"),
                p = n("241c").f,
                f = n("06cf").f,
                m = n("9bf2").f,
                g = n("58a8").trim,
                v = "Number",
                y = i[v],
                _ = y.prototype,
                b = c(d(_)) == v,
                x = function(t) {
                    var e, n, r, i, o, a, s, c, l = u(t, !1);
                    if ("string" == typeof l && l.length > 2)
                        if (l = g(l), e = l.charCodeAt(0), 43 === e || 45 === e) {
                            if (n = l.charCodeAt(2), 88 === n || 120 === n) return NaN
                        } else if (48 === e) {
                        switch (l.charCodeAt(1)) {
                            case 66:
                            case 98:
                                r = 2, i = 49;
                                break;
                            case 79:
                            case 111:
                                r = 8, i = 55;
                                break;
                            default:
                                return +l
                        }
                        for (o = l.slice(2), a = o.length, s = 0; s < a; s++)
                            if (c = o.charCodeAt(s), c < 48 || c > i) return NaN;
                        return parseInt(o, r)
                    }
                    return +l
                };
            if (o(v, !y(" 0o1") || !y("0b1") || y("+0x1"))) {
                for (var w, M = function(t) {
                        var e = arguments.length < 1 ? 0 : t,
                            n = this;
                        return n instanceof M && (b ? h((function() {
                            _.valueOf.call(n)
                        })) : c(n) != v) ? l(new y(x(e)), n, M) : x(e)
                    }, T = r ? p(y) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), S = 0; T.length > S; S++) s(y, w = T[S]) && !s(M, w) && m(M, w, f(y, w));
                M.prototype = _, _.constructor = M, a(i, v, M)
            }
        },
        ab13: function(t, e, n) {
            var r = n("b622"),
                i = r("match");
            t.exports = function(t) {
                var e = /./;
                try {
                    "/./" [t](e)
                } catch (n) {
                    try {
                        return e[i] = !1, "/./" [t](e)
                    } catch (r) {}
                }
                return !1
            }
        },
        ac1f: function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("9263");
            r({
                target: "RegExp",
                proto: !0,
                forced: /./.exec !== i
            }, {
                exec: i
            })
        },
        ad6d: function(t, e, n) {
            "use strict";
            var r = n("825a");
            t.exports = function() {
                var t = r(this),
                    e = "";
                return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.sticky && (e += "y"), e
            }
        },
        ae40: function(t, e, n) {
            var r = n("83ab"),
                i = n("d039"),
                o = n("5135"),
                a = Object.defineProperty,
                s = {},
                c = function(t) {
                    throw t
                };
            t.exports = function(t, e) {
                if (o(s, t)) return s[t];
                e || (e = {});
                var n = [][t],
                    l = !!o(e, "ACCESSORS") && e.ACCESSORS,
                    u = o(e, 0) ? e[0] : c,
                    h = o(e, 1) ? e[1] : void 0;
                return s[t] = !!n && !i((function() {
                    if (l && !r) return !0;
                    var t = {
                        length: -1
                    };
                    l ? a(t, 1, {
                        enumerable: !0,
                        get: c
                    }) : t[1] = 1, n.call(t, u, h)
                }))
            }
        },
        ae93: function(t, e, n) {
            "use strict";
            var r, i, o, a = n("e163"),
                s = n("9112"),
                c = n("5135"),
                l = n("b622"),
                u = n("c430"),
                h = l("iterator"),
                d = !1,
                p = function() {
                    return this
                };
            [].keys && (o = [].keys(), "next" in o ? (i = a(a(o)), i !== Object.prototype && (r = i)) : d = !0), void 0 == r && (r = {}), u || c(r, h) || s(r, h, p), t.exports = {
                IteratorPrototype: r,
                BUGGY_SAFARI_ITERATORS: d
            }
        },
        b041: function(t, e, n) {
            "use strict";
            var r = n("00ee"),
                i = n("f5df");
            t.exports = r ? {}.toString : function() {
                return "[object " + i(this) + "]"
            }
        },
        b0c0: function(t, e, n) {
            var r = n("83ab"),
                i = n("9bf2").f,
                o = Function.prototype,
                a = o.toString,
                s = /^\s*function ([^ (]*)/,
                c = "name";
            r && !(c in o) && i(o, c, {
                configurable: !0,
                get: function() {
                    try {
                        return a.call(this).match(s)[1]
                    } catch (t) {
                        return ""
                    }
                }
            })
        },
        b39a: function(t, e, n) {
            "use strict";
            var r = n("da84"),
                i = n("ebb5"),
                o = n("d039"),
                a = r.Int8Array,
                s = i.aTypedArray,
                c = i.exportTypedArrayMethod,
                l = [].toLocaleString,
                u = [].slice,
                h = !!a && o((function() {
                    l.call(new a(1))
                })),
                d = o((function() {
                    return [1, 2].toLocaleString() != new a([1, 2]).toLocaleString()
                })) || !o((function() {
                    a.prototype.toLocaleString.call([1, 2])
                }));
            c("toLocaleString", (function() {
                return l.apply(h ? u.call(s(this)) : s(this), arguments)
            }), d)
        },
        b575: function(t, e, n) {
            var r, i, o, a, s, c, l, u, h = n("da84"),
                d = n("06cf").f,
                p = n("c6b6"),
                f = n("2cf4").set,
                m = n("1cdc"),
                g = h.MutationObserver || h.WebKitMutationObserver,
                v = h.process,
                y = h.Promise,
                _ = "process" == p(v),
                b = d(h, "queueMicrotask"),
                x = b && b.value;
            x || (r = function() {
                var t, e;
                _ && (t = v.domain) && t.exit();
                while (i) {
                    e = i.fn, i = i.next;
                    try {
                        e()
                    } catch (n) {
                        throw i ? a() : o = void 0, n
                    }
                }
                o = void 0, t && t.enter()
            }, _ ? a = function() {
                v.nextTick(r)
            } : g && !m ? (s = !0, c = document.createTextNode(""), new g(r).observe(c, {
                characterData: !0
            }), a = function() {
                c.data = s = !s
            }) : y && y.resolve ? (l = y.resolve(void 0), u = l.then, a = function() {
                u.call(l, r)
            }) : a = function() {
                f.call(h, r)
            }), t.exports = x || function(t) {
                var e = {
                    fn: t,
                    next: void 0
                };
                o && (o.next = e), i || (i = e, a()), o = e
            }
        },
        b622: function(t, e, n) {
            var r = n("da84"),
                i = n("5692"),
                o = n("5135"),
                a = n("90e3"),
                s = n("4930"),
                c = n("fdbf"),
                l = i("wks"),
                u = r.Symbol,
                h = c ? u : u && u.withoutSetter || a;
            t.exports = function(t) {
                return o(l, t) || (s && o(u, t) ? l[t] = u[t] : l[t] = h("Symbol." + t)), l[t]
            }
        },
        b64b: function(t, e, n) {
            var r = n("23e7"),
                i = n("7b0b"),
                o = n("df75"),
                a = n("d039"),
                s = a((function() {
                    o(1)
                }));
            r({
                target: "Object",
                stat: !0,
                forced: s
            }, {
                keys: function(t) {
                    return o(i(t))
                }
            })
        },
        b680: function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("a691"),
                o = n("408a"),
                a = n("1148"),
                s = n("d039"),
                c = 1..toFixed,
                l = Math.floor,
                u = function(t, e, n) {
                    return 0 === e ? n : e % 2 === 1 ? u(t, e - 1, n * t) : u(t * t, e / 2, n)
                },
                h = function(t) {
                    var e = 0,
                        n = t;
                    while (n >= 4096) e += 12, n /= 4096;
                    while (n >= 2) e += 1, n /= 2;
                    return e
                },
                d = c && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== (0xde0b6b3a7640080).toFixed(0)) || !s((function() {
                    c.call({})
                }));
            r({
                target: "Number",
                proto: !0,
                forced: d
            }, {
                toFixed: function(t) {
                    var e, n, r, s, c = o(this),
                        d = i(t),
                        p = [0, 0, 0, 0, 0, 0],
                        f = "",
                        m = "0",
                        g = function(t, e) {
                            var n = -1,
                                r = e;
                            while (++n < 6) r += t * p[n], p[n] = r % 1e7, r = l(r / 1e7)
                        },
                        v = function(t) {
                            var e = 6,
                                n = 0;
                            while (--e >= 0) n += p[e], p[e] = l(n / t), n = n % t * 1e7
                        },
                        y = function() {
                            var t = 6,
                                e = "";
                            while (--t >= 0)
                                if ("" !== e || 0 === t || 0 !== p[t]) {
                                    var n = String(p[t]);
                                    e = "" === e ? n : e + a.call("0", 7 - n.length) + n
                                }
                            return e
                        };
                    if (d < 0 || d > 20) throw RangeError("Incorrect fraction digits");
                    if (c != c) return "NaN";
                    if (c <= -1e21 || c >= 1e21) return String(c);
                    if (c < 0 && (f = "-", c = -c), c > 1e-21)
                        if (e = h(c * u(2, 69, 1)) - 69, n = e < 0 ? c * u(2, -e, 1) : c / u(2, e, 1), n *= 4503599627370496, e = 52 - e, e > 0) {
                            g(0, n), r = d;
                            while (r >= 7) g(1e7, 0), r -= 7;
                            g(u(10, r, 1), 0), r = e - 1;
                            while (r >= 23) v(1 << 23), r -= 23;
                            v(1 << r), g(1, 1), v(2), m = y()
                        } else g(0, n), g(1 << -e, 0), m = y() + a.call("0", d);
                    return d > 0 ? (s = m.length, m = f + (s <= d ? "0." + a.call("0", d - s) + m : m.slice(0, s - d) + "." + m.slice(s - d))) : m = f + m, m
                }
            })
        },
        b727: function(t, e, n) {
            var r = n("0366"),
                i = n("44ad"),
                o = n("7b0b"),
                a = n("50c4"),
                s = n("65f0"),
                c = [].push,
                l = function(t) {
                    var e = 1 == t,
                        n = 2 == t,
                        l = 3 == t,
                        u = 4 == t,
                        h = 6 == t,
                        d = 5 == t || h;
                    return function(p, f, m, g) {
                        for (var v, y, _ = o(p), b = i(_), x = r(f, m, 3), w = a(b.length), M = 0, T = g || s, S = e ? T(p, w) : n ? T(p, 0) : void 0; w > M; M++)
                            if ((d || M in b) && (v = b[M], y = x(v, M, _), t))
                                if (e) S[M] = y;
                                else if (y) switch (t) {
                            case 3:
                                return !0;
                            case 5:
                                return v;
                            case 6:
                                return M;
                            case 2:
                                c.call(S, v)
                        } else if (u) return !1;
                        return h ? -1 : l || u ? u : S
                    }
                };
            t.exports = {
                forEach: l(0),
                map: l(1),
                filter: l(2),
                some: l(3),
                every: l(4),
                find: l(5),
                findIndex: l(6)
            }
        },
        b85c: function(t, e, n) {
            "use strict";
            n.d(e, "a", (function() {
                return i
            }));
            n("a4d3"), n("e01a"), n("d28b"), n("d3b7"), n("3ca3"), n("ddb0");
            var r = n("06c5");

            function i(t, e) {
                var n;
                if ("undefined" === typeof Symbol || null == t[Symbol.iterator]) {
                    if (Array.isArray(t) || (n = Object(r["a"])(t)) || e && t && "number" === typeof t.length) {
                        n && (t = n);
                        var i = 0,
                            o = function() {};
                        return {
                            s: o,
                            n: function() {
                                return i >= t.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t[i++]
                                }
                            },
                            e: function(t) {
                                throw t
                            },
                            f: o
                        }
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }
                var a, s = !0,
                    c = !1;
                return {
                    s: function() {
                        n = t[Symbol.iterator]()
                    },
                    n: function() {
                        var t = n.next();
                        return s = t.done, t
                    },
                    e: function(t) {
                        c = !0, a = t
                    },
                    f: function() {
                        try {
                            s || null == n["return"] || n["return"]()
                        } finally {
                            if (c) throw a
                        }
                    }
                }
            }
        },
        bee2: function(t, e, n) {
            "use strict";

            function r(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var r = e[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
                }
            }

            function i(t, e, n) {
                return e && r(t.prototype, e), n && r(t, n), t
            }
            n.d(e, "a", (function() {
                return i
            }))
        },
        c04e: function(t, e, n) {
            var r = n("861d");
            t.exports = function(t, e) {
                if (!r(t)) return t;
                var n, i;
                if (e && "function" == typeof(n = t.toString) && !r(i = n.call(t))) return i;
                if ("function" == typeof(n = t.valueOf) && !r(i = n.call(t))) return i;
                if (!e && "function" == typeof(n = t.toString) && !r(i = n.call(t))) return i;
                throw TypeError("Can't convert object to primitive value")
            }
        },
        c098: function(t, e, n) {
            t.exports = n("d4af")
        },
        c1ac: function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("b727").filter,
                o = n("4840"),
                a = r.aTypedArray,
                s = r.aTypedArrayConstructor,
                c = r.exportTypedArrayMethod;
            c("filter", (function(t) {
                var e = i(a(this), t, arguments.length > 1 ? arguments[1] : void 0),
                    n = o(this, this.constructor),
                    r = 0,
                    c = e.length,
                    l = new(s(n))(c);
                while (c > r) l[r] = e[r++];
                return l
            }))
        },
        c430: function(t, e) {
            t.exports = !1
        },
        c6b6: function(t, e) {
            var n = {}.toString;
            t.exports = function(t) {
                return n.call(t).slice(8, -1)
            }
        },
        c6cd: function(t, e, n) {
            var r = n("da84"),
                i = n("ce4e"),
                o = "__core-js_shared__",
                a = r[o] || i(o, {});
            t.exports = a
        },
        c8ba: function(t, e) {
            var n;
            n = function() {
                return this
            }();
            try {
                n = n || new Function("return this")()
            } catch (r) {
                "object" === typeof window && (n = window)
            }
            t.exports = n
        },
        c975: function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("4d64").indexOf,
                o = n("a640"),
                a = n("ae40"),
                s = [].indexOf,
                c = !!s && 1 / [1].indexOf(1, -0) < 0,
                l = o("indexOf"),
                u = a("indexOf", {
                    ACCESSORS: !0,
                    1: 0
                });
            r({
                target: "Array",
                proto: !0,
                forced: c || !l || !u
            }, {
                indexOf: function(t) {
                    return c ? s.apply(this, arguments) || 0 : i(this, t, arguments.length > 1 ? arguments[1] : void 0)
                }
            })
        },
        ca84: function(t, e, n) {
            var r = n("5135"),
                i = n("fc6a"),
                o = n("4d64").indexOf,
                a = n("d012");
            t.exports = function(t, e) {
                var n, s = i(t),
                    c = 0,
                    l = [];
                for (n in s) !r(a, n) && r(s, n) && l.push(n);
                while (e.length > c) r(s, n = e[c++]) && (~o(l, n) || l.push(n));
                return l
            }
        },
        ca91: function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("d58f").left,
                o = r.aTypedArray,
                a = r.exportTypedArrayMethod;
            a("reduce", (function(t) {
                return i(o(this), t, arguments.length, arguments.length > 1 ? arguments[1] : void 0)
            }))
        },
        caad: function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("4d64").includes,
                o = n("44d2"),
                a = n("ae40"),
                s = a("indexOf", {
                    ACCESSORS: !0,
                    1: 0
                });
            r({
                target: "Array",
                proto: !0,
                forced: !s
            }, {
                includes: function(t) {
                    return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
                }
            }), o("includes")
        },
        cb29: function(t, e, n) {
            var r = n("23e7"),
                i = n("81d5"),
                o = n("44d2");
            r({
                target: "Array",
                proto: !0
            }, {
                fill: i
            }), o("fill")
        },
        cc12: function(t, e, n) {
            var r = n("da84"),
                i = n("861d"),
                o = r.document,
                a = i(o) && i(o.createElement);
            t.exports = function(t) {
                return a ? o.createElement(t) : {}
            }
        },
        cca6: function(t, e, n) {
            var r = n("23e7"),
                i = n("60da");
            r({
                target: "Object",
                stat: !0,
                forced: Object.assign !== i
            }, {
                assign: i
            })
        },
        cd26: function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = r.aTypedArray,
                o = r.exportTypedArrayMethod,
                a = Math.floor;
            o("reverse", (function() {
                var t, e = this,
                    n = i(e).length,
                    r = a(n / 2),
                    o = 0;
                while (o < r) t = e[o], e[o++] = e[--n], e[n] = t;
                return e
            }))
        },
        cdf9: function(t, e, n) {
            var r = n("825a"),
                i = n("861d"),
                o = n("f069");
            t.exports = function(t, e) {
                if (r(t), i(e) && e.constructor === t) return e;
                var n = o.f(t),
                    a = n.resolve;
                return a(e), n.promise
            }
        },
        ce4e: function(t, e, n) {
            var r = n("da84"),
                i = n("9112");
            t.exports = function(t, e) {
                try {
                    i(r, t, e)
                } catch (n) {
                    r[t] = e
                }
                return e
            }
        },
        cfc3: function(t, e, n) {
            var r = n("74e8");
            r("Float32", (function(t) {
                return function(e, n, r) {
                    return t(this, e, n, r)
                }
            }))
        },
        cffa: function(t, e, n) {
            "use strict";
            n.d(e, "b", (function() {
                return _t
            })), n.d(e, "a", (function() {
                return _t
            }));
            var r, i, o, a, s, c, l, u, h = n("a5cf"),
                d = function() {
                    return "undefined" !== typeof window
                },
                p = {},
                f = 180 / Math.PI,
                m = Math.PI / 180,
                g = Math.atan2,
                v = 1e8,
                y = /([A-Z])/g,
                _ = /(?:left|right|width|margin|padding|x)/i,
                b = /[\s,\(]\S/,
                x = {
                    autoAlpha: "opacity,visibility",
                    scale: "scaleX,scaleY",
                    alpha: "opacity"
                },
                w = function(t, e) {
                    return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
                },
                M = function(t, e) {
                    return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
                },
                T = function(t, e) {
                    return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
                },
                S = function(t, e) {
                    var n = e.s + e.c * t;
                    e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
                },
                E = function(t, e) {
                    return e.set(e.t, e.p, t ? e.e : e.b, e)
                },
                A = function(t, e) {
                    return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
                },
                L = function(t, e, n) {
                    return t.style[e] = n
                },
                R = function(t, e, n) {
                    return t.style.setProperty(e, n)
                },
                C = function(t, e, n) {
                    return t._gsap[e] = n
                },
                O = function(t, e, n) {
                    return t._gsap.scaleX = t._gsap.scaleY = n
                },
                P = function(t, e, n, r, i) {
                    var o = t._gsap;
                    o.scaleX = o.scaleY = n, o.renderTransform(i, o)
                },
                I = function(t, e, n, r, i) {
                    var o = t._gsap;
                    o[e] = n, o.renderTransform(i, o)
                },
                N = "transform",
                D = N + "Origin",
                k = function(t, e) {
                    var n = i.createElementNS ? i.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : i.createElement(t);
                    return n.style ? n : i.createElement(t)
                },
                F = function t(e, n, r) {
                    var i = getComputedStyle(e);
                    return i[n] || i.getPropertyValue(n.replace(y, "-$1").toLowerCase()) || i.getPropertyValue(n) || !r && t(e, U(n) || n, 1) || ""
                },
                B = "O,Moz,ms,Ms,Webkit".split(","),
                U = function(t, e, n) {
                    var r = e || s,
                        i = r.style,
                        o = 5;
                    if (t in i && !n) return t;
                    t = t.charAt(0).toUpperCase() + t.substr(1);
                    while (o-- && !(B[o] + t in i));
                    return o < 0 ? null : (3 === o ? "ms" : o >= 0 ? B[o] : "") + t
                },
                H = function() {
                    d() && window.document && (r = window, i = r.document, o = i.documentElement, s = k("div") || {
                        style: {}
                    }, c = k("div"), N = U(N), D = N + "Origin", s.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", u = !!U("perspective"), a = 1)
                },
                z = function t(e) {
                    var n, r = k("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                        i = this.parentNode,
                        a = this.nextSibling,
                        s = this.style.cssText;
                    if (o.appendChild(r), r.appendChild(this), this.style.display = "block", e) try {
                        n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
                    } catch (c) {} else this._gsapBBox && (n = this._gsapBBox());
                    return i && (a ? i.insertBefore(this, a) : i.appendChild(this)), o.removeChild(r), this.style.cssText = s, n
                },
                j = function(t, e) {
                    var n = e.length;
                    while (n--)
                        if (t.hasAttribute(e[n])) return t.getAttribute(e[n])
                },
                G = function(t) {
                    var e;
                    try {
                        e = t.getBBox()
                    } catch (n) {
                        e = z.call(t, !0)
                    }
                    return e && (e.width || e.height) || t.getBBox === z || (e = z.call(t, !0)), !e || e.width || e.x || e.y ? e : {
                        x: +j(t, ["x", "cx", "x1"]) || 0,
                        y: +j(t, ["y", "cy", "y1"]) || 0,
                        width: 0,
                        height: 0
                    }
                },
                V = function(t) {
                    return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !G(t))
                },
                W = function(t, e) {
                    if (e) {
                        var n = t.style;
                        e in p && e !== D && (e = N), n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), n.removeProperty(e.replace(y, "-$1").toLowerCase())) : n.removeAttribute(e)
                    }
                },
                X = function(t, e, n, r, i, o) {
                    var a = new h["c"](t._pt, e, n, 0, 1, o ? A : E);
                    return t._pt = a, a.b = r, a.e = i, t._props.push(n), a
                },
                q = {
                    deg: 1,
                    rad: 1,
                    turn: 1
                },
                Y = function t(e, n, r, o) {
                    var a, c, l, u, d = parseFloat(r) || 0,
                        f = (r + "").trim().substr((d + "").length) || "px",
                        m = s.style,
                        g = _.test(n),
                        v = "svg" === e.tagName.toLowerCase(),
                        y = (v ? "client" : "offset") + (g ? "Width" : "Height"),
                        b = 100,
                        x = "px" === o,
                        w = "%" === o;
                    return o === f || !d || q[o] || q[f] ? d : ("px" !== f && !x && (d = t(e, n, r, "px")), u = e.getCTM && V(e), w && (p[n] || ~n.indexOf("adius")) ? Object(h["t"])(d / (u ? e.getBBox()[g ? "width" : "height"] : e[y]) * b) : (m[g ? "width" : "height"] = b + (x ? f : o), c = ~n.indexOf("adius") || "em" === o && e.appendChild && !v ? e : e.parentNode, u && (c = (e.ownerSVGElement || {}).parentNode), c && c !== i && c.appendChild || (c = i.body), l = c._gsap, l && w && l.width && g && l.time === h["v"].time ? Object(h["t"])(d / l.width * b) : ((w || "%" === f) && (m.position = F(e, "position")), c === e && (m.position = "static"), c.appendChild(s), a = s[y], c.removeChild(s), m.position = "absolute", g && w && (l = Object(h["h"])(c), l.time = h["v"].time, l.width = c[y]), Object(h["t"])(x ? a * d / b : a && d ? b / a * d : 0))))
                },
                $ = function(t, e, n, r) {
                    var i;
                    return a || H(), e in x && "transform" !== e && (e = x[e], ~e.indexOf(",") && (e = e.split(",")[0])), p[e] && "transform" !== e ? (i = st(t, r), i = "transformOrigin" !== e ? i[e] : ct(F(t, D)) + " " + i.zOrigin + "px") : (i = t.style[e], (!i || "auto" === i || r || ~(i + "").indexOf("calc(")) && (i = tt[e] && tt[e](t, e, n) || F(t, e) || Object(h["i"])(t, e) || ("opacity" === e ? 1 : 0))), n && !~(i + "").indexOf(" ") ? Y(t, e, i, n) + n : i
                },
                Z = function(t, e, n, r) {
                    if (!n || "none" === n) {
                        var i = U(e, t, 1),
                            o = i && F(t, i, 1);
                        o && o !== n ? (e = i, n = o) : "borderColor" === e && (n = F(t, "borderTopColor"))
                    }
                    var a, s, c, l, u, d, p, f, m, g, v, y, _, b = new h["c"](this._pt, t.style, e, 0, 1, h["r"]),
                        x = 0,
                        w = 0;
                    if (b.b = n, b.e = r, n += "", r += "", "auto" === r && (t.style[e] = r, r = F(t, e) || r, t.style[e] = n), a = [n, r], Object(h["e"])(a), n = a[0], r = a[1], c = n.match(h["o"]) || [], _ = r.match(h["o"]) || [], _.length) {
                        while (s = h["o"].exec(r)) p = s[0], m = r.substring(x, s.index), u ? u = (u + 1) % 5 : "rgba(" !== m.substr(-5) && "hsla(" !== m.substr(-5) || (u = 1), p !== (d = c[w++] || "") && (l = parseFloat(d) || 0, v = d.substr((l + "").length), y = "=" === p.charAt(1) ? +(p.charAt(0) + "1") : 0, y && (p = p.substr(2)), f = parseFloat(p), g = p.substr((f + "").length), x = h["o"].lastIndex - g.length, g || (g = g || h["f"].units[e] || v, x === r.length && (r += g, b.e += g)), v !== g && (l = Y(t, e, d, g) || 0), b._pt = {
                            _next: b._pt,
                            p: m || 1 === w ? m : ",",
                            s: l,
                            c: y ? y * f : f - l,
                            m: u && u < 4 ? Math.round : 0
                        });
                        b.c = x < r.length ? r.substring(x, r.length) : ""
                    } else b.r = "display" === e && "none" === r ? A : E;
                    return h["q"].test(r) && (b.e = 0), this._pt = b, b
                },
                J = {
                    top: "0%",
                    bottom: "100%",
                    left: "0%",
                    right: "100%",
                    center: "50%"
                },
                K = function(t) {
                    var e = t.split(" "),
                        n = e[0],
                        r = e[1] || "50%";
                    return "top" !== n && "bottom" !== n && "left" !== r && "right" !== r || (t = n, n = r, r = t), e[0] = J[n] || n, e[1] = J[r] || r, e.join(" ")
                },
                Q = function(t, e) {
                    if (e.tween && e.tween._time === e.tween._dur) {
                        var n, r, i, o = e.t,
                            a = o.style,
                            s = e.u,
                            c = o._gsap;
                        if ("all" === s || !0 === s) a.cssText = "", r = 1;
                        else {
                            s = s.split(","), i = s.length;
                            while (--i > -1) n = s[i], p[n] && (r = 1, n = "transformOrigin" === n ? D : N), W(o, n)
                        }
                        r && (W(o, N), c && (c.svg && o.removeAttribute("transform"), st(o, 1), c.uncache = 1))
                    }
                },
                tt = {
                    clearProps: function(t, e, n, r, i) {
                        if ("isFromStart" !== i.data) {
                            var o = t._pt = new h["c"](t._pt, e, n, 0, 0, Q);
                            return o.u = r, o.pr = -10, o.tween = i, t._props.push(n), 1
                        }
                    }
                },
                et = [1, 0, 0, 1, 0, 0],
                nt = {},
                rt = function(t) {
                    return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
                },
                it = function(t) {
                    var e = F(t, N);
                    return rt(e) ? et : e.substr(7).match(h["n"]).map(h["t"])
                },
                ot = function(t, e) {
                    var n, r, i, a, s = t._gsap || Object(h["h"])(t),
                        c = t.style,
                        l = it(t);
                    return s.svg && t.getAttribute("transform") ? (i = t.transform.baseVal.consolidate().matrix, l = [i.a, i.b, i.c, i.d, i.e, i.f], "1,0,0,1,0,0" === l.join(",") ? et : l) : (l !== et || t.offsetParent || t === o || s.svg || (i = c.display, c.display = "block", n = t.parentNode, n && t.offsetParent || (a = 1, r = t.nextSibling, o.appendChild(t)), l = it(t), i ? c.display = i : W(t, "display"), a && (r ? n.insertBefore(t, r) : n ? n.appendChild(t) : o.removeChild(t))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
                },
                at = function(t, e, n, r, i, o) {
                    var a, s, c, l, u = t._gsap,
                        h = i || ot(t, !0),
                        d = u.xOrigin || 0,
                        p = u.yOrigin || 0,
                        f = u.xOffset || 0,
                        m = u.yOffset || 0,
                        g = h[0],
                        v = h[1],
                        y = h[2],
                        _ = h[3],
                        b = h[4],
                        x = h[5],
                        w = e.split(" "),
                        M = parseFloat(w[0]) || 0,
                        T = parseFloat(w[1]) || 0;
                    n ? h !== et && (s = g * _ - v * y) && (c = M * (_ / s) + T * (-y / s) + (y * x - _ * b) / s, l = M * (-v / s) + T * (g / s) - (g * x - v * b) / s, M = c, T = l) : (a = G(t), M = a.x + (~w[0].indexOf("%") ? M / 100 * a.width : M), T = a.y + (~(w[1] || w[0]).indexOf("%") ? T / 100 * a.height : T)), r || !1 !== r && u.smooth ? (b = M - d, x = T - p, u.xOffset = f + (b * g + x * y) - b, u.yOffset = m + (b * v + x * _) - x) : u.xOffset = u.yOffset = 0, u.xOrigin = M, u.yOrigin = T, u.smooth = !!r, u.origin = e, u.originIsAbsolute = !!n, t.style[D] = "0px 0px", o && (X(o, u, "xOrigin", d, M), X(o, u, "yOrigin", p, T), X(o, u, "xOffset", f, u.xOffset), X(o, u, "yOffset", m, u.yOffset)), t.setAttribute("data-svg-origin", M + " " + T)
                },
                st = function(t, e) {
                    var n = t._gsap || new h["a"](t);
                    if ("x" in n && !e && !n.uncache) return n;
                    var r, i, o, a, s, c, l, d, p, v, y, _, b, x, w, M, T, S, E, A, L, R, C, O, P, I, k, B, U, H, z, j, G = t.style,
                        W = n.scaleX < 0,
                        X = "px",
                        q = "deg",
                        Y = F(t, D) || "0";
                    return r = i = o = c = l = d = p = v = y = 0, a = s = 1, n.svg = !(!t.getCTM || !V(t)), x = ot(t, n.svg), n.svg && (O = !n.uncache && t.getAttribute("data-svg-origin"), at(t, O || Y, !!O || n.originIsAbsolute, !1 !== n.smooth, x)), _ = n.xOrigin || 0, b = n.yOrigin || 0, x !== et && (S = x[0], E = x[1], A = x[2], L = x[3], r = R = x[4], i = C = x[5], 6 === x.length ? (a = Math.sqrt(S * S + E * E), s = Math.sqrt(L * L + A * A), c = S || E ? g(E, S) * f : 0, p = A || L ? g(A, L) * f + c : 0, p && (s *= Math.cos(p * m)), n.svg && (r -= _ - (_ * S + b * A), i -= b - (_ * E + b * L))) : (j = x[6], H = x[7], k = x[8], B = x[9], U = x[10], z = x[11], r = x[12], i = x[13], o = x[14], w = g(j, U), l = w * f, w && (M = Math.cos(-w), T = Math.sin(-w), O = R * M + k * T, P = C * M + B * T, I = j * M + U * T, k = R * -T + k * M, B = C * -T + B * M, U = j * -T + U * M, z = H * -T + z * M, R = O, C = P, j = I), w = g(-A, U), d = w * f, w && (M = Math.cos(-w), T = Math.sin(-w), O = S * M - k * T, P = E * M - B * T, I = A * M - U * T, z = L * T + z * M, S = O, E = P, A = I), w = g(E, S), c = w * f, w && (M = Math.cos(w), T = Math.sin(w), O = S * M + E * T, P = R * M + C * T, E = E * M - S * T, C = C * M - R * T, S = O, R = P), l && Math.abs(l) + Math.abs(c) > 359.9 && (l = c = 0, d = 180 - d), a = Object(h["t"])(Math.sqrt(S * S + E * E + A * A)), s = Object(h["t"])(Math.sqrt(C * C + j * j)), w = g(R, C), p = Math.abs(w) > 2e-4 ? w * f : 0, y = z ? 1 / (z < 0 ? -z : z) : 0), n.svg && (O = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !rt(F(t, N)), O && t.setAttribute("transform", O))), Math.abs(p) > 90 && Math.abs(p) < 270 && (W ? (a *= -1, p += c <= 0 ? 180 : -180, c += c <= 0 ? 180 : -180) : (s *= -1, p += p <= 0 ? 180 : -180)), n.x = ((n.xPercent = r && Math.round(t.offsetWidth / 2) === Math.round(-r) ? -50 : 0) ? 0 : r) + X, n.y = ((n.yPercent = i && Math.round(t.offsetHeight / 2) === Math.round(-i) ? -50 : 0) ? 0 : i) + X, n.z = o + X, n.scaleX = Object(h["t"])(a), n.scaleY = Object(h["t"])(s), n.rotation = Object(h["t"])(c) + q, n.rotationX = Object(h["t"])(l) + q, n.rotationY = Object(h["t"])(d) + q, n.skewX = p + q, n.skewY = v + q, n.transformPerspective = y + X, (n.zOrigin = parseFloat(Y.split(" ")[2]) || 0) && (G[D] = ct(Y)), n.xOffset = n.yOffset = 0, n.force3D = h["f"].force3D, n.renderTransform = n.svg ? mt : u ? ft : ut, n.uncache = 0, n
                },
                ct = function(t) {
                    return (t = t.split(" "))[0] + " " + t[1]
                },
                lt = function(t, e, n) {
                    var r = Object(h["x"])(e);
                    return Object(h["t"])(parseFloat(e) + parseFloat(Y(t, "x", n + "px", r))) + r
                },
                ut = function(t, e) {
                    e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, ft(t, e)
                },
                ht = "0deg",
                dt = "0px",
                pt = ") ",
                ft = function(t, e) {
                    var n = e || this,
                        r = n.xPercent,
                        i = n.yPercent,
                        o = n.x,
                        a = n.y,
                        s = n.z,
                        c = n.rotation,
                        l = n.rotationY,
                        u = n.rotationX,
                        h = n.skewX,
                        d = n.skewY,
                        p = n.scaleX,
                        f = n.scaleY,
                        g = n.transformPerspective,
                        v = n.force3D,
                        y = n.target,
                        _ = n.zOrigin,
                        b = "",
                        x = "auto" === v && t && 1 !== t || !0 === v;
                    if (_ && (u !== ht || l !== ht)) {
                        var w, M = parseFloat(l) * m,
                            T = Math.sin(M),
                            S = Math.cos(M);
                        M = parseFloat(u) * m, w = Math.cos(M), o = lt(y, o, T * w * -_), a = lt(y, a, -Math.sin(M) * -_), s = lt(y, s, S * w * -_ + _)
                    }
                    g !== dt && (b += "perspective(" + g + pt), (r || i) && (b += "translate(" + r + "%, " + i + "%) "), (x || o !== dt || a !== dt || s !== dt) && (b += s !== dt || x ? "translate3d(" + o + ", " + a + ", " + s + ") " : "translate(" + o + ", " + a + pt), c !== ht && (b += "rotate(" + c + pt), l !== ht && (b += "rotateY(" + l + pt), u !== ht && (b += "rotateX(" + u + pt), h === ht && d === ht || (b += "skew(" + h + ", " + d + pt), 1 === p && 1 === f || (b += "scale(" + p + ", " + f + pt), y.style[N] = b || "translate(0, 0)"
                },
                mt = function(t, e) {
                    var n, r, i, o, a, s = e || this,
                        c = s.xPercent,
                        l = s.yPercent,
                        u = s.x,
                        d = s.y,
                        p = s.rotation,
                        f = s.skewX,
                        g = s.skewY,
                        v = s.scaleX,
                        y = s.scaleY,
                        _ = s.target,
                        b = s.xOrigin,
                        x = s.yOrigin,
                        w = s.xOffset,
                        M = s.yOffset,
                        T = s.forceCSS,
                        S = parseFloat(u),
                        E = parseFloat(d);
                    p = parseFloat(p), f = parseFloat(f), g = parseFloat(g), g && (g = parseFloat(g), f += g, p += g), p || f ? (p *= m, f *= m, n = Math.cos(p) * v, r = Math.sin(p) * v, i = Math.sin(p - f) * -y, o = Math.cos(p - f) * y, f && (g *= m, a = Math.tan(f - g), a = Math.sqrt(1 + a * a), i *= a, o *= a, g && (a = Math.tan(g), a = Math.sqrt(1 + a * a), n *= a, r *= a)), n = Object(h["t"])(n), r = Object(h["t"])(r), i = Object(h["t"])(i), o = Object(h["t"])(o)) : (n = v, o = y, r = i = 0), (S && !~(u + "").indexOf("px") || E && !~(d + "").indexOf("px")) && (S = Y(_, "x", u, "px"), E = Y(_, "y", d, "px")), (b || x || w || M) && (S = Object(h["t"])(S + b - (b * n + x * i) + w), E = Object(h["t"])(E + x - (b * r + x * o) + M)), (c || l) && (a = _.getBBox(), S = Object(h["t"])(S + c / 100 * a.width), E = Object(h["t"])(E + l / 100 * a.height)), a = "matrix(" + n + "," + r + "," + i + "," + o + "," + S + "," + E + ")", _.setAttribute("transform", a), T && (_.style[N] = a)
                },
                gt = function(t, e, n, r, i, o) {
                    var a, s, c = 360,
                        l = Object(h["k"])(i),
                        u = parseFloat(i) * (l && ~i.indexOf("rad") ? f : 1),
                        d = o ? u * o : u - r,
                        p = r + d + "deg";
                    return l && (a = i.split("_")[1], "short" === a && (d %= c, d !== d % (c / 2) && (d += d < 0 ? c : -c)), "cw" === a && d < 0 ? d = (d + c * v) % c - ~~(d / c) * c : "ccw" === a && d > 0 && (d = (d - c * v) % c - ~~(d / c) * c)), t._pt = s = new h["c"](t._pt, e, n, r, d, M), s.e = p, s.u = "deg", t._props.push(n), s
                },
                vt = function(t, e, n) {
                    var r, o, a, s, l, u, d, f, m = c.style,
                        g = n._gsap,
                        v = "perspective,force3D,transformOrigin,svgOrigin";
                    for (o in m.cssText = getComputedStyle(n).cssText + ";position:absolute;display:block;", m[N] = e, i.body.appendChild(c), r = st(c, 1), p) a = g[o], s = r[o], a !== s && v.indexOf(o) < 0 && (d = Object(h["x"])(a), f = Object(h["x"])(s), l = d !== f ? Y(n, o, a, f) : parseFloat(a), u = parseFloat(s), t._pt = new h["c"](t._pt, g, o, l, u - l, w), t._pt.u = f || 0, t._props.push(o));
                    i.body.removeChild(c)
                };
            /*!
             * CSSPlugin 3.5.1
             * https://greensock.com
             *
             * Copyright 2008-2020, GreenSock. All rights reserved.
             * Subject to the terms at https://greensock.com/standard-license or for
             * Club GreenSock members, the agreement issued with that membership.
             * @author: Jack Doyle, jack@greensock.com
             */
            Object(h["g"])("padding,margin,Width,Radius", (function(t, e) {
                var n = "Top",
                    r = "Right",
                    i = "Bottom",
                    o = "Left",
                    a = (e < 3 ? [n, r, i, o] : [n + o, n + r, i + r, i + o]).map((function(n) {
                        return e < 2 ? t + n : "border" + n + t
                    }));
                tt[e > 1 ? "border" + t : t] = function(t, e, n, r, i) {
                    var o, s;
                    if (arguments.length < 4) return o = a.map((function(e) {
                        return $(t, e, n)
                    })), s = o.join(" "), 5 === s.split(o[0]).length ? o[0] : s;
                    o = (r + "").split(" "), s = {}, a.forEach((function(t, e) {
                        return s[t] = o[e] = o[e] || o[(e - 1) / 2 | 0]
                    })), t.init(e, s, i)
                }
            }));
            var yt = {
                name: "css",
                register: H,
                targetTest: function(t) {
                    return t.style && t.nodeType
                },
                init: function(t, e, n, r, i) {
                    var o, s, c, l, u, d, f, m, g, v, y, _, M, E, A, L = this._props,
                        R = t.style;
                    for (f in a || H(), e)
                        if ("autoRound" !== f && (s = e[f], !h["p"][f] || !Object(h["d"])(f, e, n, r, t, i)))
                            if (u = typeof s, d = tt[f], "function" === u && (s = s.call(n, r, t, i), u = typeof s), "string" === u && ~s.indexOf("random(") && (s = Object(h["s"])(s)), d) d(this, t, f, s, n) && (A = 1);
                            else if ("--" === f.substr(0, 2)) this.add(R, "setProperty", getComputedStyle(t).getPropertyValue(f) + "", s + "", r, i, 0, 0, f);
                    else if ("undefined" !== u) {
                        if (o = $(t, f), l = parseFloat(o), v = "string" === u && "=" === s.charAt(1) ? +(s.charAt(0) + "1") : 0, v && (s = s.substr(2)), c = parseFloat(s), f in x && ("autoAlpha" === f && (1 === l && "hidden" === $(t, "visibility") && c && (l = 0), X(this, R, "visibility", l ? "inherit" : "hidden", c ? "inherit" : "hidden", !c)), "scale" !== f && "transform" !== f && (f = x[f], ~f.indexOf(",") && (f = f.split(",")[0]))), y = f in p, y)
                            if (_ || (M = t._gsap, M.renderTransform || st(t), E = !1 !== e.smoothOrigin && M.smooth, _ = this._pt = new h["c"](this._pt, R, N, 0, 1, M.renderTransform, M, 0, -1), _.dep = 1), "scale" === f) this._pt = new h["c"](this._pt, M, "scaleY", M.scaleY, v ? v * c : c - M.scaleY), L.push("scaleY", f), f += "X";
                            else {
                                if ("transformOrigin" === f) {
                                    s = K(s), M.svg ? at(t, s, 0, E, 0, this) : (g = parseFloat(s.split(" ")[2]) || 0, g !== M.zOrigin && X(this, M, "zOrigin", M.zOrigin, g), X(this, R, f, ct(o), ct(s)));
                                    continue
                                }
                                if ("svgOrigin" === f) {
                                    at(t, s, 1, E, 0, this);
                                    continue
                                }
                                if (f in nt) {
                                    gt(this, M, f, l, s, v);
                                    continue
                                }
                                if ("smoothOrigin" === f) {
                                    X(this, M, "smooth", M.smooth, s);
                                    continue
                                }
                                if ("force3D" === f) {
                                    M[f] = s;
                                    continue
                                }
                                if ("transform" === f) {
                                    vt(this, s, t);
                                    continue
                                }
                            }
                        else f in R || (f = U(f) || f);
                        if (y || (c || 0 === c) && (l || 0 === l) && !b.test(s) && f in R) m = (o + "").substr((l + "").length), c || (c = 0), g = Object(h["x"])(s) || (f in h["f"].units ? h["f"].units[f] : m), m !== g && (l = Y(t, f, o, g)), this._pt = new h["c"](this._pt, y ? M : R, f, l, v ? v * c : c - l, "px" !== g || !1 === e.autoRound || y ? w : S), this._pt.u = g || 0, m !== g && (this._pt.b = o, this._pt.r = T);
                        else if (f in R) Z.call(this, t, f, o, s);
                        else {
                            if (!(f in t)) {
                                Object(h["m"])(f, s);
                                continue
                            }
                            this.add(t, f, t[f], s, r, i)
                        }
                        L.push(f)
                    }
                    A && Object(h["u"])(this)
                },
                get: $,
                aliases: x,
                getSetter: function(t, e, n) {
                    var r = x[e];
                    return r && r.indexOf(",") < 0 && (e = r), e in p && e !== D && (t._gsap.x || $(t, "x")) ? n && l === n ? "scale" === e ? O : C : (l = n || {}) && ("scale" === e ? P : I) : t.style && !Object(h["l"])(t.style[e]) ? L : ~e.indexOf("-") ? R : Object(h["j"])(t, e)
                },
                core: {
                    _removeProperty: W,
                    _getMatrix: ot
                }
            };
            h["y"].utils.checkPrefix = U,
                function(t, e, n, r) {
                    var i = Object(h["g"])(t + "," + e + "," + n, (function(t) {
                        p[t] = 1
                    }));
                    Object(h["g"])(e, (function(t) {
                        h["f"].units[t] = "deg", nt[t] = 1
                    })), x[i[13]] = t + "," + e, Object(h["g"])(r, (function(t) {
                        var e = t.split(":");
                        x[e[1]] = i[e[0]]
                    }))
                }("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"), Object(h["g"])("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(t) {
                    h["f"].units[t] = "px"
                })), h["y"].registerPlugin(yt);
            var _t = h["y"].registerPlugin(yt) || h["y"];
            _t.core.Tween
        },
        d012: function(t, e) {
            t.exports = {}
        },
        d039: function(t, e) {
            t.exports = function(t) {
                try {
                    return !!t()
                } catch (e) {
                    return !0
                }
            }
        },
        d066: function(t, e, n) {
            var r = n("428f"),
                i = n("da84"),
                o = function(t) {
                    return "function" == typeof t ? t : void 0
                };
            t.exports = function(t, e) {
                return arguments.length < 2 ? o(r[t]) || o(i[t]) : r[t] && r[t][e] || i[t] && i[t][e]
            }
        },
        d139: function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("b727").find,
                o = r.aTypedArray,
                a = r.exportTypedArrayMethod;
            a("find", (function(t) {
                return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0)
            }))
        },
        d1e7: function(t, e, n) {
            "use strict";
            var r = {}.propertyIsEnumerable,
                i = Object.getOwnPropertyDescriptor,
                o = i && !r.call({
                    1: 2
                }, 1);
            e.f = o ? function(t) {
                var e = i(this, t);
                return !!e && e.enumerable
            } : r
        },
        d28b: function(t, e, n) {
            var r = n("746f");
            r("iterator")
        },
        d2bb: function(t, e, n) {
            var r = n("825a"),
                i = n("3bbe");
            t.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
                var t, e = !1,
                    n = {};
                try {
                    t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set, t.call(n, []), e = n instanceof Array
                } catch (o) {}
                return function(n, o) {
                    return r(n), i(o), e ? t.call(n, o) : n.__proto__ = o, n
                }
            }() : void 0)
        },
        d3b7: function(t, e, n) {
            var r = n("00ee"),
                i = n("6eeb"),
                o = n("b041");
            r || i(Object.prototype, "toString", o, {
                unsafe: !0
            })
        },
        d44e: function(t, e, n) {
            var r = n("9bf2").f,
                i = n("5135"),
                o = n("b622"),
                a = o("toStringTag");
            t.exports = function(t, e, n) {
                t && !i(t = n ? t : t.prototype, a) && r(t, a, {
                    configurable: !0,
                    value: e
                })
            }
        },
        d4af: function(t, e, n) {
            "use strict";
            var r = n("8eb7"),
                i = n("7b3e"),
                o = 10,
                a = 40,
                s = 800;

            function c(t) {
                var e = 0,
                    n = 0,
                    r = 0,
                    i = 0;
                return "detail" in t && (n = t.detail), "wheelDelta" in t && (n = -t.wheelDelta / 120), "wheelDeltaY" in t && (n = -t.wheelDeltaY / 120), "wheelDeltaX" in t && (e = -t.wheelDeltaX / 120), "axis" in t && t.axis === t.HORIZONTAL_AXIS && (e = n, n = 0), r = e * o, i = n * o, "deltaY" in t && (i = t.deltaY), "deltaX" in t && (r = t.deltaX), (r || i) && t.deltaMode && (1 == t.deltaMode ? (r *= a, i *= a) : (r *= s, i *= s)), r && !e && (e = r < 1 ? -1 : 1), i && !n && (n = i < 1 ? -1 : 1), {
                    spinX: e,
                    spinY: n,
                    pixelX: r,
                    pixelY: i
                }
            }
            c.getEventType = function() {
                return r.firefox() ? "DOMMouseScroll" : i("wheel") ? "wheel" : "mousewheel"
            }, t.exports = c
        },
        d4ec: function(t, e, n) {
            "use strict";

            function r(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }
            n.d(e, "a", (function() {
                return r
            }))
        },
        d58f: function(t, e, n) {
            var r = n("1c0b"),
                i = n("7b0b"),
                o = n("44ad"),
                a = n("50c4"),
                s = function(t) {
                    return function(e, n, s, c) {
                        r(n);
                        var l = i(e),
                            u = o(l),
                            h = a(l.length),
                            d = t ? h - 1 : 0,
                            p = t ? -1 : 1;
                        if (s < 2)
                            while (1) {
                                if (d in u) {
                                    c = u[d], d += p;
                                    break
                                }
                                if (d += p, t ? d < 0 : h <= d) throw TypeError("Reduce of empty array with no initial value")
                            }
                        for (; t ? d >= 0 : h > d; d += p) d in u && (c = n(c, u[d], d, l));
                        return c
                    }
                };
            t.exports = {
                left: s(!1),
                right: s(!0)
            }
        },
        d5d6: function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("b727").forEach,
                o = r.aTypedArray,
                a = r.exportTypedArrayMethod;
            a("forEach", (function(t) {
                i(o(this), t, arguments.length > 1 ? arguments[1] : void 0)
            }))
        },
        d784: function(t, e, n) {
            "use strict";
            n("ac1f");
            var r = n("6eeb"),
                i = n("d039"),
                o = n("b622"),
                a = n("9263"),
                s = n("9112"),
                c = o("species"),
                l = !i((function() {
                    var t = /./;
                    return t.exec = function() {
                        var t = [];
                        return t.groups = {
                            a: "7"
                        }, t
                    }, "7" !== "".replace(t, "$<a>")
                })),
                u = function() {
                    return "$0" === "a".replace(/./, "$0")
                }(),
                h = o("replace"),
                d = function() {
                    return !!/./ [h] && "" === /./ [h]("a", "$0")
                }(),
                p = !i((function() {
                    var t = /(?:)/,
                        e = t.exec;
                    t.exec = function() {
                        return e.apply(this, arguments)
                    };
                    var n = "ab".split(t);
                    return 2 !== n.length || "a" !== n[0] || "b" !== n[1]
                }));
            t.exports = function(t, e, n, h) {
                var f = o(t),
                    m = !i((function() {
                        var e = {};
                        return e[f] = function() {
                            return 7
                        }, 7 != "" [t](e)
                    })),
                    g = m && !i((function() {
                        var e = !1,
                            n = /a/;
                        return "split" === t && (n = {}, n.constructor = {}, n.constructor[c] = function() {
                            return n
                        }, n.flags = "", n[f] = /./ [f]), n.exec = function() {
                            return e = !0, null
                        }, n[f](""), !e
                    }));
                if (!m || !g || "replace" === t && (!l || !u || d) || "split" === t && !p) {
                    var v = /./ [f],
                        y = n(f, "" [t], (function(t, e, n, r, i) {
                            return e.exec === a ? m && !i ? {
                                done: !0,
                                value: v.call(e, n, r)
                            } : {
                                done: !0,
                                value: t.call(n, e, r)
                            } : {
                                done: !1
                            }
                        }), {
                            REPLACE_KEEPS_$0: u,
                            REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: d
                        }),
                        _ = y[0],
                        b = y[1];
                    r(String.prototype, t, _), r(RegExp.prototype, f, 2 == e ? function(t, e) {
                        return b.call(t, this, e)
                    } : function(t) {
                        return b.call(t, this)
                    })
                }
                h && s(RegExp.prototype[f], "sham", !0)
            }
        },
        d81d: function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("b727").map,
                o = n("1dde"),
                a = n("ae40"),
                s = o("map"),
                c = a("map");
            r({
                target: "Array",
                proto: !0,
                forced: !s || !c
            }, {
                map: function(t) {
                    return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
                }
            })
        },
        da84: function(t, e, n) {
            (function(e) {
                var n = function(t) {
                    return t && t.Math == Math && t
                };
                t.exports = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof e && e) || Function("return this")()
            }).call(this, n("c8ba"))
        },
        dbb4: function(t, e, n) {
            var r = n("23e7"),
                i = n("83ab"),
                o = n("56ef"),
                a = n("fc6a"),
                s = n("06cf"),
                c = n("8418");
            r({
                target: "Object",
                stat: !0,
                sham: !i
            }, {
                getOwnPropertyDescriptors: function(t) {
                    var e, n, r = a(t),
                        i = s.f,
                        l = o(r),
                        u = {},
                        h = 0;
                    while (l.length > h) n = i(r, e = l[h++]), void 0 !== n && c(u, e, n);
                    return u
                }
            })
        },
        ddb0: function(t, e, n) {
            var r = n("da84"),
                i = n("fdbc"),
                o = n("e260"),
                a = n("9112"),
                s = n("b622"),
                c = s("iterator"),
                l = s("toStringTag"),
                u = o.values;
            for (var h in i) {
                var d = r[h],
                    p = d && d.prototype;
                if (p) {
                    if (p[c] !== u) try {
                        a(p, c, u)
                    } catch (m) {
                        p[c] = u
                    }
                    if (p[l] || a(p, l, h), i[h])
                        for (var f in o)
                            if (p[f] !== o[f]) try {
                                a(p, f, o[f])
                            } catch (m) {
                                p[f] = o[f]
                            }
                }
            }
        },
        df75: function(t, e, n) {
            var r = n("ca84"),
                i = n("7839");
            t.exports = Object.keys || function(t) {
                return r(t, i)
            }
        },
        e01a: function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("83ab"),
                o = n("da84"),
                a = n("5135"),
                s = n("861d"),
                c = n("9bf2").f,
                l = n("e893"),
                u = o.Symbol;
            if (i && "function" == typeof u && (!("description" in u.prototype) || void 0 !== u().description)) {
                var h = {},
                    d = function() {
                        var t = arguments.length < 1 || void 0 === arguments[0] ? void 0 : String(arguments[0]),
                            e = this instanceof d ? new u(t) : void 0 === t ? u() : u(t);
                        return "" === t && (h[e] = !0), e
                    };
                l(d, u);
                var p = d.prototype = u.prototype;
                p.constructor = d;
                var f = p.toString,
                    m = "Symbol(test)" == String(u("test")),
                    g = /^Symbol\((.*)\)[^)]+$/;
                c(p, "description", {
                    configurable: !0,
                    get: function() {
                        var t = s(this) ? this.valueOf() : this,
                            e = f.call(t);
                        if (a(h, t)) return "";
                        var n = m ? e.slice(7, -1) : e.replace(g, "$1");
                        return "" === n ? void 0 : n
                    }
                }), r({
                    global: !0,
                    forced: !0
                }, {
                    Symbol: d
                })
            }
        },
        e163: function(t, e, n) {
            var r = n("5135"),
                i = n("7b0b"),
                o = n("f772"),
                a = n("e177"),
                s = o("IE_PROTO"),
                c = Object.prototype;
            t.exports = a ? Object.getPrototypeOf : function(t) {
                return t = i(t), r(t, s) ? t[s] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? c : null
            }
        },
        e177: function(t, e, n) {
            var r = n("d039");
            t.exports = !r((function() {
                function t() {}
                return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype
            }))
        },
        e260: function(t, e, n) {
            "use strict";
            var r = n("fc6a"),
                i = n("44d2"),
                o = n("3f8c"),
                a = n("69f3"),
                s = n("7dd0"),
                c = "Array Iterator",
                l = a.set,
                u = a.getterFor(c);
            t.exports = s(Array, "Array", (function(t, e) {
                l(this, {
                    type: c,
                    target: r(t),
                    index: 0,
                    kind: e
                })
            }), (function() {
                var t = u(this),
                    e = t.target,
                    n = t.kind,
                    r = t.index++;
                return !e || r >= e.length ? (t.target = void 0, {
                    value: void 0,
                    done: !0
                }) : "keys" == n ? {
                    value: r,
                    done: !1
                } : "values" == n ? {
                    value: e[r],
                    done: !1
                } : {
                    value: [r, e[r]],
                    done: !1
                }
            }), "values"), o.Arguments = o.Array, i("keys"), i("values"), i("entries")
        },
        e2cc: function(t, e, n) {
            var r = n("6eeb");
            t.exports = function(t, e, n) {
                for (var i in e) r(t, i, e[i], n);
                return t
            }
        },
        e439: function(t, e, n) {
            var r = n("23e7"),
                i = n("d039"),
                o = n("fc6a"),
                a = n("06cf").f,
                s = n("83ab"),
                c = i((function() {
                    a(1)
                })),
                l = !s || c;
            r({
                target: "Object",
                stat: !0,
                forced: l,
                sham: !s
            }, {
                getOwnPropertyDescriptor: function(t, e) {
                    return a(o(t), e)
                }
            })
        },
        e538: function(t, e, n) {
            var r = n("b622");
            e.f = r
        },
        e58c: function(t, e, n) {
            "use strict";
            var r = n("fc6a"),
                i = n("a691"),
                o = n("50c4"),
                a = n("a640"),
                s = n("ae40"),
                c = Math.min,
                l = [].lastIndexOf,
                u = !!l && 1 / [1].lastIndexOf(1, -0) < 0,
                h = a("lastIndexOf"),
                d = s("indexOf", {
                    ACCESSORS: !0,
                    1: 0
                }),
                p = u || !h || !d;
            t.exports = p ? function(t) {
                if (u) return l.apply(this, arguments) || 0;
                var e = r(this),
                    n = o(e.length),
                    a = n - 1;
                for (arguments.length > 1 && (a = c(a, i(arguments[1]))), a < 0 && (a = n + a); a >= 0; a--)
                    if (a in e && e[a] === t) return a || 0;
                return -1
            } : l
        },
        e667: function(t, e) {
            t.exports = function(t) {
                try {
                    return {
                        error: !1,
                        value: t()
                    }
                } catch (e) {
                    return {
                        error: !0,
                        value: e
                    }
                }
            }
        },
        e6cf: function(t, e, n) {
            "use strict";
            var r, i, o, a, s = n("23e7"),
                c = n("c430"),
                l = n("da84"),
                u = n("d066"),
                h = n("fea9"),
                d = n("6eeb"),
                p = n("e2cc"),
                f = n("d44e"),
                m = n("2626"),
                g = n("861d"),
                v = n("1c0b"),
                y = n("19aa"),
                _ = n("c6b6"),
                b = n("8925"),
                x = n("2266"),
                w = n("1c7e"),
                M = n("4840"),
                T = n("2cf4").set,
                S = n("b575"),
                E = n("cdf9"),
                A = n("44de"),
                L = n("f069"),
                R = n("e667"),
                C = n("69f3"),
                O = n("94ca"),
                P = n("b622"),
                I = n("2d00"),
                N = P("species"),
                D = "Promise",
                k = C.get,
                F = C.set,
                B = C.getterFor(D),
                U = h,
                H = l.TypeError,
                z = l.document,
                j = l.process,
                G = u("fetch"),
                V = L.f,
                W = V,
                X = "process" == _(j),
                q = !!(z && z.createEvent && l.dispatchEvent),
                Y = "unhandledrejection",
                $ = "rejectionhandled",
                Z = 0,
                J = 1,
                K = 2,
                Q = 1,
                tt = 2,
                et = O(D, (function() {
                    var t = b(U) !== String(U);
                    if (!t) {
                        if (66 === I) return !0;
                        if (!X && "function" != typeof PromiseRejectionEvent) return !0
                    }
                    if (c && !U.prototype["finally"]) return !0;
                    if (I >= 51 && /native code/.test(U)) return !1;
                    var e = U.resolve(1),
                        n = function(t) {
                            t((function() {}), (function() {}))
                        },
                        r = e.constructor = {};
                    return r[N] = n, !(e.then((function() {})) instanceof n)
                })),
                nt = et || !w((function(t) {
                    U.all(t)["catch"]((function() {}))
                })),
                rt = function(t) {
                    var e;
                    return !(!g(t) || "function" != typeof(e = t.then)) && e
                },
                it = function(t, e, n) {
                    if (!e.notified) {
                        e.notified = !0;
                        var r = e.reactions;
                        S((function() {
                            var i = e.value,
                                o = e.state == J,
                                a = 0;
                            while (r.length > a) {
                                var s, c, l, u = r[a++],
                                    h = o ? u.ok : u.fail,
                                    d = u.resolve,
                                    p = u.reject,
                                    f = u.domain;
                                try {
                                    h ? (o || (e.rejection === tt && ct(t, e), e.rejection = Q), !0 === h ? s = i : (f && f.enter(), s = h(i), f && (f.exit(), l = !0)), s === u.promise ? p(H("Promise-chain cycle")) : (c = rt(s)) ? c.call(s, d, p) : d(s)) : p(i)
                                } catch (m) {
                                    f && !l && f.exit(), p(m)
                                }
                            }
                            e.reactions = [], e.notified = !1, n && !e.rejection && at(t, e)
                        }))
                    }
                },
                ot = function(t, e, n) {
                    var r, i;
                    q ? (r = z.createEvent("Event"), r.promise = e, r.reason = n, r.initEvent(t, !1, !0), l.dispatchEvent(r)) : r = {
                        promise: e,
                        reason: n
                    }, (i = l["on" + t]) ? i(r) : t === Y && A("Unhandled promise rejection", n)
                },
                at = function(t, e) {
                    T.call(l, (function() {
                        var n, r = e.value,
                            i = st(e);
                        if (i && (n = R((function() {
                                X ? j.emit("unhandledRejection", r, t) : ot(Y, t, r)
                            })), e.rejection = X || st(e) ? tt : Q, n.error)) throw n.value
                    }))
                },
                st = function(t) {
                    return t.rejection !== Q && !t.parent
                },
                ct = function(t, e) {
                    T.call(l, (function() {
                        X ? j.emit("rejectionHandled", t) : ot($, t, e.value)
                    }))
                },
                lt = function(t, e, n, r) {
                    return function(i) {
                        t(e, n, i, r)
                    }
                },
                ut = function(t, e, n, r) {
                    e.done || (e.done = !0, r && (e = r), e.value = n, e.state = K, it(t, e, !0))
                },
                ht = function(t, e, n, r) {
                    if (!e.done) {
                        e.done = !0, r && (e = r);
                        try {
                            if (t === n) throw H("Promise can't be resolved itself");
                            var i = rt(n);
                            i ? S((function() {
                                var r = {
                                    done: !1
                                };
                                try {
                                    i.call(n, lt(ht, t, r, e), lt(ut, t, r, e))
                                } catch (o) {
                                    ut(t, r, o, e)
                                }
                            })) : (e.value = n, e.state = J, it(t, e, !1))
                        } catch (o) {
                            ut(t, {
                                done: !1
                            }, o, e)
                        }
                    }
                };
            et && (U = function(t) {
                y(this, U, D), v(t), r.call(this);
                var e = k(this);
                try {
                    t(lt(ht, this, e), lt(ut, this, e))
                } catch (n) {
                    ut(this, e, n)
                }
            }, r = function(t) {
                F(this, {
                    type: D,
                    done: !1,
                    notified: !1,
                    parent: !1,
                    reactions: [],
                    rejection: !1,
                    state: Z,
                    value: void 0
                })
            }, r.prototype = p(U.prototype, {
                then: function(t, e) {
                    var n = B(this),
                        r = V(M(this, U));
                    return r.ok = "function" != typeof t || t, r.fail = "function" == typeof e && e, r.domain = X ? j.domain : void 0, n.parent = !0, n.reactions.push(r), n.state != Z && it(this, n, !1), r.promise
                },
                catch: function(t) {
                    return this.then(void 0, t)
                }
            }), i = function() {
                var t = new r,
                    e = k(t);
                this.promise = t, this.resolve = lt(ht, t, e), this.reject = lt(ut, t, e)
            }, L.f = V = function(t) {
                return t === U || t === o ? new i(t) : W(t)
            }, c || "function" != typeof h || (a = h.prototype.then, d(h.prototype, "then", (function(t, e) {
                var n = this;
                return new U((function(t, e) {
                    a.call(n, t, e)
                })).then(t, e)
            }), {
                unsafe: !0
            }), "function" == typeof G && s({
                global: !0,
                enumerable: !0,
                forced: !0
            }, {
                fetch: function(t) {
                    return E(U, G.apply(l, arguments))
                }
            }))), s({
                global: !0,
                wrap: !0,
                forced: et
            }, {
                Promise: U
            }), f(U, D, !1, !0), m(D), o = u(D), s({
                target: D,
                stat: !0,
                forced: et
            }, {
                reject: function(t) {
                    var e = V(this);
                    return e.reject.call(void 0, t), e.promise
                }
            }), s({
                target: D,
                stat: !0,
                forced: c || et
            }, {
                resolve: function(t) {
                    return E(c && this === o ? U : this, t)
                }
            }), s({
                target: D,
                stat: !0,
                forced: nt
            }, {
                all: function(t) {
                    var e = this,
                        n = V(e),
                        r = n.resolve,
                        i = n.reject,
                        o = R((function() {
                            var n = v(e.resolve),
                                o = [],
                                a = 0,
                                s = 1;
                            x(t, (function(t) {
                                var c = a++,
                                    l = !1;
                                o.push(void 0), s++, n.call(e, t).then((function(t) {
                                    l || (l = !0, o[c] = t, --s || r(o))
                                }), i)
                            })), --s || r(o)
                        }));
                    return o.error && i(o.value), n.promise
                },
                race: function(t) {
                    var e = this,
                        n = V(e),
                        r = n.reject,
                        i = R((function() {
                            var i = v(e.resolve);
                            x(t, (function(t) {
                                i.call(e, t).then(n.resolve, r)
                            }))
                        }));
                    return i.error && r(i.value), n.promise
                }
            })
        },
        e893: function(t, e, n) {
            var r = n("5135"),
                i = n("56ef"),
                o = n("06cf"),
                a = n("9bf2");
            t.exports = function(t, e) {
                for (var n = i(e), s = a.f, c = o.f, l = 0; l < n.length; l++) {
                    var u = n[l];
                    r(t, u) || s(t, u, c(e, u))
                }
            }
        },
        e8b5: function(t, e, n) {
            var r = n("c6b6");
            t.exports = Array.isArray || function(t) {
                return "Array" == r(t)
            }
        },
        e91f: function(t, e, n) {
            "use strict";
            var r = n("ebb5"),
                i = n("4d64").indexOf,
                o = r.aTypedArray,
                a = r.exportTypedArrayMethod;
            a("indexOf", (function(t) {
                return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0)
            }))
        },
        e95a: function(t, e, n) {
            var r = n("b622"),
                i = n("3f8c"),
                o = r("iterator"),
                a = Array.prototype;
            t.exports = function(t) {
                return void 0 !== t && (i.Array === t || a[o] === t)
            }
        },
        ebb5: function(t, e, n) {
            "use strict";
            var r, i = n("a981"),
                o = n("83ab"),
                a = n("da84"),
                s = n("861d"),
                c = n("5135"),
                l = n("f5df"),
                u = n("9112"),
                h = n("6eeb"),
                d = n("9bf2").f,
                p = n("e163"),
                f = n("d2bb"),
                m = n("b622"),
                g = n("90e3"),
                v = a.Int8Array,
                y = v && v.prototype,
                _ = a.Uint8ClampedArray,
                b = _ && _.prototype,
                x = v && p(v),
                w = y && p(y),
                M = Object.prototype,
                T = M.isPrototypeOf,
                S = m("toStringTag"),
                E = g("TYPED_ARRAY_TAG"),
                A = i && !!f && "Opera" !== l(a.opera),
                L = !1,
                R = {
                    Int8Array: 1,
                    Uint8Array: 1,
                    Uint8ClampedArray: 1,
                    Int16Array: 2,
                    Uint16Array: 2,
                    Int32Array: 4,
                    Uint32Array: 4,
                    Float32Array: 4,
                    Float64Array: 8
                },
                C = function(t) {
                    var e = l(t);
                    return "DataView" === e || c(R, e)
                },
                O = function(t) {
                    return s(t) && c(R, l(t))
                },
                P = function(t) {
                    if (O(t)) return t;
                    throw TypeError("Target is not a typed array")
                },
                I = function(t) {
                    if (f) {
                        if (T.call(x, t)) return t
                    } else
                        for (var e in R)
                            if (c(R, r)) {
                                var n = a[e];
                                if (n && (t === n || T.call(n, t))) return t
                            } throw TypeError("Target is not a typed array constructor")
                },
                N = function(t, e, n) {
                    if (o) {
                        if (n)
                            for (var r in R) {
                                var i = a[r];
                                i && c(i.prototype, t) && delete i.prototype[t]
                            }
                        w[t] && !n || h(w, t, n ? e : A && y[t] || e)
                    }
                },
                D = function(t, e, n) {
                    var r, i;
                    if (o) {
                        if (f) {
                            if (n)
                                for (r in R) i = a[r], i && c(i, t) && delete i[t];
                            if (x[t] && !n) return;
                            try {
                                return h(x, t, n ? e : A && v[t] || e)
                            } catch (s) {}
                        }
                        for (r in R) i = a[r], !i || i[t] && !n || h(i, t, e)
                    }
                };
            for (r in R) a[r] || (A = !1);
            if ((!A || "function" != typeof x || x === Function.prototype) && (x = function() {
                    throw TypeError("Incorrect invocation")
                }, A))
                for (r in R) a[r] && f(a[r], x);
            if ((!A || !w || w === M) && (w = x.prototype, A))
                for (r in R) a[r] && f(a[r].prototype, w);
            if (A && p(b) !== w && f(b, w), o && !c(w, S))
                for (r in L = !0, d(w, S, {
                        get: function() {
                            return s(this) ? this[E] : void 0
                        }
                    }), R) a[r] && u(a[r], E, r);
            t.exports = {
                NATIVE_ARRAY_BUFFER_VIEWS: A,
                TYPED_ARRAY_TAG: L && E,
                aTypedArray: P,
                aTypedArrayConstructor: I,
                exportTypedArrayMethod: N,
                exportTypedArrayStaticMethod: D,
                isView: C,
                isTypedArray: O,
                TypedArray: x,
                TypedArrayPrototype: w
            }
        },
        f069: function(t, e, n) {
            "use strict";
            var r = n("1c0b"),
                i = function(t) {
                    var e, n;
                    this.promise = new t((function(t, r) {
                        if (void 0 !== e || void 0 !== n) throw TypeError("Bad Promise constructor");
                        e = t, n = r
                    })), this.resolve = r(e), this.reject = r(n)
                };
            t.exports.f = function(t) {
                return new i(t)
            }
        },
        f5df: function(t, e, n) {
            var r = n("00ee"),
                i = n("c6b6"),
                o = n("b622"),
                a = o("toStringTag"),
                s = "Arguments" == i(function() {
                    return arguments
                }()),
                c = function(t, e) {
                    try {
                        return t[e]
                    } catch (n) {}
                };
            t.exports = r ? i : function(t) {
                var e, n, r;
                return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof(n = c(e = Object(t), a)) ? n : s ? i(e) : "Object" == (r = i(e)) && "function" == typeof e.callee ? "Arguments" : r
            }
        },
        f772: function(t, e, n) {
            var r = n("5692"),
                i = n("90e3"),
                o = r("keys");
            t.exports = function(t) {
                return o[t] || (o[t] = i(t))
            }
        },
        f8cd: function(t, e, n) {
            var r = n("a691");
            t.exports = function(t) {
                var e = r(t);
                if (e < 0) throw RangeError("The argument can't be less than 0");
                return e
            }
        },
        fb2c: function(t, e, n) {
            var r = n("74e8");
            r("Uint32", (function(t) {
                return function(e, n, r) {
                    return t(this, e, n, r)
                }
            }))
        },
        fb6a: function(t, e, n) {
            "use strict";
            var r = n("23e7"),
                i = n("861d"),
                o = n("e8b5"),
                a = n("23cb"),
                s = n("50c4"),
                c = n("fc6a"),
                l = n("8418"),
                u = n("b622"),
                h = n("1dde"),
                d = n("ae40"),
                p = h("slice"),
                f = d("slice", {
                    ACCESSORS: !0,
                    0: 0,
                    1: 2
                }),
                m = u("species"),
                g = [].slice,
                v = Math.max;
            r({
                target: "Array",
                proto: !0,
                forced: !p || !f
            }, {
                slice: function(t, e) {
                    var n, r, u, h = c(this),
                        d = s(h.length),
                        p = a(t, d),
                        f = a(void 0 === e ? d : e, d);
                    if (o(h) && (n = h.constructor, "function" != typeof n || n !== Array && !o(n.prototype) ? i(n) && (n = n[m], null === n && (n = void 0)) : n = void 0, n === Array || void 0 === n)) return g.call(h, p, f);
                    for (r = new(void 0 === n ? Array : n)(v(f - p, 0)), u = 0; p < f; p++, u++) p in h && l(r, u, h[p]);
                    return r.length = u, r
                }
            })
        },
        fc6a: function(t, e, n) {
            var r = n("44ad"),
                i = n("1d80");
            t.exports = function(t) {
                return r(i(t))
            }
        },
        fdbc: function(t, e) {
            t.exports = {
                CSSRuleList: 0,
                CSSStyleDeclaration: 0,
                CSSValueList: 0,
                ClientRectList: 0,
                DOMRectList: 0,
                DOMStringList: 0,
                DOMTokenList: 1,
                DataTransferItemList: 0,
                FileList: 0,
                HTMLAllCollection: 0,
                HTMLCollection: 0,
                HTMLFormElement: 0,
                HTMLSelectElement: 0,
                MediaList: 0,
                MimeTypeArray: 0,
                NamedNodeMap: 0,
                NodeList: 1,
                PaintRequestList: 0,
                Plugin: 0,
                PluginArray: 0,
                SVGLengthList: 0,
                SVGNumberList: 0,
                SVGPathSegList: 0,
                SVGPointList: 0,
                SVGStringList: 0,
                SVGTransformList: 0,
                SourceBufferList: 0,
                StyleSheetList: 0,
                TextTrackCueList: 0,
                TextTrackList: 0,
                TouchList: 0
            }
        },
        fdbf: function(t, e, n) {
            var r = n("4930");
            t.exports = r && !Symbol.sham && "symbol" == typeof Symbol.iterator
        },
        fea9: function(t, e, n) {
            var r = n("da84");
            t.exports = r.Promise
        }
    }
]);